// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GatingSet.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_GatingSet_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_GatingSet_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_GatingSet_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_GatingSet_2eproto;
namespace pb {
class BOOL_GATE_OP;
class BOOL_GATE_OPDefaultTypeInternal;
extern BOOL_GATE_OPDefaultTypeInternal _BOOL_GATE_OP_default_instance_;
class COMP;
class COMPDefaultTypeInternal;
extern COMPDefaultTypeInternal _COMP_default_instance_;
class CytoFrame;
class CytoFrameDefaultTypeInternal;
extern CytoFrameDefaultTypeInternal _CytoFrame_default_instance_;
class GatingHierarchy;
class GatingHierarchyDefaultTypeInternal;
extern GatingHierarchyDefaultTypeInternal _GatingHierarchy_default_instance_;
class GatingSet;
class GatingSetDefaultTypeInternal;
extern GatingSetDefaultTypeInternal _GatingSet_default_instance_;
class PARAM;
class PARAMDefaultTypeInternal;
extern PARAMDefaultTypeInternal _PARAM_default_instance_;
class POPINDICES;
class POPINDICESDefaultTypeInternal;
extern POPINDICESDefaultTypeInternal _POPINDICES_default_instance_;
class POPSTATS;
class POPSTATSDefaultTypeInternal;
extern POPSTATSDefaultTypeInternal _POPSTATS_default_instance_;
class TRANS_TBL;
class TRANS_TBLDefaultTypeInternal;
extern TRANS_TBLDefaultTypeInternal _TRANS_TBL_default_instance_;
class biexpTrans;
class biexpTransDefaultTypeInternal;
extern biexpTransDefaultTypeInternal _biexpTrans_default_instance_;
class boolGate;
class boolGateDefaultTypeInternal;
extern boolGateDefaultTypeInternal _boolGate_default_instance_;
class calibrationTable;
class calibrationTableDefaultTypeInternal;
extern calibrationTableDefaultTypeInternal _calibrationTable_default_instance_;
class clusterGate;
class clusterGateDefaultTypeInternal;
extern clusterGateDefaultTypeInternal _clusterGate_default_instance_;
class coordinate;
class coordinateDefaultTypeInternal;
extern coordinateDefaultTypeInternal _coordinate_default_instance_;
class ellipseGate;
class ellipseGateDefaultTypeInternal;
extern ellipseGateDefaultTypeInternal _ellipseGate_default_instance_;
class fasinhTrans;
class fasinhTransDefaultTypeInternal;
extern fasinhTransDefaultTypeInternal _fasinhTrans_default_instance_;
class flinTrans;
class flinTransDefaultTypeInternal;
extern flinTransDefaultTypeInternal _flinTrans_default_instance_;
class gate;
class gateDefaultTypeInternal;
extern gateDefaultTypeInternal _gate_default_instance_;
class logGML2Trans;
class logGML2TransDefaultTypeInternal;
extern logGML2TransDefaultTypeInternal _logGML2Trans_default_instance_;
class logTrans;
class logTransDefaultTypeInternal;
extern logTransDefaultTypeInternal _logTrans_default_instance_;
class logicleTrans;
class logicleTransDefaultTypeInternal;
extern logicleTransDefaultTypeInternal _logicleTrans_default_instance_;
class nodeProperties;
class nodePropertiesDefaultTypeInternal;
extern nodePropertiesDefaultTypeInternal _nodeProperties_default_instance_;
class paramPoly;
class paramPolyDefaultTypeInternal;
extern paramPolyDefaultTypeInternal _paramPoly_default_instance_;
class paramRange;
class paramRangeDefaultTypeInternal;
extern paramRangeDefaultTypeInternal _paramRange_default_instance_;
class polygonGate;
class polygonGateDefaultTypeInternal;
extern polygonGateDefaultTypeInternal _polygonGate_default_instance_;
class populationTree;
class populationTreeDefaultTypeInternal;
extern populationTreeDefaultTypeInternal _populationTree_default_instance_;
class quadGate;
class quadGateDefaultTypeInternal;
extern quadGateDefaultTypeInternal _quadGate_default_instance_;
class rangeGate;
class rangeGateDefaultTypeInternal;
extern rangeGateDefaultTypeInternal _rangeGate_default_instance_;
class scaleTrans;
class scaleTransDefaultTypeInternal;
extern scaleTransDefaultTypeInternal _scaleTrans_default_instance_;
class trans_local;
class trans_localDefaultTypeInternal;
extern trans_localDefaultTypeInternal _trans_local_default_instance_;
class trans_pair;
class trans_pairDefaultTypeInternal;
extern trans_pairDefaultTypeInternal _trans_pair_default_instance_;
class transformation;
class transformationDefaultTypeInternal;
extern transformationDefaultTypeInternal _transformation_default_instance_;
class treeNodes;
class treeNodesDefaultTypeInternal;
extern treeNodesDefaultTypeInternal _treeNodes_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::BOOL_GATE_OP* Arena::CreateMaybeMessage<::pb::BOOL_GATE_OP>(Arena*);
template<> ::pb::COMP* Arena::CreateMaybeMessage<::pb::COMP>(Arena*);
template<> ::pb::CytoFrame* Arena::CreateMaybeMessage<::pb::CytoFrame>(Arena*);
template<> ::pb::GatingHierarchy* Arena::CreateMaybeMessage<::pb::GatingHierarchy>(Arena*);
template<> ::pb::GatingSet* Arena::CreateMaybeMessage<::pb::GatingSet>(Arena*);
template<> ::pb::PARAM* Arena::CreateMaybeMessage<::pb::PARAM>(Arena*);
template<> ::pb::POPINDICES* Arena::CreateMaybeMessage<::pb::POPINDICES>(Arena*);
template<> ::pb::POPSTATS* Arena::CreateMaybeMessage<::pb::POPSTATS>(Arena*);
template<> ::pb::TRANS_TBL* Arena::CreateMaybeMessage<::pb::TRANS_TBL>(Arena*);
template<> ::pb::biexpTrans* Arena::CreateMaybeMessage<::pb::biexpTrans>(Arena*);
template<> ::pb::boolGate* Arena::CreateMaybeMessage<::pb::boolGate>(Arena*);
template<> ::pb::calibrationTable* Arena::CreateMaybeMessage<::pb::calibrationTable>(Arena*);
template<> ::pb::clusterGate* Arena::CreateMaybeMessage<::pb::clusterGate>(Arena*);
template<> ::pb::coordinate* Arena::CreateMaybeMessage<::pb::coordinate>(Arena*);
template<> ::pb::ellipseGate* Arena::CreateMaybeMessage<::pb::ellipseGate>(Arena*);
template<> ::pb::fasinhTrans* Arena::CreateMaybeMessage<::pb::fasinhTrans>(Arena*);
template<> ::pb::flinTrans* Arena::CreateMaybeMessage<::pb::flinTrans>(Arena*);
template<> ::pb::gate* Arena::CreateMaybeMessage<::pb::gate>(Arena*);
template<> ::pb::logGML2Trans* Arena::CreateMaybeMessage<::pb::logGML2Trans>(Arena*);
template<> ::pb::logTrans* Arena::CreateMaybeMessage<::pb::logTrans>(Arena*);
template<> ::pb::logicleTrans* Arena::CreateMaybeMessage<::pb::logicleTrans>(Arena*);
template<> ::pb::nodeProperties* Arena::CreateMaybeMessage<::pb::nodeProperties>(Arena*);
template<> ::pb::paramPoly* Arena::CreateMaybeMessage<::pb::paramPoly>(Arena*);
template<> ::pb::paramRange* Arena::CreateMaybeMessage<::pb::paramRange>(Arena*);
template<> ::pb::polygonGate* Arena::CreateMaybeMessage<::pb::polygonGate>(Arena*);
template<> ::pb::populationTree* Arena::CreateMaybeMessage<::pb::populationTree>(Arena*);
template<> ::pb::quadGate* Arena::CreateMaybeMessage<::pb::quadGate>(Arena*);
template<> ::pb::rangeGate* Arena::CreateMaybeMessage<::pb::rangeGate>(Arena*);
template<> ::pb::scaleTrans* Arena::CreateMaybeMessage<::pb::scaleTrans>(Arena*);
template<> ::pb::trans_local* Arena::CreateMaybeMessage<::pb::trans_local>(Arena*);
template<> ::pb::trans_pair* Arena::CreateMaybeMessage<::pb::trans_pair>(Arena*);
template<> ::pb::transformation* Arena::CreateMaybeMessage<::pb::transformation>(Arena*);
template<> ::pb::treeNodes* Arena::CreateMaybeMessage<::pb::treeNodes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

enum QUADRANT : int {
  Q1 = 1,
  Q2 = 2,
  Q3 = 3,
  Q4 = 4
};
bool QUADRANT_IsValid(int value);
constexpr QUADRANT QUADRANT_MIN = Q1;
constexpr QUADRANT QUADRANT_MAX = Q4;
constexpr int QUADRANT_ARRAYSIZE = QUADRANT_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QUADRANT_descriptor();
template<typename T>
inline const std::string& QUADRANT_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QUADRANT>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QUADRANT_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QUADRANT_descriptor(), enum_t_value);
}
inline bool QUADRANT_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QUADRANT* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QUADRANT>(
    QUADRANT_descriptor(), name, value);
}
enum GATE_TYPE : int {
  POLYGON_GATE = 1,
  RANGE_GATE = 2,
  BOOL_GATE = 3,
  ELLIPSE_GATE = 4,
  RECT_GATE = 5,
  LOGICAL_GATE = 6,
  ELLIPSOID_GATE = 7,
  CLUSTER_GATE = 8,
  QUAD_GATE = 9
};
bool GATE_TYPE_IsValid(int value);
constexpr GATE_TYPE GATE_TYPE_MIN = POLYGON_GATE;
constexpr GATE_TYPE GATE_TYPE_MAX = QUAD_GATE;
constexpr int GATE_TYPE_ARRAYSIZE = GATE_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GATE_TYPE_descriptor();
template<typename T>
inline const std::string& GATE_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GATE_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GATE_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GATE_TYPE_descriptor(), enum_t_value);
}
inline bool GATE_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GATE_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GATE_TYPE>(
    GATE_TYPE_descriptor(), name, value);
}
enum ind_type : int {
  BOOL = 0,
  INT = 1,
  ROOT = 2
};
bool ind_type_IsValid(int value);
constexpr ind_type ind_type_MIN = BOOL;
constexpr ind_type ind_type_MAX = ROOT;
constexpr int ind_type_ARRAYSIZE = ind_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ind_type_descriptor();
template<typename T>
inline const std::string& ind_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ind_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ind_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ind_type_descriptor(), enum_t_value);
}
inline bool ind_type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ind_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ind_type>(
    ind_type_descriptor(), name, value);
}
enum TRANS_TYPE : int {
  PB_CALTBL = 0,
  PB_LOG = 1,
  PB_LIN = 2,
  PB_FLIN = 3,
  PB_FASIGNH = 4,
  PB_BIEXP = 5,
  PB_LOGICLE = 6,
  PB_LOGGML2 = 7,
  PB_SCALE = 8
};
bool TRANS_TYPE_IsValid(int value);
constexpr TRANS_TYPE TRANS_TYPE_MIN = PB_CALTBL;
constexpr TRANS_TYPE TRANS_TYPE_MAX = PB_SCALE;
constexpr int TRANS_TYPE_ARRAYSIZE = TRANS_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TRANS_TYPE_descriptor();
template<typename T>
inline const std::string& TRANS_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TRANS_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TRANS_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TRANS_TYPE_descriptor(), enum_t_value);
}
inline bool TRANS_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TRANS_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TRANS_TYPE>(
    TRANS_TYPE_descriptor(), name, value);
}
// ===================================================================

class paramRange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.paramRange) */ {
 public:
  inline paramRange() : paramRange(nullptr) {}
  virtual ~paramRange();

  paramRange(const paramRange& from);
  paramRange(paramRange&& from) noexcept
    : paramRange() {
    *this = ::std::move(from);
  }

  inline paramRange& operator=(const paramRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline paramRange& operator=(paramRange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const paramRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const paramRange* internal_default_instance() {
    return reinterpret_cast<const paramRange*>(
               &_paramRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(paramRange& a, paramRange& b) {
    a.Swap(&b);
  }
  inline void Swap(paramRange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(paramRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline paramRange* New() const final {
    return CreateMaybeMessage<paramRange>(nullptr);
  }

  paramRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<paramRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const paramRange& from);
  void MergeFrom(const paramRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(paramRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.paramRange";
  }
  protected:
  explicit paramRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required float min = 2;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  float min() const;
  void set_min(float value);
  private:
  float _internal_min() const;
  void _internal_set_min(float value);
  public:

  // required float max = 3;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  float max() const;
  void set_max(float value);
  private:
  float _internal_max() const;
  void _internal_set_max(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.paramRange)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  float min_;
  float max_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class rangeGate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.rangeGate) */ {
 public:
  inline rangeGate() : rangeGate(nullptr) {}
  virtual ~rangeGate();

  rangeGate(const rangeGate& from);
  rangeGate(rangeGate&& from) noexcept
    : rangeGate() {
    *this = ::std::move(from);
  }

  inline rangeGate& operator=(const rangeGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline rangeGate& operator=(rangeGate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const rangeGate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rangeGate* internal_default_instance() {
    return reinterpret_cast<const rangeGate*>(
               &_rangeGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(rangeGate& a, rangeGate& b) {
    a.Swap(&b);
  }
  inline void Swap(rangeGate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rangeGate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline rangeGate* New() const final {
    return CreateMaybeMessage<rangeGate>(nullptr);
  }

  rangeGate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<rangeGate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const rangeGate& from);
  void MergeFrom(const rangeGate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rangeGate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.rangeGate";
  }
  protected:
  explicit rangeGate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 1,
  };
  // required .pb.paramRange param = 1;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::pb::paramRange& param() const;
  ::pb::paramRange* release_param();
  ::pb::paramRange* mutable_param();
  void set_allocated_param(::pb::paramRange* param);
  private:
  const ::pb::paramRange& _internal_param() const;
  ::pb::paramRange* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::pb::paramRange* param);
  ::pb::paramRange* unsafe_arena_release_param();

  // @@protoc_insertion_point(class_scope:pb.rangeGate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pb::paramRange* param_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class paramPoly PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.paramPoly) */ {
 public:
  inline paramPoly() : paramPoly(nullptr) {}
  virtual ~paramPoly();

  paramPoly(const paramPoly& from);
  paramPoly(paramPoly&& from) noexcept
    : paramPoly() {
    *this = ::std::move(from);
  }

  inline paramPoly& operator=(const paramPoly& from) {
    CopyFrom(from);
    return *this;
  }
  inline paramPoly& operator=(paramPoly&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const paramPoly& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const paramPoly* internal_default_instance() {
    return reinterpret_cast<const paramPoly*>(
               &_paramPoly_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(paramPoly& a, paramPoly& b) {
    a.Swap(&b);
  }
  inline void Swap(paramPoly* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(paramPoly* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline paramPoly* New() const final {
    return CreateMaybeMessage<paramPoly>(nullptr);
  }

  paramPoly* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<paramPoly>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const paramPoly& from);
  void MergeFrom(const paramPoly& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(paramPoly* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.paramPoly";
  }
  protected:
  explicit paramPoly(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
    kVerticesFieldNumber = 2,
  };
  // repeated string params = 1;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  const std::string& params(int index) const;
  std::string* mutable_params(int index);
  void set_params(int index, const std::string& value);
  void set_params(int index, std::string&& value);
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, size_t size);
  std::string* add_params();
  void add_params(const std::string& value);
  void add_params(std::string&& value);
  void add_params(const char* value);
  void add_params(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& params() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_params();
  private:
  const std::string& _internal_params(int index) const;
  std::string* _internal_add_params();
  public:

  // repeated .pb.coordinate vertices = 2;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::pb::coordinate* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >*
      mutable_vertices();
  private:
  const ::pb::coordinate& _internal_vertices(int index) const;
  ::pb::coordinate* _internal_add_vertices();
  public:
  const ::pb::coordinate& vertices(int index) const;
  ::pb::coordinate* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >&
      vertices() const;

  // @@protoc_insertion_point(class_scope:pb.paramPoly)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> params_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate > vertices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class polygonGate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.polygonGate) */ {
 public:
  inline polygonGate() : polygonGate(nullptr) {}
  virtual ~polygonGate();

  polygonGate(const polygonGate& from);
  polygonGate(polygonGate&& from) noexcept
    : polygonGate() {
    *this = ::std::move(from);
  }

  inline polygonGate& operator=(const polygonGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline polygonGate& operator=(polygonGate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const polygonGate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const polygonGate* internal_default_instance() {
    return reinterpret_cast<const polygonGate*>(
               &_polygonGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(polygonGate& a, polygonGate& b) {
    a.Swap(&b);
  }
  inline void Swap(polygonGate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(polygonGate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline polygonGate* New() const final {
    return CreateMaybeMessage<polygonGate>(nullptr);
  }

  polygonGate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<polygonGate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const polygonGate& from);
  void MergeFrom(const polygonGate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(polygonGate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.polygonGate";
  }
  protected:
  explicit polygonGate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 1,
    kQgFieldNumber = 2,
  };
  // required .pb.paramPoly param = 1;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::pb::paramPoly& param() const;
  ::pb::paramPoly* release_param();
  ::pb::paramPoly* mutable_param();
  void set_allocated_param(::pb::paramPoly* param);
  private:
  const ::pb::paramPoly& _internal_param() const;
  ::pb::paramPoly* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::pb::paramPoly* param);
  ::pb::paramPoly* unsafe_arena_release_param();

  // optional .pb.quadGate qg = 2;
  bool has_qg() const;
  private:
  bool _internal_has_qg() const;
  public:
  void clear_qg();
  const ::pb::quadGate& qg() const;
  ::pb::quadGate* release_qg();
  ::pb::quadGate* mutable_qg();
  void set_allocated_qg(::pb::quadGate* qg);
  private:
  const ::pb::quadGate& _internal_qg() const;
  ::pb::quadGate* _internal_mutable_qg();
  public:
  void unsafe_arena_set_allocated_qg(
      ::pb::quadGate* qg);
  ::pb::quadGate* unsafe_arena_release_qg();

  // @@protoc_insertion_point(class_scope:pb.polygonGate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pb::paramPoly* param_;
  ::pb::quadGate* qg_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class coordinate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.coordinate) */ {
 public:
  inline coordinate() : coordinate(nullptr) {}
  virtual ~coordinate();

  coordinate(const coordinate& from);
  coordinate(coordinate&& from) noexcept
    : coordinate() {
    *this = ::std::move(from);
  }

  inline coordinate& operator=(const coordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline coordinate& operator=(coordinate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const coordinate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const coordinate* internal_default_instance() {
    return reinterpret_cast<const coordinate*>(
               &_coordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(coordinate& a, coordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(coordinate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(coordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline coordinate* New() const final {
    return CreateMaybeMessage<coordinate>(nullptr);
  }

  coordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<coordinate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const coordinate& from);
  void MergeFrom(const coordinate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(coordinate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.coordinate";
  }
  protected:
  explicit coordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.coordinate)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class ellipseGate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ellipseGate) */ {
 public:
  inline ellipseGate() : ellipseGate(nullptr) {}
  virtual ~ellipseGate();

  ellipseGate(const ellipseGate& from);
  ellipseGate(ellipseGate&& from) noexcept
    : ellipseGate() {
    *this = ::std::move(from);
  }

  inline ellipseGate& operator=(const ellipseGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ellipseGate& operator=(ellipseGate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ellipseGate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ellipseGate* internal_default_instance() {
    return reinterpret_cast<const ellipseGate*>(
               &_ellipseGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ellipseGate& a, ellipseGate& b) {
    a.Swap(&b);
  }
  inline void Swap(ellipseGate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ellipseGate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ellipseGate* New() const final {
    return CreateMaybeMessage<ellipseGate>(nullptr);
  }

  ellipseGate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ellipseGate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ellipseGate& from);
  void MergeFrom(const ellipseGate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ellipseGate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ellipseGate";
  }
  protected:
  explicit ellipseGate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovFieldNumber = 2,
    kAntipodalVerticesFieldNumber = 3,
    kMuFieldNumber = 1,
    kDistFieldNumber = 4,
  };
  // repeated .pb.coordinate cov = 2;
  int cov_size() const;
  private:
  int _internal_cov_size() const;
  public:
  void clear_cov();
  ::pb::coordinate* mutable_cov(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >*
      mutable_cov();
  private:
  const ::pb::coordinate& _internal_cov(int index) const;
  ::pb::coordinate* _internal_add_cov();
  public:
  const ::pb::coordinate& cov(int index) const;
  ::pb::coordinate* add_cov();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >&
      cov() const;

  // repeated .pb.coordinate antipodal_vertices = 3;
  int antipodal_vertices_size() const;
  private:
  int _internal_antipodal_vertices_size() const;
  public:
  void clear_antipodal_vertices();
  ::pb::coordinate* mutable_antipodal_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >*
      mutable_antipodal_vertices();
  private:
  const ::pb::coordinate& _internal_antipodal_vertices(int index) const;
  ::pb::coordinate* _internal_add_antipodal_vertices();
  public:
  const ::pb::coordinate& antipodal_vertices(int index) const;
  ::pb::coordinate* add_antipodal_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >&
      antipodal_vertices() const;

  // required .pb.coordinate mu = 1;
  bool has_mu() const;
  private:
  bool _internal_has_mu() const;
  public:
  void clear_mu();
  const ::pb::coordinate& mu() const;
  ::pb::coordinate* release_mu();
  ::pb::coordinate* mutable_mu();
  void set_allocated_mu(::pb::coordinate* mu);
  private:
  const ::pb::coordinate& _internal_mu() const;
  ::pb::coordinate* _internal_mutable_mu();
  public:
  void unsafe_arena_set_allocated_mu(
      ::pb::coordinate* mu);
  ::pb::coordinate* unsafe_arena_release_mu();

  // optional float dist = 4;
  bool has_dist() const;
  private:
  bool _internal_has_dist() const;
  public:
  void clear_dist();
  float dist() const;
  void set_dist(float value);
  private:
  float _internal_dist() const;
  void _internal_set_dist(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.ellipseGate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate > cov_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate > antipodal_vertices_;
  ::pb::coordinate* mu_;
  float dist_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class BOOL_GATE_OP PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.BOOL_GATE_OP) */ {
 public:
  inline BOOL_GATE_OP() : BOOL_GATE_OP(nullptr) {}
  virtual ~BOOL_GATE_OP();

  BOOL_GATE_OP(const BOOL_GATE_OP& from);
  BOOL_GATE_OP(BOOL_GATE_OP&& from) noexcept
    : BOOL_GATE_OP() {
    *this = ::std::move(from);
  }

  inline BOOL_GATE_OP& operator=(const BOOL_GATE_OP& from) {
    CopyFrom(from);
    return *this;
  }
  inline BOOL_GATE_OP& operator=(BOOL_GATE_OP&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BOOL_GATE_OP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BOOL_GATE_OP* internal_default_instance() {
    return reinterpret_cast<const BOOL_GATE_OP*>(
               &_BOOL_GATE_OP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BOOL_GATE_OP& a, BOOL_GATE_OP& b) {
    a.Swap(&b);
  }
  inline void Swap(BOOL_GATE_OP* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BOOL_GATE_OP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BOOL_GATE_OP* New() const final {
    return CreateMaybeMessage<BOOL_GATE_OP>(nullptr);
  }

  BOOL_GATE_OP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BOOL_GATE_OP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BOOL_GATE_OP& from);
  void MergeFrom(const BOOL_GATE_OP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BOOL_GATE_OP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.BOOL_GATE_OP";
  }
  protected:
  explicit BOOL_GATE_OP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kOpFieldNumber = 2,
    kIsNotFieldNumber = 3,
  };
  // repeated string path = 1;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  const std::string& path(int index) const;
  std::string* mutable_path(int index);
  void set_path(int index, const std::string& value);
  void set_path(int index, std::string&& value);
  void set_path(int index, const char* value);
  void set_path(int index, const char* value, size_t size);
  std::string* add_path();
  void add_path(const std::string& value);
  void add_path(std::string&& value);
  void add_path(const char* value);
  void add_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_path();
  private:
  const std::string& _internal_path(int index) const;
  std::string* _internal_add_path();
  public:

  // required uint32 op = 2;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  ::PROTOBUF_NAMESPACE_ID::uint32 op() const;
  void set_op(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_op() const;
  void _internal_set_op(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required bool isNot = 3;
  bool has_isnot() const;
  private:
  bool _internal_has_isnot() const;
  public:
  void clear_isnot();
  bool isnot() const;
  void set_isnot(bool value);
  private:
  bool _internal_isnot() const;
  void _internal_set_isnot(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pb.BOOL_GATE_OP)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> path_;
  ::PROTOBUF_NAMESPACE_ID::uint32 op_;
  bool isnot_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class boolGate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.boolGate) */ {
 public:
  inline boolGate() : boolGate(nullptr) {}
  virtual ~boolGate();

  boolGate(const boolGate& from);
  boolGate(boolGate&& from) noexcept
    : boolGate() {
    *this = ::std::move(from);
  }

  inline boolGate& operator=(const boolGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline boolGate& operator=(boolGate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const boolGate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const boolGate* internal_default_instance() {
    return reinterpret_cast<const boolGate*>(
               &_boolGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(boolGate& a, boolGate& b) {
    a.Swap(&b);
  }
  inline void Swap(boolGate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(boolGate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline boolGate* New() const final {
    return CreateMaybeMessage<boolGate>(nullptr);
  }

  boolGate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<boolGate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const boolGate& from);
  void MergeFrom(const boolGate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(boolGate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.boolGate";
  }
  protected:
  explicit boolGate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolOpSpecFieldNumber = 1,
  };
  // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
  int boolopspec_size() const;
  private:
  int _internal_boolopspec_size() const;
  public:
  void clear_boolopspec();
  ::pb::BOOL_GATE_OP* mutable_boolopspec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::BOOL_GATE_OP >*
      mutable_boolopspec();
  private:
  const ::pb::BOOL_GATE_OP& _internal_boolopspec(int index) const;
  ::pb::BOOL_GATE_OP* _internal_add_boolopspec();
  public:
  const ::pb::BOOL_GATE_OP& boolopspec(int index) const;
  ::pb::BOOL_GATE_OP* add_boolopspec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::BOOL_GATE_OP >&
      boolopspec() const;

  // @@protoc_insertion_point(class_scope:pb.boolGate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::BOOL_GATE_OP > boolopspec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class clusterGate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.clusterGate) */ {
 public:
  inline clusterGate() : clusterGate(nullptr) {}
  virtual ~clusterGate();

  clusterGate(const clusterGate& from);
  clusterGate(clusterGate&& from) noexcept
    : clusterGate() {
    *this = ::std::move(from);
  }

  inline clusterGate& operator=(const clusterGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline clusterGate& operator=(clusterGate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const clusterGate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const clusterGate* internal_default_instance() {
    return reinterpret_cast<const clusterGate*>(
               &_clusterGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(clusterGate& a, clusterGate& b) {
    a.Swap(&b);
  }
  inline void Swap(clusterGate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(clusterGate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline clusterGate* New() const final {
    return CreateMaybeMessage<clusterGate>(nullptr);
  }

  clusterGate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<clusterGate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const clusterGate& from);
  void MergeFrom(const clusterGate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(clusterGate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.clusterGate";
  }
  protected:
  explicit clusterGate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterMethodFieldNumber = 1,
  };
  // required string cluster_method = 1;
  bool has_cluster_method() const;
  private:
  bool _internal_has_cluster_method() const;
  public:
  void clear_cluster_method();
  const std::string& cluster_method() const;
  void set_cluster_method(const std::string& value);
  void set_cluster_method(std::string&& value);
  void set_cluster_method(const char* value);
  void set_cluster_method(const char* value, size_t size);
  std::string* mutable_cluster_method();
  std::string* release_cluster_method();
  void set_allocated_cluster_method(std::string* cluster_method);
  private:
  const std::string& _internal_cluster_method() const;
  void _internal_set_cluster_method(const std::string& value);
  std::string* _internal_mutable_cluster_method();
  public:

  // @@protoc_insertion_point(class_scope:pb.clusterGate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cluster_method_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class quadGate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.quadGate) */ {
 public:
  inline quadGate() : quadGate(nullptr) {}
  virtual ~quadGate();

  quadGate(const quadGate& from);
  quadGate(quadGate&& from) noexcept
    : quadGate() {
    *this = ::std::move(from);
  }

  inline quadGate& operator=(const quadGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline quadGate& operator=(quadGate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const quadGate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const quadGate* internal_default_instance() {
    return reinterpret_cast<const quadGate*>(
               &_quadGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(quadGate& a, quadGate& b) {
    a.Swap(&b);
  }
  inline void Swap(quadGate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(quadGate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline quadGate* New() const final {
    return CreateMaybeMessage<quadGate>(nullptr);
  }

  quadGate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<quadGate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const quadGate& from);
  void MergeFrom(const quadGate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(quadGate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.quadGate";
  }
  protected:
  explicit quadGate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kQuadrantFieldNumber = 3,
  };
  // required string uid = 1;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  void set_uid(const std::string& value);
  void set_uid(std::string&& value);
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  std::string* mutable_uid();
  std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // required .pb.QUADRANT quadrant = 3;
  bool has_quadrant() const;
  private:
  bool _internal_has_quadrant() const;
  public:
  void clear_quadrant();
  ::pb::QUADRANT quadrant() const;
  void set_quadrant(::pb::QUADRANT value);
  private:
  ::pb::QUADRANT _internal_quadrant() const;
  void _internal_set_quadrant(::pb::QUADRANT value);
  public:

  // @@protoc_insertion_point(class_scope:pb.quadGate)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  int quadrant_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class gate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.gate) */ {
 public:
  inline gate() : gate(nullptr) {}
  virtual ~gate();

  gate(const gate& from);
  gate(gate&& from) noexcept
    : gate() {
    *this = ::std::move(from);
  }

  inline gate& operator=(const gate& from) {
    CopyFrom(from);
    return *this;
  }
  inline gate& operator=(gate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const gate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const gate* internal_default_instance() {
    return reinterpret_cast<const gate*>(
               &_gate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(gate& a, gate& b) {
    a.Swap(&b);
  }
  inline void Swap(gate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(gate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline gate* New() const final {
    return CreateMaybeMessage<gate>(nullptr);
  }

  gate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<gate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const gate& from);
  void MergeFrom(const gate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(gate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.gate";
  }
  protected:
  explicit gate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRgFieldNumber = 5,
    kPgFieldNumber = 6,
    kEgFieldNumber = 7,
    kBgFieldNumber = 8,
    kCgFieldNumber = 9,
    kNegFieldNumber = 1,
    kIsTransformedFieldNumber = 2,
    kIsGainedFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // optional .pb.rangeGate rg = 5;
  bool has_rg() const;
  private:
  bool _internal_has_rg() const;
  public:
  void clear_rg();
  const ::pb::rangeGate& rg() const;
  ::pb::rangeGate* release_rg();
  ::pb::rangeGate* mutable_rg();
  void set_allocated_rg(::pb::rangeGate* rg);
  private:
  const ::pb::rangeGate& _internal_rg() const;
  ::pb::rangeGate* _internal_mutable_rg();
  public:
  void unsafe_arena_set_allocated_rg(
      ::pb::rangeGate* rg);
  ::pb::rangeGate* unsafe_arena_release_rg();

  // optional .pb.polygonGate pg = 6;
  bool has_pg() const;
  private:
  bool _internal_has_pg() const;
  public:
  void clear_pg();
  const ::pb::polygonGate& pg() const;
  ::pb::polygonGate* release_pg();
  ::pb::polygonGate* mutable_pg();
  void set_allocated_pg(::pb::polygonGate* pg);
  private:
  const ::pb::polygonGate& _internal_pg() const;
  ::pb::polygonGate* _internal_mutable_pg();
  public:
  void unsafe_arena_set_allocated_pg(
      ::pb::polygonGate* pg);
  ::pb::polygonGate* unsafe_arena_release_pg();

  // optional .pb.ellipseGate eg = 7;
  bool has_eg() const;
  private:
  bool _internal_has_eg() const;
  public:
  void clear_eg();
  const ::pb::ellipseGate& eg() const;
  ::pb::ellipseGate* release_eg();
  ::pb::ellipseGate* mutable_eg();
  void set_allocated_eg(::pb::ellipseGate* eg);
  private:
  const ::pb::ellipseGate& _internal_eg() const;
  ::pb::ellipseGate* _internal_mutable_eg();
  public:
  void unsafe_arena_set_allocated_eg(
      ::pb::ellipseGate* eg);
  ::pb::ellipseGate* unsafe_arena_release_eg();

  // optional .pb.boolGate bg = 8;
  bool has_bg() const;
  private:
  bool _internal_has_bg() const;
  public:
  void clear_bg();
  const ::pb::boolGate& bg() const;
  ::pb::boolGate* release_bg();
  ::pb::boolGate* mutable_bg();
  void set_allocated_bg(::pb::boolGate* bg);
  private:
  const ::pb::boolGate& _internal_bg() const;
  ::pb::boolGate* _internal_mutable_bg();
  public:
  void unsafe_arena_set_allocated_bg(
      ::pb::boolGate* bg);
  ::pb::boolGate* unsafe_arena_release_bg();

  // optional .pb.clusterGate cg = 9;
  bool has_cg() const;
  private:
  bool _internal_has_cg() const;
  public:
  void clear_cg();
  const ::pb::clusterGate& cg() const;
  ::pb::clusterGate* release_cg();
  ::pb::clusterGate* mutable_cg();
  void set_allocated_cg(::pb::clusterGate* cg);
  private:
  const ::pb::clusterGate& _internal_cg() const;
  ::pb::clusterGate* _internal_mutable_cg();
  public:
  void unsafe_arena_set_allocated_cg(
      ::pb::clusterGate* cg);
  ::pb::clusterGate* unsafe_arena_release_cg();

  // required bool neg = 1;
  bool has_neg() const;
  private:
  bool _internal_has_neg() const;
  public:
  void clear_neg();
  bool neg() const;
  void set_neg(bool value);
  private:
  bool _internal_neg() const;
  void _internal_set_neg(bool value);
  public:

  // required bool isTransformed = 2;
  bool has_istransformed() const;
  private:
  bool _internal_has_istransformed() const;
  public:
  void clear_istransformed();
  bool istransformed() const;
  void set_istransformed(bool value);
  private:
  bool _internal_istransformed() const;
  void _internal_set_istransformed(bool value);
  public:

  // required bool isGained = 3;
  bool has_isgained() const;
  private:
  bool _internal_has_isgained() const;
  public:
  void clear_isgained();
  bool isgained() const;
  void set_isgained(bool value);
  private:
  bool _internal_isgained() const;
  void _internal_set_isgained(bool value);
  public:

  // required .pb.GATE_TYPE type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pb::GATE_TYPE type() const;
  void set_type(::pb::GATE_TYPE value);
  private:
  ::pb::GATE_TYPE _internal_type() const;
  void _internal_set_type(::pb::GATE_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:pb.gate)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pb::rangeGate* rg_;
  ::pb::polygonGate* pg_;
  ::pb::ellipseGate* eg_;
  ::pb::boolGate* bg_;
  ::pb::clusterGate* cg_;
  bool neg_;
  bool istransformed_;
  bool isgained_;
  int type_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class POPSTATS PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.POPSTATS) */ {
 public:
  inline POPSTATS() : POPSTATS(nullptr) {}
  virtual ~POPSTATS();

  POPSTATS(const POPSTATS& from);
  POPSTATS(POPSTATS&& from) noexcept
    : POPSTATS() {
    *this = ::std::move(from);
  }

  inline POPSTATS& operator=(const POPSTATS& from) {
    CopyFrom(from);
    return *this;
  }
  inline POPSTATS& operator=(POPSTATS&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const POPSTATS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const POPSTATS* internal_default_instance() {
    return reinterpret_cast<const POPSTATS*>(
               &_POPSTATS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(POPSTATS& a, POPSTATS& b) {
    a.Swap(&b);
  }
  inline void Swap(POPSTATS* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(POPSTATS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline POPSTATS* New() const final {
    return CreateMaybeMessage<POPSTATS>(nullptr);
  }

  POPSTATS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<POPSTATS>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const POPSTATS& from);
  void MergeFrom(const POPSTATS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(POPSTATS* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.POPSTATS";
  }
  protected:
  explicit POPSTATS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatTypeFieldNumber = 1,
    kStatValFieldNumber = 2,
  };
  // required string statType = 1;
  bool has_stattype() const;
  private:
  bool _internal_has_stattype() const;
  public:
  void clear_stattype();
  const std::string& stattype() const;
  void set_stattype(const std::string& value);
  void set_stattype(std::string&& value);
  void set_stattype(const char* value);
  void set_stattype(const char* value, size_t size);
  std::string* mutable_stattype();
  std::string* release_stattype();
  void set_allocated_stattype(std::string* stattype);
  private:
  const std::string& _internal_stattype() const;
  void _internal_set_stattype(const std::string& value);
  std::string* _internal_mutable_stattype();
  public:

  // required float statVal = 2;
  bool has_statval() const;
  private:
  bool _internal_has_statval() const;
  public:
  void clear_statval();
  float statval() const;
  void set_statval(float value);
  private:
  float _internal_statval() const;
  void _internal_set_statval(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.POPSTATS)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stattype_;
  float statval_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class calibrationTable PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.calibrationTable) */ {
 public:
  inline calibrationTable() : calibrationTable(nullptr) {}
  virtual ~calibrationTable();

  calibrationTable(const calibrationTable& from);
  calibrationTable(calibrationTable&& from) noexcept
    : calibrationTable() {
    *this = ::std::move(from);
  }

  inline calibrationTable& operator=(const calibrationTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline calibrationTable& operator=(calibrationTable&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const calibrationTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const calibrationTable* internal_default_instance() {
    return reinterpret_cast<const calibrationTable*>(
               &_calibrationTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(calibrationTable& a, calibrationTable& b) {
    a.Swap(&b);
  }
  inline void Swap(calibrationTable* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(calibrationTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline calibrationTable* New() const final {
    return CreateMaybeMessage<calibrationTable>(nullptr);
  }

  calibrationTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<calibrationTable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const calibrationTable& from);
  void MergeFrom(const calibrationTable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(calibrationTable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.calibrationTable";
  }
  protected:
  explicit calibrationTable(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kBFieldNumber = 3,
    kCFieldNumber = 4,
    kDFieldNumber = 5,
    kCaltypeFieldNumber = 7,
    kSplineMethodFieldNumber = 6,
    kFlagFieldNumber = 8,
  };
  // repeated float x = 1 [packed = true];
  int x_size() const;
  private:
  int _internal_x_size() const;
  public:
  void clear_x();
  private:
  float _internal_x(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_x() const;
  void _internal_add_x(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_x();
  public:
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      x() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_x();

  // repeated float y = 2 [packed = true];
  int y_size() const;
  private:
  int _internal_y_size() const;
  public:
  void clear_y();
  private:
  float _internal_y(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_y() const;
  void _internal_add_y(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_y();
  public:
  float y(int index) const;
  void set_y(int index, float value);
  void add_y(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      y() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_y();

  // repeated float b = 3 [packed = true];
  int b_size() const;
  private:
  int _internal_b_size() const;
  public:
  void clear_b();
  private:
  float _internal_b(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_b() const;
  void _internal_add_b(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_b();
  public:
  float b(int index) const;
  void set_b(int index, float value);
  void add_b(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      b() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_b();

  // repeated float c = 4 [packed = true];
  int c_size() const;
  private:
  int _internal_c_size() const;
  public:
  void clear_c();
  private:
  float _internal_c(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_c() const;
  void _internal_add_c(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_c();
  public:
  float c(int index) const;
  void set_c(int index, float value);
  void add_c(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      c() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_c();

  // repeated float d = 5 [packed = true];
  int d_size() const;
  private:
  int _internal_d_size() const;
  public:
  void clear_d();
  private:
  float _internal_d(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_d() const;
  void _internal_add_d(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_d();
  public:
  float d(int index) const;
  void set_d(int index, float value);
  void add_d(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      d() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_d();

  // optional string caltype = 7;
  bool has_caltype() const;
  private:
  bool _internal_has_caltype() const;
  public:
  void clear_caltype();
  const std::string& caltype() const;
  void set_caltype(const std::string& value);
  void set_caltype(std::string&& value);
  void set_caltype(const char* value);
  void set_caltype(const char* value, size_t size);
  std::string* mutable_caltype();
  std::string* release_caltype();
  void set_allocated_caltype(std::string* caltype);
  private:
  const std::string& _internal_caltype() const;
  void _internal_set_caltype(const std::string& value);
  std::string* _internal_mutable_caltype();
  public:

  // optional uint32 spline_method = 6;
  bool has_spline_method() const;
  private:
  bool _internal_has_spline_method() const;
  public:
  void clear_spline_method();
  ::PROTOBUF_NAMESPACE_ID::uint32 spline_method() const;
  void set_spline_method(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_spline_method() const;
  void _internal_set_spline_method(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool flag = 8;
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  bool flag() const;
  void set_flag(bool value);
  private:
  bool _internal_flag() const;
  void _internal_set_flag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pb.calibrationTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > x_;
  mutable std::atomic<int> _x_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > y_;
  mutable std::atomic<int> _y_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > b_;
  mutable std::atomic<int> _b_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > c_;
  mutable std::atomic<int> _c_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > d_;
  mutable std::atomic<int> _d_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caltype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 spline_method_;
  bool flag_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class biexpTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.biexpTrans) */ {
 public:
  inline biexpTrans() : biexpTrans(nullptr) {}
  virtual ~biexpTrans();

  biexpTrans(const biexpTrans& from);
  biexpTrans(biexpTrans&& from) noexcept
    : biexpTrans() {
    *this = ::std::move(from);
  }

  inline biexpTrans& operator=(const biexpTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline biexpTrans& operator=(biexpTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const biexpTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const biexpTrans* internal_default_instance() {
    return reinterpret_cast<const biexpTrans*>(
               &_biexpTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(biexpTrans& a, biexpTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(biexpTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(biexpTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline biexpTrans* New() const final {
    return CreateMaybeMessage<biexpTrans>(nullptr);
  }

  biexpTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<biexpTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const biexpTrans& from);
  void MergeFrom(const biexpTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(biexpTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.biexpTrans";
  }
  protected:
  explicit biexpTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelRangeFieldNumber = 1,
    kPosFieldNumber = 2,
    kNegFieldNumber = 3,
    kWidthBasisFieldNumber = 4,
    kMaxValueFieldNumber = 5,
  };
  // optional uint32 channelRange = 1;
  bool has_channelrange() const;
  private:
  bool _internal_has_channelrange() const;
  public:
  void clear_channelrange();
  ::PROTOBUF_NAMESPACE_ID::uint32 channelrange() const;
  void set_channelrange(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channelrange() const;
  void _internal_set_channelrange(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  float pos() const;
  void set_pos(float value);
  private:
  float _internal_pos() const;
  void _internal_set_pos(float value);
  public:

  // optional float neg = 3;
  bool has_neg() const;
  private:
  bool _internal_has_neg() const;
  public:
  void clear_neg();
  float neg() const;
  void set_neg(float value);
  private:
  float _internal_neg() const;
  void _internal_set_neg(float value);
  public:

  // optional float widthBasis = 4;
  bool has_widthbasis() const;
  private:
  bool _internal_has_widthbasis() const;
  public:
  void clear_widthbasis();
  float widthbasis() const;
  void set_widthbasis(float value);
  private:
  float _internal_widthbasis() const;
  void _internal_set_widthbasis(float value);
  public:

  // optional float maxValue = 5;
  bool has_maxvalue() const;
  private:
  bool _internal_has_maxvalue() const;
  public:
  void clear_maxvalue();
  float maxvalue() const;
  void set_maxvalue(float value);
  private:
  float _internal_maxvalue() const;
  void _internal_set_maxvalue(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.biexpTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channelrange_;
  float pos_;
  float neg_;
  float widthbasis_;
  float maxvalue_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class fasinhTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.fasinhTrans) */ {
 public:
  inline fasinhTrans() : fasinhTrans(nullptr) {}
  virtual ~fasinhTrans();

  fasinhTrans(const fasinhTrans& from);
  fasinhTrans(fasinhTrans&& from) noexcept
    : fasinhTrans() {
    *this = ::std::move(from);
  }

  inline fasinhTrans& operator=(const fasinhTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline fasinhTrans& operator=(fasinhTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fasinhTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fasinhTrans* internal_default_instance() {
    return reinterpret_cast<const fasinhTrans*>(
               &_fasinhTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(fasinhTrans& a, fasinhTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(fasinhTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(fasinhTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fasinhTrans* New() const final {
    return CreateMaybeMessage<fasinhTrans>(nullptr);
  }

  fasinhTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fasinhTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fasinhTrans& from);
  void MergeFrom(const fasinhTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fasinhTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.fasinhTrans";
  }
  protected:
  explicit fasinhTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kMaxRangeFieldNumber = 2,
    kTFieldNumber = 3,
    kAFieldNumber = 4,
    kMFieldNumber = 5,
  };
  // optional float length = 1;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // optional float maxRange = 2;
  bool has_maxrange() const;
  private:
  bool _internal_has_maxrange() const;
  public:
  void clear_maxrange();
  float maxrange() const;
  void set_maxrange(float value);
  private:
  float _internal_maxrange() const;
  void _internal_set_maxrange(float value);
  public:

  // optional float T = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  float t() const;
  void set_t(float value);
  private:
  float _internal_t() const;
  void _internal_set_t(float value);
  public:

  // optional float A = 4;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // optional float M = 5;
  bool has_m() const;
  private:
  bool _internal_has_m() const;
  public:
  void clear_m();
  float m() const;
  void set_m(float value);
  private:
  float _internal_m() const;
  void _internal_set_m(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.fasinhTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float length_;
  float maxrange_;
  float t_;
  float a_;
  float m_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class scaleTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.scaleTrans) */ {
 public:
  inline scaleTrans() : scaleTrans(nullptr) {}
  virtual ~scaleTrans();

  scaleTrans(const scaleTrans& from);
  scaleTrans(scaleTrans&& from) noexcept
    : scaleTrans() {
    *this = ::std::move(from);
  }

  inline scaleTrans& operator=(const scaleTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline scaleTrans& operator=(scaleTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const scaleTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const scaleTrans* internal_default_instance() {
    return reinterpret_cast<const scaleTrans*>(
               &_scaleTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(scaleTrans& a, scaleTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(scaleTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(scaleTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline scaleTrans* New() const final {
    return CreateMaybeMessage<scaleTrans>(nullptr);
  }

  scaleTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<scaleTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const scaleTrans& from);
  void MergeFrom(const scaleTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(scaleTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.scaleTrans";
  }
  protected:
  explicit scaleTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScaleFactorFieldNumber = 1,
    kTScaleFieldNumber = 2,
    kRScaleFieldNumber = 3,
  };
  // optional float scale_factor = 1;
  bool has_scale_factor() const;
  private:
  bool _internal_has_scale_factor() const;
  public:
  void clear_scale_factor();
  float scale_factor() const;
  void set_scale_factor(float value);
  private:
  float _internal_scale_factor() const;
  void _internal_set_scale_factor(float value);
  public:

  // optional float t_scale = 2;
  bool has_t_scale() const;
  private:
  bool _internal_has_t_scale() const;
  public:
  void clear_t_scale();
  float t_scale() const;
  void set_t_scale(float value);
  private:
  float _internal_t_scale() const;
  void _internal_set_t_scale(float value);
  public:

  // optional float r_scale = 3;
  bool has_r_scale() const;
  private:
  bool _internal_has_r_scale() const;
  public:
  void clear_r_scale();
  float r_scale() const;
  void set_r_scale(float value);
  private:
  float _internal_r_scale() const;
  void _internal_set_r_scale(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.scaleTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float scale_factor_;
  float t_scale_;
  float r_scale_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class flinTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.flinTrans) */ {
 public:
  inline flinTrans() : flinTrans(nullptr) {}
  virtual ~flinTrans();

  flinTrans(const flinTrans& from);
  flinTrans(flinTrans&& from) noexcept
    : flinTrans() {
    *this = ::std::move(from);
  }

  inline flinTrans& operator=(const flinTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline flinTrans& operator=(flinTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flinTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flinTrans* internal_default_instance() {
    return reinterpret_cast<const flinTrans*>(
               &_flinTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(flinTrans& a, flinTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(flinTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flinTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flinTrans* New() const final {
    return CreateMaybeMessage<flinTrans>(nullptr);
  }

  flinTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flinTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flinTrans& from);
  void MergeFrom(const flinTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flinTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.flinTrans";
  }
  protected:
  explicit flinTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // optional float min = 1;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  float min() const;
  void set_min(float value);
  private:
  float _internal_min() const;
  void _internal_set_min(float value);
  public:

  // optional float max = 2;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  float max() const;
  void set_max(float value);
  private:
  float _internal_max() const;
  void _internal_set_max(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.flinTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float min_;
  float max_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class logTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.logTrans) */ {
 public:
  inline logTrans() : logTrans(nullptr) {}
  virtual ~logTrans();

  logTrans(const logTrans& from);
  logTrans(logTrans&& from) noexcept
    : logTrans() {
    *this = ::std::move(from);
  }

  inline logTrans& operator=(const logTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline logTrans& operator=(logTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const logTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const logTrans* internal_default_instance() {
    return reinterpret_cast<const logTrans*>(
               &_logTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(logTrans& a, logTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(logTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(logTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline logTrans* New() const final {
    return CreateMaybeMessage<logTrans>(nullptr);
  }

  logTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<logTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const logTrans& from);
  void MergeFrom(const logTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(logTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.logTrans";
  }
  protected:
  explicit logTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kDecadeFieldNumber = 2,
    kTFieldNumber = 3,
    kScaleFieldNumber = 4,
  };
  // optional float offset = 1;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // optional float decade = 2;
  bool has_decade() const;
  private:
  bool _internal_has_decade() const;
  public:
  void clear_decade();
  float decade() const;
  void set_decade(float value);
  private:
  float _internal_decade() const;
  void _internal_set_decade(float value);
  public:

  // optional float T = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  float t() const;
  void set_t(float value);
  private:
  float _internal_t() const;
  void _internal_set_t(float value);
  public:

  // optional float scale = 4;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  float scale() const;
  void set_scale(float value);
  private:
  float _internal_scale() const;
  void _internal_set_scale(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.logTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float offset_;
  float decade_;
  float t_;
  float scale_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class logGML2Trans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.logGML2Trans) */ {
 public:
  inline logGML2Trans() : logGML2Trans(nullptr) {}
  virtual ~logGML2Trans();

  logGML2Trans(const logGML2Trans& from);
  logGML2Trans(logGML2Trans&& from) noexcept
    : logGML2Trans() {
    *this = ::std::move(from);
  }

  inline logGML2Trans& operator=(const logGML2Trans& from) {
    CopyFrom(from);
    return *this;
  }
  inline logGML2Trans& operator=(logGML2Trans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const logGML2Trans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const logGML2Trans* internal_default_instance() {
    return reinterpret_cast<const logGML2Trans*>(
               &_logGML2Trans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(logGML2Trans& a, logGML2Trans& b) {
    a.Swap(&b);
  }
  inline void Swap(logGML2Trans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(logGML2Trans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline logGML2Trans* New() const final {
    return CreateMaybeMessage<logGML2Trans>(nullptr);
  }

  logGML2Trans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<logGML2Trans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const logGML2Trans& from);
  void MergeFrom(const logGML2Trans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(logGML2Trans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.logGML2Trans";
  }
  protected:
  explicit logGML2Trans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTFieldNumber = 1,
    kMFieldNumber = 2,
  };
  // optional float T = 1;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  float t() const;
  void set_t(float value);
  private:
  float _internal_t() const;
  void _internal_set_t(float value);
  public:

  // optional float M = 2;
  bool has_m() const;
  private:
  bool _internal_has_m() const;
  public:
  void clear_m();
  float m() const;
  void set_m(float value);
  private:
  float _internal_m() const;
  void _internal_set_m(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.logGML2Trans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float t_;
  float m_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class logicleTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.logicleTrans) */ {
 public:
  inline logicleTrans() : logicleTrans(nullptr) {}
  virtual ~logicleTrans();

  logicleTrans(const logicleTrans& from);
  logicleTrans(logicleTrans&& from) noexcept
    : logicleTrans() {
    *this = ::std::move(from);
  }

  inline logicleTrans& operator=(const logicleTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline logicleTrans& operator=(logicleTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const logicleTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const logicleTrans* internal_default_instance() {
    return reinterpret_cast<const logicleTrans*>(
               &_logicleTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(logicleTrans& a, logicleTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(logicleTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(logicleTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline logicleTrans* New() const final {
    return CreateMaybeMessage<logicleTrans>(nullptr);
  }

  logicleTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<logicleTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const logicleTrans& from);
  void MergeFrom(const logicleTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(logicleTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.logicleTrans";
  }
  protected:
  explicit logicleTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTFieldNumber = 1,
    kWFieldNumber = 2,
    kMFieldNumber = 3,
    kAFieldNumber = 4,
    kBinsFieldNumber = 5,
    kIsGml2FieldNumber = 6,
    kIsInverseFieldNumber = 7,
  };
  // optional float T = 1;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  float t() const;
  void set_t(float value);
  private:
  float _internal_t() const;
  void _internal_set_t(float value);
  public:

  // optional float W = 2;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // optional float M = 3;
  bool has_m() const;
  private:
  bool _internal_has_m() const;
  public:
  void clear_m();
  float m() const;
  void set_m(float value);
  private:
  float _internal_m() const;
  void _internal_set_m(float value);
  public:

  // optional float A = 4;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // optional float bins = 5;
  bool has_bins() const;
  private:
  bool _internal_has_bins() const;
  public:
  void clear_bins();
  float bins() const;
  void set_bins(float value);
  private:
  float _internal_bins() const;
  void _internal_set_bins(float value);
  public:

  // optional bool isGml2 = 6;
  bool has_isgml2() const;
  private:
  bool _internal_has_isgml2() const;
  public:
  void clear_isgml2();
  bool isgml2() const;
  void set_isgml2(bool value);
  private:
  bool _internal_isgml2() const;
  void _internal_set_isgml2(bool value);
  public:

  // optional bool isInverse = 7;
  bool has_isinverse() const;
  private:
  bool _internal_has_isinverse() const;
  public:
  void clear_isinverse();
  bool isinverse() const;
  void set_isinverse(bool value);
  private:
  bool _internal_isinverse() const;
  void _internal_set_isinverse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pb.logicleTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float t_;
  float w_;
  float m_;
  float a_;
  float bins_;
  bool isgml2_;
  bool isinverse_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class transformation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.transformation) */ {
 public:
  inline transformation() : transformation(nullptr) {}
  virtual ~transformation();

  transformation(const transformation& from);
  transformation(transformation&& from) noexcept
    : transformation() {
    *this = ::std::move(from);
  }

  inline transformation& operator=(const transformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline transformation& operator=(transformation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const transformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const transformation* internal_default_instance() {
    return reinterpret_cast<const transformation*>(
               &_transformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(transformation& a, transformation& b) {
    a.Swap(&b);
  }
  inline void Swap(transformation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(transformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline transformation* New() const final {
    return CreateMaybeMessage<transformation>(nullptr);
  }

  transformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<transformation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const transformation& from);
  void MergeFrom(const transformation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(transformation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.transformation";
  }
  protected:
  explicit transformation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kChannelFieldNumber = 5,
    kCalTblFieldNumber = 1,
    kBtFieldNumber = 7,
    kLtFieldNumber = 8,
    kFltFieldNumber = 9,
    kStFieldNumber = 10,
    kFtFieldNumber = 11,
    kLgtFieldNumber = 13,
    kLgml2TFieldNumber = 14,
    kTransTypeFieldNumber = 3,
    kIsGateOnlyFieldNumber = 2,
    kIsComputedFieldNumber = 6,
    kTypeFieldNumber = 12,
  };
  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string channel = 5;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  const std::string& channel() const;
  void set_channel(const std::string& value);
  void set_channel(std::string&& value);
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  std::string* mutable_channel();
  std::string* release_channel();
  void set_allocated_channel(std::string* channel);
  private:
  const std::string& _internal_channel() const;
  void _internal_set_channel(const std::string& value);
  std::string* _internal_mutable_channel();
  public:

  // optional .pb.calibrationTable calTbl = 1;
  bool has_caltbl() const;
  private:
  bool _internal_has_caltbl() const;
  public:
  void clear_caltbl();
  const ::pb::calibrationTable& caltbl() const;
  ::pb::calibrationTable* release_caltbl();
  ::pb::calibrationTable* mutable_caltbl();
  void set_allocated_caltbl(::pb::calibrationTable* caltbl);
  private:
  const ::pb::calibrationTable& _internal_caltbl() const;
  ::pb::calibrationTable* _internal_mutable_caltbl();
  public:
  void unsafe_arena_set_allocated_caltbl(
      ::pb::calibrationTable* caltbl);
  ::pb::calibrationTable* unsafe_arena_release_caltbl();

  // optional .pb.biexpTrans bt = 7;
  bool has_bt() const;
  private:
  bool _internal_has_bt() const;
  public:
  void clear_bt();
  const ::pb::biexpTrans& bt() const;
  ::pb::biexpTrans* release_bt();
  ::pb::biexpTrans* mutable_bt();
  void set_allocated_bt(::pb::biexpTrans* bt);
  private:
  const ::pb::biexpTrans& _internal_bt() const;
  ::pb::biexpTrans* _internal_mutable_bt();
  public:
  void unsafe_arena_set_allocated_bt(
      ::pb::biexpTrans* bt);
  ::pb::biexpTrans* unsafe_arena_release_bt();

  // optional .pb.logTrans lt = 8;
  bool has_lt() const;
  private:
  bool _internal_has_lt() const;
  public:
  void clear_lt();
  const ::pb::logTrans& lt() const;
  ::pb::logTrans* release_lt();
  ::pb::logTrans* mutable_lt();
  void set_allocated_lt(::pb::logTrans* lt);
  private:
  const ::pb::logTrans& _internal_lt() const;
  ::pb::logTrans* _internal_mutable_lt();
  public:
  void unsafe_arena_set_allocated_lt(
      ::pb::logTrans* lt);
  ::pb::logTrans* unsafe_arena_release_lt();

  // optional .pb.flinTrans flt = 9;
  bool has_flt() const;
  private:
  bool _internal_has_flt() const;
  public:
  void clear_flt();
  const ::pb::flinTrans& flt() const;
  ::pb::flinTrans* release_flt();
  ::pb::flinTrans* mutable_flt();
  void set_allocated_flt(::pb::flinTrans* flt);
  private:
  const ::pb::flinTrans& _internal_flt() const;
  ::pb::flinTrans* _internal_mutable_flt();
  public:
  void unsafe_arena_set_allocated_flt(
      ::pb::flinTrans* flt);
  ::pb::flinTrans* unsafe_arena_release_flt();

  // optional .pb.scaleTrans st = 10;
  bool has_st() const;
  private:
  bool _internal_has_st() const;
  public:
  void clear_st();
  const ::pb::scaleTrans& st() const;
  ::pb::scaleTrans* release_st();
  ::pb::scaleTrans* mutable_st();
  void set_allocated_st(::pb::scaleTrans* st);
  private:
  const ::pb::scaleTrans& _internal_st() const;
  ::pb::scaleTrans* _internal_mutable_st();
  public:
  void unsafe_arena_set_allocated_st(
      ::pb::scaleTrans* st);
  ::pb::scaleTrans* unsafe_arena_release_st();

  // optional .pb.fasinhTrans ft = 11;
  bool has_ft() const;
  private:
  bool _internal_has_ft() const;
  public:
  void clear_ft();
  const ::pb::fasinhTrans& ft() const;
  ::pb::fasinhTrans* release_ft();
  ::pb::fasinhTrans* mutable_ft();
  void set_allocated_ft(::pb::fasinhTrans* ft);
  private:
  const ::pb::fasinhTrans& _internal_ft() const;
  ::pb::fasinhTrans* _internal_mutable_ft();
  public:
  void unsafe_arena_set_allocated_ft(
      ::pb::fasinhTrans* ft);
  ::pb::fasinhTrans* unsafe_arena_release_ft();

  // optional .pb.logicleTrans lgt = 13;
  bool has_lgt() const;
  private:
  bool _internal_has_lgt() const;
  public:
  void clear_lgt();
  const ::pb::logicleTrans& lgt() const;
  ::pb::logicleTrans* release_lgt();
  ::pb::logicleTrans* mutable_lgt();
  void set_allocated_lgt(::pb::logicleTrans* lgt);
  private:
  const ::pb::logicleTrans& _internal_lgt() const;
  ::pb::logicleTrans* _internal_mutable_lgt();
  public:
  void unsafe_arena_set_allocated_lgt(
      ::pb::logicleTrans* lgt);
  ::pb::logicleTrans* unsafe_arena_release_lgt();

  // optional .pb.logGML2Trans lgml2t = 14;
  bool has_lgml2t() const;
  private:
  bool _internal_has_lgml2t() const;
  public:
  void clear_lgml2t();
  const ::pb::logGML2Trans& lgml2t() const;
  ::pb::logGML2Trans* release_lgml2t();
  ::pb::logGML2Trans* mutable_lgml2t();
  void set_allocated_lgml2t(::pb::logGML2Trans* lgml2t);
  private:
  const ::pb::logGML2Trans& _internal_lgml2t() const;
  ::pb::logGML2Trans* _internal_mutable_lgml2t();
  public:
  void unsafe_arena_set_allocated_lgml2t(
      ::pb::logGML2Trans* lgml2t);
  ::pb::logGML2Trans* unsafe_arena_release_lgml2t();

  // optional .pb.TRANS_TYPE trans_type = 3;
  bool has_trans_type() const;
  private:
  bool _internal_has_trans_type() const;
  public:
  void clear_trans_type();
  ::pb::TRANS_TYPE trans_type() const;
  void set_trans_type(::pb::TRANS_TYPE value);
  private:
  ::pb::TRANS_TYPE _internal_trans_type() const;
  void _internal_set_trans_type(::pb::TRANS_TYPE value);
  public:

  // optional bool isGateOnly = 2;
  bool has_isgateonly() const;
  private:
  bool _internal_has_isgateonly() const;
  public:
  void clear_isgateonly();
  bool isgateonly() const;
  void set_isgateonly(bool value);
  private:
  bool _internal_isgateonly() const;
  void _internal_set_isgateonly(bool value);
  public:

  // optional bool isComputed = 6;
  bool has_iscomputed() const;
  private:
  bool _internal_has_iscomputed() const;
  public:
  void clear_iscomputed();
  bool iscomputed() const;
  void set_iscomputed(bool value);
  private:
  bool _internal_iscomputed() const;
  void _internal_set_iscomputed(bool value);
  public:

  // optional uint32 type = 12;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.transformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
  ::pb::calibrationTable* caltbl_;
  ::pb::biexpTrans* bt_;
  ::pb::logTrans* lt_;
  ::pb::flinTrans* flt_;
  ::pb::scaleTrans* st_;
  ::pb::fasinhTrans* ft_;
  ::pb::logicleTrans* lgt_;
  ::pb::logGML2Trans* lgml2t_;
  int trans_type_;
  bool isgateonly_;
  bool iscomputed_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class trans_pair PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.trans_pair) */ {
 public:
  inline trans_pair() : trans_pair(nullptr) {}
  virtual ~trans_pair();

  trans_pair(const trans_pair& from);
  trans_pair(trans_pair&& from) noexcept
    : trans_pair() {
    *this = ::std::move(from);
  }

  inline trans_pair& operator=(const trans_pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline trans_pair& operator=(trans_pair&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const trans_pair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const trans_pair* internal_default_instance() {
    return reinterpret_cast<const trans_pair*>(
               &_trans_pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(trans_pair& a, trans_pair& b) {
    a.Swap(&b);
  }
  inline void Swap(trans_pair* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(trans_pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline trans_pair* New() const final {
    return CreateMaybeMessage<trans_pair>(nullptr);
  }

  trans_pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<trans_pair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const trans_pair& from);
  void MergeFrom(const trans_pair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(trans_pair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.trans_pair";
  }
  protected:
  explicit trans_pair(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTransFieldNumber = 3,
    kTransAddressFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .pb.transformation trans = 3;
  bool has_trans() const;
  private:
  bool _internal_has_trans() const;
  public:
  void clear_trans();
  const ::pb::transformation& trans() const;
  ::pb::transformation* release_trans();
  ::pb::transformation* mutable_trans();
  void set_allocated_trans(::pb::transformation* trans);
  private:
  const ::pb::transformation& _internal_trans() const;
  ::pb::transformation* _internal_mutable_trans();
  public:
  void unsafe_arena_set_allocated_trans(
      ::pb::transformation* trans);
  ::pb::transformation* unsafe_arena_release_trans();

  // optional uint64 trans_address = 2;
  bool has_trans_address() const;
  private:
  bool _internal_has_trans_address() const;
  public:
  void clear_trans_address();
  ::PROTOBUF_NAMESPACE_ID::uint64 trans_address() const;
  void set_trans_address(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_trans_address() const;
  void _internal_set_trans_address(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.trans_pair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::pb::transformation* trans_;
  ::PROTOBUF_NAMESPACE_ID::uint64 trans_address_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class trans_local PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.trans_local) */ {
 public:
  inline trans_local() : trans_local(nullptr) {}
  virtual ~trans_local();

  trans_local(const trans_local& from);
  trans_local(trans_local&& from) noexcept
    : trans_local() {
    *this = ::std::move(from);
  }

  inline trans_local& operator=(const trans_local& from) {
    CopyFrom(from);
    return *this;
  }
  inline trans_local& operator=(trans_local&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const trans_local& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const trans_local* internal_default_instance() {
    return reinterpret_cast<const trans_local*>(
               &_trans_local_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(trans_local& a, trans_local& b) {
    a.Swap(&b);
  }
  inline void Swap(trans_local* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(trans_local* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline trans_local* New() const final {
    return CreateMaybeMessage<trans_local>(nullptr);
  }

  trans_local* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<trans_local>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const trans_local& from);
  void MergeFrom(const trans_local& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(trans_local* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.trans_local";
  }
  protected:
  explicit trans_local(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpFieldNumber = 1,
    kSampleIDsFieldNumber = 3,
    kGroupNameFieldNumber = 2,
  };
  // repeated .pb.trans_pair tp = 1;
  int tp_size() const;
  private:
  int _internal_tp_size() const;
  public:
  void clear_tp();
  ::pb::trans_pair* mutable_tp(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_pair >*
      mutable_tp();
  private:
  const ::pb::trans_pair& _internal_tp(int index) const;
  ::pb::trans_pair* _internal_add_tp();
  public:
  const ::pb::trans_pair& tp(int index) const;
  ::pb::trans_pair* add_tp();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_pair >&
      tp() const;

  // repeated uint32 sampleIDs = 3 [packed = true];
  int sampleids_size() const;
  private:
  int _internal_sampleids_size() const;
  public:
  void clear_sampleids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sampleids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_sampleids() const;
  void _internal_add_sampleids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_sampleids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 sampleids(int index) const;
  void set_sampleids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_sampleids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      sampleids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_sampleids();

  // optional string groupName = 2;
  bool has_groupname() const;
  private:
  bool _internal_has_groupname() const;
  public:
  void clear_groupname();
  const std::string& groupname() const;
  void set_groupname(const std::string& value);
  void set_groupname(std::string&& value);
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  std::string* mutable_groupname();
  std::string* release_groupname();
  void set_allocated_groupname(std::string* groupname);
  private:
  const std::string& _internal_groupname() const;
  void _internal_set_groupname(const std::string& value);
  std::string* _internal_mutable_groupname();
  public:

  // @@protoc_insertion_point(class_scope:pb.trans_local)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_pair > tp_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > sampleids_;
  mutable std::atomic<int> _sampleids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class POPINDICES PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.POPINDICES) */ {
 public:
  inline POPINDICES() : POPINDICES(nullptr) {}
  virtual ~POPINDICES();

  POPINDICES(const POPINDICES& from);
  POPINDICES(POPINDICES&& from) noexcept
    : POPINDICES() {
    *this = ::std::move(from);
  }

  inline POPINDICES& operator=(const POPINDICES& from) {
    CopyFrom(from);
    return *this;
  }
  inline POPINDICES& operator=(POPINDICES&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const POPINDICES& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const POPINDICES* internal_default_instance() {
    return reinterpret_cast<const POPINDICES*>(
               &_POPINDICES_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(POPINDICES& a, POPINDICES& b) {
    a.Swap(&b);
  }
  inline void Swap(POPINDICES* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(POPINDICES* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline POPINDICES* New() const final {
    return CreateMaybeMessage<POPINDICES>(nullptr);
  }

  POPINDICES* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<POPINDICES>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const POPINDICES& from);
  void MergeFrom(const POPINDICES& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(POPINDICES* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.POPINDICES";
  }
  protected:
  explicit POPINDICES(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIIndFieldNumber = 3,
    kBIndFieldNumber = 4,
    kNEventsFieldNumber = 1,
    kIndtypeFieldNumber = 2,
  };
  // repeated uint32 iInd = 3 [packed = true];
  int iind_size() const;
  private:
  int _internal_iind_size() const;
  public:
  void clear_iind();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_iind(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_iind() const;
  void _internal_add_iind(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_iind();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 iind(int index) const;
  void set_iind(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_iind(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      iind() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_iind();

  // optional bytes bInd = 4;
  bool has_bind() const;
  private:
  bool _internal_has_bind() const;
  public:
  void clear_bind();
  const std::string& bind() const;
  void set_bind(const std::string& value);
  void set_bind(std::string&& value);
  void set_bind(const char* value);
  void set_bind(const void* value, size_t size);
  std::string* mutable_bind();
  std::string* release_bind();
  void set_allocated_bind(std::string* bind);
  private:
  const std::string& _internal_bind() const;
  void _internal_set_bind(const std::string& value);
  std::string* _internal_mutable_bind();
  public:

  // required uint32 nEvents = 1;
  bool has_nevents() const;
  private:
  bool _internal_has_nevents() const;
  public:
  void clear_nevents();
  ::PROTOBUF_NAMESPACE_ID::uint32 nevents() const;
  void set_nevents(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_nevents() const;
  void _internal_set_nevents(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .pb.ind_type indtype = 2;
  bool has_indtype() const;
  private:
  bool _internal_has_indtype() const;
  public:
  void clear_indtype();
  ::pb::ind_type indtype() const;
  void set_indtype(::pb::ind_type value);
  private:
  ::pb::ind_type _internal_indtype() const;
  void _internal_set_indtype(::pb::ind_type value);
  public:

  // @@protoc_insertion_point(class_scope:pb.POPINDICES)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > iind_;
  mutable std::atomic<int> _iind_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bind_;
  ::PROTOBUF_NAMESPACE_ID::uint32 nevents_;
  int indtype_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class nodeProperties PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.nodeProperties) */ {
 public:
  inline nodeProperties() : nodeProperties(nullptr) {}
  virtual ~nodeProperties();

  nodeProperties(const nodeProperties& from);
  nodeProperties(nodeProperties&& from) noexcept
    : nodeProperties() {
    *this = ::std::move(from);
  }

  inline nodeProperties& operator=(const nodeProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline nodeProperties& operator=(nodeProperties&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const nodeProperties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const nodeProperties* internal_default_instance() {
    return reinterpret_cast<const nodeProperties*>(
               &_nodeProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(nodeProperties& a, nodeProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(nodeProperties* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(nodeProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline nodeProperties* New() const final {
    return CreateMaybeMessage<nodeProperties>(nullptr);
  }

  nodeProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<nodeProperties>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const nodeProperties& from);
  void MergeFrom(const nodeProperties& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(nodeProperties* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.nodeProperties";
  }
  protected:
  explicit nodeProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFjStatsFieldNumber = 2,
    kFcStatsFieldNumber = 3,
    kThisNameFieldNumber = 1,
    kIndicesFieldNumber = 5,
    kThisGateFieldNumber = 6,
    kHiddenFieldNumber = 4,
  };
  // repeated .pb.POPSTATS fjStats = 2;
  int fjstats_size() const;
  private:
  int _internal_fjstats_size() const;
  public:
  void clear_fjstats();
  ::pb::POPSTATS* mutable_fjstats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS >*
      mutable_fjstats();
  private:
  const ::pb::POPSTATS& _internal_fjstats(int index) const;
  ::pb::POPSTATS* _internal_add_fjstats();
  public:
  const ::pb::POPSTATS& fjstats(int index) const;
  ::pb::POPSTATS* add_fjstats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS >&
      fjstats() const;

  // repeated .pb.POPSTATS fcStats = 3;
  int fcstats_size() const;
  private:
  int _internal_fcstats_size() const;
  public:
  void clear_fcstats();
  ::pb::POPSTATS* mutable_fcstats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS >*
      mutable_fcstats();
  private:
  const ::pb::POPSTATS& _internal_fcstats(int index) const;
  ::pb::POPSTATS* _internal_add_fcstats();
  public:
  const ::pb::POPSTATS& fcstats(int index) const;
  ::pb::POPSTATS* add_fcstats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS >&
      fcstats() const;

  // required string thisName = 1;
  bool has_thisname() const;
  private:
  bool _internal_has_thisname() const;
  public:
  void clear_thisname();
  const std::string& thisname() const;
  void set_thisname(const std::string& value);
  void set_thisname(std::string&& value);
  void set_thisname(const char* value);
  void set_thisname(const char* value, size_t size);
  std::string* mutable_thisname();
  std::string* release_thisname();
  void set_allocated_thisname(std::string* thisname);
  private:
  const std::string& _internal_thisname() const;
  void _internal_set_thisname(const std::string& value);
  std::string* _internal_mutable_thisname();
  public:

  // optional .pb.POPINDICES indices = 5;
  bool has_indices() const;
  private:
  bool _internal_has_indices() const;
  public:
  void clear_indices();
  const ::pb::POPINDICES& indices() const;
  ::pb::POPINDICES* release_indices();
  ::pb::POPINDICES* mutable_indices();
  void set_allocated_indices(::pb::POPINDICES* indices);
  private:
  const ::pb::POPINDICES& _internal_indices() const;
  ::pb::POPINDICES* _internal_mutable_indices();
  public:
  void unsafe_arena_set_allocated_indices(
      ::pb::POPINDICES* indices);
  ::pb::POPINDICES* unsafe_arena_release_indices();

  // optional .pb.gate thisGate = 6;
  bool has_thisgate() const;
  private:
  bool _internal_has_thisgate() const;
  public:
  void clear_thisgate();
  const ::pb::gate& thisgate() const;
  ::pb::gate* release_thisgate();
  ::pb::gate* mutable_thisgate();
  void set_allocated_thisgate(::pb::gate* thisgate);
  private:
  const ::pb::gate& _internal_thisgate() const;
  ::pb::gate* _internal_mutable_thisgate();
  public:
  void unsafe_arena_set_allocated_thisgate(
      ::pb::gate* thisgate);
  ::pb::gate* unsafe_arena_release_thisgate();

  // required bool hidden = 4;
  bool has_hidden() const;
  private:
  bool _internal_has_hidden() const;
  public:
  void clear_hidden();
  bool hidden() const;
  void set_hidden(bool value);
  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pb.nodeProperties)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS > fjstats_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS > fcstats_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thisname_;
  ::pb::POPINDICES* indices_;
  ::pb::gate* thisgate_;
  bool hidden_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class treeNodes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.treeNodes) */ {
 public:
  inline treeNodes() : treeNodes(nullptr) {}
  virtual ~treeNodes();

  treeNodes(const treeNodes& from);
  treeNodes(treeNodes&& from) noexcept
    : treeNodes() {
    *this = ::std::move(from);
  }

  inline treeNodes& operator=(const treeNodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline treeNodes& operator=(treeNodes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const treeNodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const treeNodes* internal_default_instance() {
    return reinterpret_cast<const treeNodes*>(
               &_treeNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(treeNodes& a, treeNodes& b) {
    a.Swap(&b);
  }
  inline void Swap(treeNodes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(treeNodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline treeNodes* New() const final {
    return CreateMaybeMessage<treeNodes>(nullptr);
  }

  treeNodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<treeNodes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const treeNodes& from);
  void MergeFrom(const treeNodes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(treeNodes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.treeNodes";
  }
  protected:
  explicit treeNodes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kParentFieldNumber = 2,
  };
  // required .pb.nodeProperties node = 1;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::pb::nodeProperties& node() const;
  ::pb::nodeProperties* release_node();
  ::pb::nodeProperties* mutable_node();
  void set_allocated_node(::pb::nodeProperties* node);
  private:
  const ::pb::nodeProperties& _internal_node() const;
  ::pb::nodeProperties* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::pb::nodeProperties* node);
  ::pb::nodeProperties* unsafe_arena_release_node();

  // optional uint32 parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  ::PROTOBUF_NAMESPACE_ID::uint32 parent() const;
  void set_parent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_parent() const;
  void _internal_set_parent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.treeNodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pb::nodeProperties* node_;
  ::PROTOBUF_NAMESPACE_ID::uint32 parent_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class populationTree PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.populationTree) */ {
 public:
  inline populationTree() : populationTree(nullptr) {}
  virtual ~populationTree();

  populationTree(const populationTree& from);
  populationTree(populationTree&& from) noexcept
    : populationTree() {
    *this = ::std::move(from);
  }

  inline populationTree& operator=(const populationTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline populationTree& operator=(populationTree&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const populationTree& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const populationTree* internal_default_instance() {
    return reinterpret_cast<const populationTree*>(
               &_populationTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(populationTree& a, populationTree& b) {
    a.Swap(&b);
  }
  inline void Swap(populationTree* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(populationTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline populationTree* New() const final {
    return CreateMaybeMessage<populationTree>(nullptr);
  }

  populationTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<populationTree>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const populationTree& from);
  void MergeFrom(const populationTree& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(populationTree* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.populationTree";
  }
  protected:
  explicit populationTree(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
  };
  // repeated .pb.treeNodes node = 1;
  int node_size() const;
  private:
  int _internal_node_size() const;
  public:
  void clear_node();
  ::pb::treeNodes* mutable_node(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::treeNodes >*
      mutable_node();
  private:
  const ::pb::treeNodes& _internal_node(int index) const;
  ::pb::treeNodes* _internal_add_node();
  public:
  const ::pb::treeNodes& node(int index) const;
  ::pb::treeNodes* add_node();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::treeNodes >&
      node() const;

  // @@protoc_insertion_point(class_scope:pb.populationTree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::treeNodes > node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class COMP PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.COMP) */ {
 public:
  inline COMP() : COMP(nullptr) {}
  virtual ~COMP();

  COMP(const COMP& from);
  COMP(COMP&& from) noexcept
    : COMP() {
    *this = ::std::move(from);
  }

  inline COMP& operator=(const COMP& from) {
    CopyFrom(from);
    return *this;
  }
  inline COMP& operator=(COMP&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const COMP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const COMP* internal_default_instance() {
    return reinterpret_cast<const COMP*>(
               &_COMP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(COMP& a, COMP& b) {
    a.Swap(&b);
  }
  inline void Swap(COMP* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(COMP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline COMP* New() const final {
    return CreateMaybeMessage<COMP>(nullptr);
  }

  COMP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<COMP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const COMP& from);
  void MergeFrom(const COMP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(COMP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.COMP";
  }
  protected:
  explicit COMP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarkerFieldNumber = 6,
    kSpillOverFieldNumber = 7,
    kCidFieldNumber = 1,
    kPrefixFieldNumber = 2,
    kSuffixFieldNumber = 3,
    kNameFieldNumber = 4,
    kCommentFieldNumber = 5,
  };
  // repeated string marker = 6;
  int marker_size() const;
  private:
  int _internal_marker_size() const;
  public:
  void clear_marker();
  const std::string& marker(int index) const;
  std::string* mutable_marker(int index);
  void set_marker(int index, const std::string& value);
  void set_marker(int index, std::string&& value);
  void set_marker(int index, const char* value);
  void set_marker(int index, const char* value, size_t size);
  std::string* add_marker();
  void add_marker(const std::string& value);
  void add_marker(std::string&& value);
  void add_marker(const char* value);
  void add_marker(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& marker() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_marker();
  private:
  const std::string& _internal_marker(int index) const;
  std::string* _internal_add_marker();
  public:

  // repeated float spillOver = 7;
  int spillover_size() const;
  private:
  int _internal_spillover_size() const;
  public:
  void clear_spillover();
  private:
  float _internal_spillover(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_spillover() const;
  void _internal_add_spillover(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_spillover();
  public:
  float spillover(int index) const;
  void set_spillover(int index, float value);
  void add_spillover(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      spillover() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_spillover();

  // optional string cid = 1;
  bool has_cid() const;
  private:
  bool _internal_has_cid() const;
  public:
  void clear_cid();
  const std::string& cid() const;
  void set_cid(const std::string& value);
  void set_cid(std::string&& value);
  void set_cid(const char* value);
  void set_cid(const char* value, size_t size);
  std::string* mutable_cid();
  std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // optional string prefix = 2;
  bool has_prefix() const;
  private:
  bool _internal_has_prefix() const;
  public:
  void clear_prefix();
  const std::string& prefix() const;
  void set_prefix(const std::string& value);
  void set_prefix(std::string&& value);
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  std::string* mutable_prefix();
  std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // optional string suffix = 3;
  bool has_suffix() const;
  private:
  bool _internal_has_suffix() const;
  public:
  void clear_suffix();
  const std::string& suffix() const;
  void set_suffix(const std::string& value);
  void set_suffix(std::string&& value);
  void set_suffix(const char* value);
  void set_suffix(const char* value, size_t size);
  std::string* mutable_suffix();
  std::string* release_suffix();
  void set_allocated_suffix(std::string* suffix);
  private:
  const std::string& _internal_suffix() const;
  void _internal_set_suffix(const std::string& value);
  std::string* _internal_mutable_suffix();
  public:

  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string comment = 5;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  void set_comment(const std::string& value);
  void set_comment(std::string&& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  std::string* mutable_comment();
  std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // @@protoc_insertion_point(class_scope:pb.COMP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> marker_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > spillover_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suffix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class PARAM PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PARAM) */ {
 public:
  inline PARAM() : PARAM(nullptr) {}
  virtual ~PARAM();

  PARAM(const PARAM& from);
  PARAM(PARAM&& from) noexcept
    : PARAM() {
    *this = ::std::move(from);
  }

  inline PARAM& operator=(const PARAM& from) {
    CopyFrom(from);
    return *this;
  }
  inline PARAM& operator=(PARAM&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PARAM& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PARAM* internal_default_instance() {
    return reinterpret_cast<const PARAM*>(
               &_PARAM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PARAM& a, PARAM& b) {
    a.Swap(&b);
  }
  inline void Swap(PARAM* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PARAM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PARAM* New() const final {
    return CreateMaybeMessage<PARAM>(nullptr);
  }

  PARAM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PARAM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PARAM& from);
  void MergeFrom(const PARAM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PARAM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PARAM";
  }
  protected:
  explicit PARAM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 1,
    kLogFieldNumber = 2,
    kRangeFieldNumber = 3,
    kHighValueFieldNumber = 4,
    kCalibrationIndexFieldNumber = 5,
  };
  // optional string param = 1;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const std::string& param() const;
  void set_param(const std::string& value);
  void set_param(std::string&& value);
  void set_param(const char* value);
  void set_param(const char* value, size_t size);
  std::string* mutable_param();
  std::string* release_param();
  void set_allocated_param(std::string* param);
  private:
  const std::string& _internal_param() const;
  void _internal_set_param(const std::string& value);
  std::string* _internal_mutable_param();
  public:

  // optional bool log = 2;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  bool log() const;
  void set_log(bool value);
  private:
  bool _internal_log() const;
  void _internal_set_log(bool value);
  public:

  // optional uint32 range = 3;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  ::PROTOBUF_NAMESPACE_ID::uint32 range() const;
  void set_range(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_range() const;
  void _internal_set_range(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 highValue = 4;
  bool has_highvalue() const;
  private:
  bool _internal_has_highvalue() const;
  public:
  void clear_highvalue();
  ::PROTOBUF_NAMESPACE_ID::uint32 highvalue() const;
  void set_highvalue(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_highvalue() const;
  void _internal_set_highvalue(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 calibrationIndex = 5;
  bool has_calibrationindex() const;
  private:
  bool _internal_has_calibrationindex() const;
  public:
  void clear_calibrationindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 calibrationindex() const;
  void set_calibrationindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_calibrationindex() const;
  void _internal_set_calibrationindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.PARAM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param_;
  bool log_;
  ::PROTOBUF_NAMESPACE_ID::uint32 range_;
  ::PROTOBUF_NAMESPACE_ID::uint32 highvalue_;
  ::PROTOBUF_NAMESPACE_ID::uint32 calibrationindex_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class GatingHierarchy PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GatingHierarchy) */ {
 public:
  inline GatingHierarchy() : GatingHierarchy(nullptr) {}
  virtual ~GatingHierarchy();

  GatingHierarchy(const GatingHierarchy& from);
  GatingHierarchy(GatingHierarchy&& from) noexcept
    : GatingHierarchy() {
    *this = ::std::move(from);
  }

  inline GatingHierarchy& operator=(const GatingHierarchy& from) {
    CopyFrom(from);
    return *this;
  }
  inline GatingHierarchy& operator=(GatingHierarchy&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GatingHierarchy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GatingHierarchy* internal_default_instance() {
    return reinterpret_cast<const GatingHierarchy*>(
               &_GatingHierarchy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GatingHierarchy& a, GatingHierarchy& b) {
    a.Swap(&b);
  }
  inline void Swap(GatingHierarchy* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GatingHierarchy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GatingHierarchy* New() const final {
    return CreateMaybeMessage<GatingHierarchy>(nullptr);
  }

  GatingHierarchy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GatingHierarchy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GatingHierarchy& from);
  void MergeFrom(const GatingHierarchy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GatingHierarchy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GatingHierarchy";
  }
  protected:
  explicit GatingHierarchy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransFlagFieldNumber = 4,
    kCompFieldNumber = 1,
    kTreeFieldNumber = 2,
    kTransFieldNumber = 5,
    kFrameFieldNumber = 6,
    kIsLoadedFieldNumber = 3,
  };
  // repeated .pb.PARAM transFlag = 4;
  int transflag_size() const;
  private:
  int _internal_transflag_size() const;
  public:
  void clear_transflag();
  ::pb::PARAM* mutable_transflag(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PARAM >*
      mutable_transflag();
  private:
  const ::pb::PARAM& _internal_transflag(int index) const;
  ::pb::PARAM* _internal_add_transflag();
  public:
  const ::pb::PARAM& transflag(int index) const;
  ::pb::PARAM* add_transflag();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PARAM >&
      transflag() const;

  // optional .pb.COMP comp = 1;
  bool has_comp() const;
  private:
  bool _internal_has_comp() const;
  public:
  void clear_comp();
  const ::pb::COMP& comp() const;
  ::pb::COMP* release_comp();
  ::pb::COMP* mutable_comp();
  void set_allocated_comp(::pb::COMP* comp);
  private:
  const ::pb::COMP& _internal_comp() const;
  ::pb::COMP* _internal_mutable_comp();
  public:
  void unsafe_arena_set_allocated_comp(
      ::pb::COMP* comp);
  ::pb::COMP* unsafe_arena_release_comp();

  // required .pb.populationTree tree = 2;
  bool has_tree() const;
  private:
  bool _internal_has_tree() const;
  public:
  void clear_tree();
  const ::pb::populationTree& tree() const;
  ::pb::populationTree* release_tree();
  ::pb::populationTree* mutable_tree();
  void set_allocated_tree(::pb::populationTree* tree);
  private:
  const ::pb::populationTree& _internal_tree() const;
  ::pb::populationTree* _internal_mutable_tree();
  public:
  void unsafe_arena_set_allocated_tree(
      ::pb::populationTree* tree);
  ::pb::populationTree* unsafe_arena_release_tree();

  // optional .pb.trans_local trans = 5;
  bool has_trans() const;
  private:
  bool _internal_has_trans() const;
  public:
  void clear_trans();
  const ::pb::trans_local& trans() const;
  ::pb::trans_local* release_trans();
  ::pb::trans_local* mutable_trans();
  void set_allocated_trans(::pb::trans_local* trans);
  private:
  const ::pb::trans_local& _internal_trans() const;
  ::pb::trans_local* _internal_mutable_trans();
  public:
  void unsafe_arena_set_allocated_trans(
      ::pb::trans_local* trans);
  ::pb::trans_local* unsafe_arena_release_trans();

  // optional .pb.CytoFrame frame = 6;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::pb::CytoFrame& frame() const;
  ::pb::CytoFrame* release_frame();
  ::pb::CytoFrame* mutable_frame();
  void set_allocated_frame(::pb::CytoFrame* frame);
  private:
  const ::pb::CytoFrame& _internal_frame() const;
  ::pb::CytoFrame* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::pb::CytoFrame* frame);
  ::pb::CytoFrame* unsafe_arena_release_frame();

  // optional bool isLoaded = 3;
  bool has_isloaded() const;
  private:
  bool _internal_has_isloaded() const;
  public:
  void clear_isloaded();
  bool isloaded() const;
  void set_isloaded(bool value);
  private:
  bool _internal_isloaded() const;
  void _internal_set_isloaded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pb.GatingHierarchy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PARAM > transflag_;
  ::pb::COMP* comp_;
  ::pb::populationTree* tree_;
  ::pb::trans_local* trans_;
  ::pb::CytoFrame* frame_;
  bool isloaded_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class CytoFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.CytoFrame) */ {
 public:
  inline CytoFrame() : CytoFrame(nullptr) {}
  virtual ~CytoFrame();

  CytoFrame(const CytoFrame& from);
  CytoFrame(CytoFrame&& from) noexcept
    : CytoFrame() {
    *this = ::std::move(from);
  }

  inline CytoFrame& operator=(const CytoFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline CytoFrame& operator=(CytoFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CytoFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CytoFrame* internal_default_instance() {
    return reinterpret_cast<const CytoFrame*>(
               &_CytoFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CytoFrame& a, CytoFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(CytoFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CytoFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CytoFrame* New() const final {
    return CreateMaybeMessage<CytoFrame>(nullptr);
  }

  CytoFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CytoFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CytoFrame& from);
  void MergeFrom(const CytoFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CytoFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.CytoFrame";
  }
  protected:
  explicit CytoFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsH5FieldNumber = 1,
  };
  // required bool is_h5 = 1;
  bool has_is_h5() const;
  private:
  bool _internal_has_is_h5() const;
  public:
  void clear_is_h5();
  bool is_h5() const;
  void set_is_h5(bool value);
  private:
  bool _internal_is_h5() const;
  void _internal_set_is_h5(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pb.CytoFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_h5_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class TRANS_TBL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.TRANS_TBL) */ {
 public:
  inline TRANS_TBL() : TRANS_TBL(nullptr) {}
  virtual ~TRANS_TBL();

  TRANS_TBL(const TRANS_TBL& from);
  TRANS_TBL(TRANS_TBL&& from) noexcept
    : TRANS_TBL() {
    *this = ::std::move(from);
  }

  inline TRANS_TBL& operator=(const TRANS_TBL& from) {
    CopyFrom(from);
    return *this;
  }
  inline TRANS_TBL& operator=(TRANS_TBL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TRANS_TBL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TRANS_TBL* internal_default_instance() {
    return reinterpret_cast<const TRANS_TBL*>(
               &_TRANS_TBL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(TRANS_TBL& a, TRANS_TBL& b) {
    a.Swap(&b);
  }
  inline void Swap(TRANS_TBL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TRANS_TBL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TRANS_TBL* New() const final {
    return CreateMaybeMessage<TRANS_TBL>(nullptr);
  }

  TRANS_TBL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TRANS_TBL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TRANS_TBL& from);
  void MergeFrom(const TRANS_TBL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TRANS_TBL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.TRANS_TBL";
  }
  protected:
  explicit TRANS_TBL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransFieldNumber = 2,
    kTransAddressFieldNumber = 1,
  };
  // optional .pb.transformation trans = 2;
  bool has_trans() const;
  private:
  bool _internal_has_trans() const;
  public:
  void clear_trans();
  const ::pb::transformation& trans() const;
  ::pb::transformation* release_trans();
  ::pb::transformation* mutable_trans();
  void set_allocated_trans(::pb::transformation* trans);
  private:
  const ::pb::transformation& _internal_trans() const;
  ::pb::transformation* _internal_mutable_trans();
  public:
  void unsafe_arena_set_allocated_trans(
      ::pb::transformation* trans);
  ::pb::transformation* unsafe_arena_release_trans();

  // optional uint64 trans_address = 1;
  bool has_trans_address() const;
  private:
  bool _internal_has_trans_address() const;
  public:
  void clear_trans_address();
  ::PROTOBUF_NAMESPACE_ID::uint64 trans_address() const;
  void set_trans_address(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_trans_address() const;
  void _internal_set_trans_address(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.TRANS_TBL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pb::transformation* trans_;
  ::PROTOBUF_NAMESPACE_ID::uint64 trans_address_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// -------------------------------------------------------------------

class GatingSet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GatingSet) */ {
 public:
  inline GatingSet() : GatingSet(nullptr) {}
  virtual ~GatingSet();

  GatingSet(const GatingSet& from);
  GatingSet(GatingSet&& from) noexcept
    : GatingSet() {
    *this = ::std::move(from);
  }

  inline GatingSet& operator=(const GatingSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline GatingSet& operator=(GatingSet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GatingSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GatingSet* internal_default_instance() {
    return reinterpret_cast<const GatingSet*>(
               &_GatingSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GatingSet& a, GatingSet& b) {
    a.Swap(&b);
  }
  inline void Swap(GatingSet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GatingSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GatingSet* New() const final {
    return CreateMaybeMessage<GatingSet>(nullptr);
  }

  GatingSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GatingSet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GatingSet& from);
  void MergeFrom(const GatingSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GatingSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GatingSet";
  }
  protected:
  explicit GatingSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GatingSet_2eproto);
    return ::descriptor_table_GatingSet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleNameFieldNumber = 1,
    kTransTblFieldNumber = 2,
    kGTransFieldNumber = 5,
    kGuidFieldNumber = 6,
    kCytolibVerionFieldNumber = 7,
    kPbVerionFieldNumber = 8,
    kH5VerionFieldNumber = 9,
    kGlobalBiExpTransFieldNumber = 3,
    kGlobalLinTransFieldNumber = 4,
  };
  // repeated string sampleName = 1;
  int samplename_size() const;
  private:
  int _internal_samplename_size() const;
  public:
  void clear_samplename();
  const std::string& samplename(int index) const;
  std::string* mutable_samplename(int index);
  void set_samplename(int index, const std::string& value);
  void set_samplename(int index, std::string&& value);
  void set_samplename(int index, const char* value);
  void set_samplename(int index, const char* value, size_t size);
  std::string* add_samplename();
  void add_samplename(const std::string& value);
  void add_samplename(std::string&& value);
  void add_samplename(const char* value);
  void add_samplename(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& samplename() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_samplename();
  private:
  const std::string& _internal_samplename(int index) const;
  std::string* _internal_add_samplename();
  public:

  // repeated .pb.TRANS_TBL trans_tbl = 2;
  int trans_tbl_size() const;
  private:
  int _internal_trans_tbl_size() const;
  public:
  void clear_trans_tbl();
  ::pb::TRANS_TBL* mutable_trans_tbl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::TRANS_TBL >*
      mutable_trans_tbl();
  private:
  const ::pb::TRANS_TBL& _internal_trans_tbl(int index) const;
  ::pb::TRANS_TBL* _internal_add_trans_tbl();
  public:
  const ::pb::TRANS_TBL& trans_tbl(int index) const;
  ::pb::TRANS_TBL* add_trans_tbl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::TRANS_TBL >&
      trans_tbl() const;

  // repeated .pb.trans_local gTrans = 5;
  int gtrans_size() const;
  private:
  int _internal_gtrans_size() const;
  public:
  void clear_gtrans();
  ::pb::trans_local* mutable_gtrans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_local >*
      mutable_gtrans();
  private:
  const ::pb::trans_local& _internal_gtrans(int index) const;
  ::pb::trans_local* _internal_add_gtrans();
  public:
  const ::pb::trans_local& gtrans(int index) const;
  ::pb::trans_local* add_gtrans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_local >&
      gtrans() const;

  // optional string guid = 6;
  bool has_guid() const;
  private:
  bool _internal_has_guid() const;
  public:
  void clear_guid();
  const std::string& guid() const;
  void set_guid(const std::string& value);
  void set_guid(std::string&& value);
  void set_guid(const char* value);
  void set_guid(const char* value, size_t size);
  std::string* mutable_guid();
  std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // optional string cytolib_verion = 7;
  bool has_cytolib_verion() const;
  private:
  bool _internal_has_cytolib_verion() const;
  public:
  void clear_cytolib_verion();
  const std::string& cytolib_verion() const;
  void set_cytolib_verion(const std::string& value);
  void set_cytolib_verion(std::string&& value);
  void set_cytolib_verion(const char* value);
  void set_cytolib_verion(const char* value, size_t size);
  std::string* mutable_cytolib_verion();
  std::string* release_cytolib_verion();
  void set_allocated_cytolib_verion(std::string* cytolib_verion);
  private:
  const std::string& _internal_cytolib_verion() const;
  void _internal_set_cytolib_verion(const std::string& value);
  std::string* _internal_mutable_cytolib_verion();
  public:

  // optional string pb_verion = 8;
  bool has_pb_verion() const;
  private:
  bool _internal_has_pb_verion() const;
  public:
  void clear_pb_verion();
  const std::string& pb_verion() const;
  void set_pb_verion(const std::string& value);
  void set_pb_verion(std::string&& value);
  void set_pb_verion(const char* value);
  void set_pb_verion(const char* value, size_t size);
  std::string* mutable_pb_verion();
  std::string* release_pb_verion();
  void set_allocated_pb_verion(std::string* pb_verion);
  private:
  const std::string& _internal_pb_verion() const;
  void _internal_set_pb_verion(const std::string& value);
  std::string* _internal_mutable_pb_verion();
  public:

  // optional string h5_verion = 9;
  bool has_h5_verion() const;
  private:
  bool _internal_has_h5_verion() const;
  public:
  void clear_h5_verion();
  const std::string& h5_verion() const;
  void set_h5_verion(const std::string& value);
  void set_h5_verion(std::string&& value);
  void set_h5_verion(const char* value);
  void set_h5_verion(const char* value, size_t size);
  std::string* mutable_h5_verion();
  std::string* release_h5_verion();
  void set_allocated_h5_verion(std::string* h5_verion);
  private:
  const std::string& _internal_h5_verion() const;
  void _internal_set_h5_verion(const std::string& value);
  std::string* _internal_mutable_h5_verion();
  public:

  // optional uint64 globalBiExpTrans = 3;
  bool has_globalbiexptrans() const;
  private:
  bool _internal_has_globalbiexptrans() const;
  public:
  void clear_globalbiexptrans();
  ::PROTOBUF_NAMESPACE_ID::uint64 globalbiexptrans() const;
  void set_globalbiexptrans(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_globalbiexptrans() const;
  void _internal_set_globalbiexptrans(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 globalLinTrans = 4;
  bool has_globallintrans() const;
  private:
  bool _internal_has_globallintrans() const;
  public:
  void clear_globallintrans();
  ::PROTOBUF_NAMESPACE_ID::uint64 globallintrans() const;
  void set_globallintrans(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_globallintrans() const;
  void _internal_set_globallintrans(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.GatingSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> samplename_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::TRANS_TBL > trans_tbl_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_local > gtrans_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cytolib_verion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pb_verion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr h5_verion_;
  ::PROTOBUF_NAMESPACE_ID::uint64 globalbiexptrans_;
  ::PROTOBUF_NAMESPACE_ID::uint64 globallintrans_;
  friend struct ::TableStruct_GatingSet_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// paramRange

// required string name = 1;
inline bool paramRange::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool paramRange::has_name() const {
  return _internal_has_name();
}
inline void paramRange::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& paramRange::name() const {
  // @@protoc_insertion_point(field_get:pb.paramRange.name)
  return _internal_name();
}
inline void paramRange::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pb.paramRange.name)
}
inline std::string* paramRange::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pb.paramRange.name)
  return _internal_mutable_name();
}
inline const std::string& paramRange::_internal_name() const {
  return name_.Get();
}
inline void paramRange::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void paramRange::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.paramRange.name)
}
inline void paramRange::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.paramRange.name)
}
inline void paramRange::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.paramRange.name)
}
inline std::string* paramRange::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* paramRange::release_name() {
  // @@protoc_insertion_point(field_release:pb.paramRange.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void paramRange::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.paramRange.name)
}

// required float min = 2;
inline bool paramRange::_internal_has_min() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool paramRange::has_min() const {
  return _internal_has_min();
}
inline void paramRange::clear_min() {
  min_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float paramRange::_internal_min() const {
  return min_;
}
inline float paramRange::min() const {
  // @@protoc_insertion_point(field_get:pb.paramRange.min)
  return _internal_min();
}
inline void paramRange::_internal_set_min(float value) {
  _has_bits_[0] |= 0x00000002u;
  min_ = value;
}
inline void paramRange::set_min(float value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:pb.paramRange.min)
}

// required float max = 3;
inline bool paramRange::_internal_has_max() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool paramRange::has_max() const {
  return _internal_has_max();
}
inline void paramRange::clear_max() {
  max_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float paramRange::_internal_max() const {
  return max_;
}
inline float paramRange::max() const {
  // @@protoc_insertion_point(field_get:pb.paramRange.max)
  return _internal_max();
}
inline void paramRange::_internal_set_max(float value) {
  _has_bits_[0] |= 0x00000004u;
  max_ = value;
}
inline void paramRange::set_max(float value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:pb.paramRange.max)
}

// -------------------------------------------------------------------

// rangeGate

// required .pb.paramRange param = 1;
inline bool rangeGate::_internal_has_param() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || param_ != nullptr);
  return value;
}
inline bool rangeGate::has_param() const {
  return _internal_has_param();
}
inline void rangeGate::clear_param() {
  if (param_ != nullptr) param_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::paramRange& rangeGate::_internal_param() const {
  const ::pb::paramRange* p = param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::paramRange*>(
      &::pb::_paramRange_default_instance_);
}
inline const ::pb::paramRange& rangeGate::param() const {
  // @@protoc_insertion_point(field_get:pb.rangeGate.param)
  return _internal_param();
}
inline void rangeGate::unsafe_arena_set_allocated_param(
    ::pb::paramRange* param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param_);
  }
  param_ = param;
  if (param) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.rangeGate.param)
}
inline ::pb::paramRange* rangeGate::release_param() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::paramRange* temp = param_;
  param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::paramRange* rangeGate::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:pb.rangeGate.param)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::paramRange* temp = param_;
  param_ = nullptr;
  return temp;
}
inline ::pb::paramRange* rangeGate::_internal_mutable_param() {
  _has_bits_[0] |= 0x00000001u;
  if (param_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::paramRange>(GetArena());
    param_ = p;
  }
  return param_;
}
inline ::pb::paramRange* rangeGate::mutable_param() {
  // @@protoc_insertion_point(field_mutable:pb.rangeGate.param)
  return _internal_mutable_param();
}
inline void rangeGate::set_allocated_param(::pb::paramRange* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete param_;
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(param);
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  param_ = param;
  // @@protoc_insertion_point(field_set_allocated:pb.rangeGate.param)
}

// -------------------------------------------------------------------

// paramPoly

// repeated string params = 1;
inline int paramPoly::_internal_params_size() const {
  return params_.size();
}
inline int paramPoly::params_size() const {
  return _internal_params_size();
}
inline void paramPoly::clear_params() {
  params_.Clear();
}
inline std::string* paramPoly::add_params() {
  // @@protoc_insertion_point(field_add_mutable:pb.paramPoly.params)
  return _internal_add_params();
}
inline const std::string& paramPoly::_internal_params(int index) const {
  return params_.Get(index);
}
inline const std::string& paramPoly::params(int index) const {
  // @@protoc_insertion_point(field_get:pb.paramPoly.params)
  return _internal_params(index);
}
inline std::string* paramPoly::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:pb.paramPoly.params)
  return params_.Mutable(index);
}
inline void paramPoly::set_params(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:pb.paramPoly.params)
  params_.Mutable(index)->assign(value);
}
inline void paramPoly::set_params(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.paramPoly.params)
  params_.Mutable(index)->assign(std::move(value));
}
inline void paramPoly::set_params(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.paramPoly.params)
}
inline void paramPoly::set_params(int index, const char* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.paramPoly.params)
}
inline std::string* paramPoly::_internal_add_params() {
  return params_.Add();
}
inline void paramPoly::add_params(const std::string& value) {
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.paramPoly.params)
}
inline void paramPoly::add_params(std::string&& value) {
  params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.paramPoly.params)
}
inline void paramPoly::add_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.paramPoly.params)
}
inline void paramPoly::add_params(const char* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.paramPoly.params)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
paramPoly::params() const {
  // @@protoc_insertion_point(field_list:pb.paramPoly.params)
  return params_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
paramPoly::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:pb.paramPoly.params)
  return &params_;
}

// repeated .pb.coordinate vertices = 2;
inline int paramPoly::_internal_vertices_size() const {
  return vertices_.size();
}
inline int paramPoly::vertices_size() const {
  return _internal_vertices_size();
}
inline void paramPoly::clear_vertices() {
  vertices_.Clear();
}
inline ::pb::coordinate* paramPoly::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:pb.paramPoly.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >*
paramPoly::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:pb.paramPoly.vertices)
  return &vertices_;
}
inline const ::pb::coordinate& paramPoly::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::pb::coordinate& paramPoly::vertices(int index) const {
  // @@protoc_insertion_point(field_get:pb.paramPoly.vertices)
  return _internal_vertices(index);
}
inline ::pb::coordinate* paramPoly::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::pb::coordinate* paramPoly::add_vertices() {
  // @@protoc_insertion_point(field_add:pb.paramPoly.vertices)
  return _internal_add_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >&
paramPoly::vertices() const {
  // @@protoc_insertion_point(field_list:pb.paramPoly.vertices)
  return vertices_;
}

// -------------------------------------------------------------------

// polygonGate

// required .pb.paramPoly param = 1;
inline bool polygonGate::_internal_has_param() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || param_ != nullptr);
  return value;
}
inline bool polygonGate::has_param() const {
  return _internal_has_param();
}
inline void polygonGate::clear_param() {
  if (param_ != nullptr) param_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::paramPoly& polygonGate::_internal_param() const {
  const ::pb::paramPoly* p = param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::paramPoly*>(
      &::pb::_paramPoly_default_instance_);
}
inline const ::pb::paramPoly& polygonGate::param() const {
  // @@protoc_insertion_point(field_get:pb.polygonGate.param)
  return _internal_param();
}
inline void polygonGate::unsafe_arena_set_allocated_param(
    ::pb::paramPoly* param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param_);
  }
  param_ = param;
  if (param) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.polygonGate.param)
}
inline ::pb::paramPoly* polygonGate::release_param() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::paramPoly* temp = param_;
  param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::paramPoly* polygonGate::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:pb.polygonGate.param)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::paramPoly* temp = param_;
  param_ = nullptr;
  return temp;
}
inline ::pb::paramPoly* polygonGate::_internal_mutable_param() {
  _has_bits_[0] |= 0x00000001u;
  if (param_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::paramPoly>(GetArena());
    param_ = p;
  }
  return param_;
}
inline ::pb::paramPoly* polygonGate::mutable_param() {
  // @@protoc_insertion_point(field_mutable:pb.polygonGate.param)
  return _internal_mutable_param();
}
inline void polygonGate::set_allocated_param(::pb::paramPoly* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete param_;
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(param);
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  param_ = param;
  // @@protoc_insertion_point(field_set_allocated:pb.polygonGate.param)
}

// optional .pb.quadGate qg = 2;
inline bool polygonGate::_internal_has_qg() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || qg_ != nullptr);
  return value;
}
inline bool polygonGate::has_qg() const {
  return _internal_has_qg();
}
inline void polygonGate::clear_qg() {
  if (qg_ != nullptr) qg_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pb::quadGate& polygonGate::_internal_qg() const {
  const ::pb::quadGate* p = qg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::quadGate*>(
      &::pb::_quadGate_default_instance_);
}
inline const ::pb::quadGate& polygonGate::qg() const {
  // @@protoc_insertion_point(field_get:pb.polygonGate.qg)
  return _internal_qg();
}
inline void polygonGate::unsafe_arena_set_allocated_qg(
    ::pb::quadGate* qg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(qg_);
  }
  qg_ = qg;
  if (qg) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.polygonGate.qg)
}
inline ::pb::quadGate* polygonGate::release_qg() {
  _has_bits_[0] &= ~0x00000002u;
  ::pb::quadGate* temp = qg_;
  qg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::quadGate* polygonGate::unsafe_arena_release_qg() {
  // @@protoc_insertion_point(field_release:pb.polygonGate.qg)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::quadGate* temp = qg_;
  qg_ = nullptr;
  return temp;
}
inline ::pb::quadGate* polygonGate::_internal_mutable_qg() {
  _has_bits_[0] |= 0x00000002u;
  if (qg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::quadGate>(GetArena());
    qg_ = p;
  }
  return qg_;
}
inline ::pb::quadGate* polygonGate::mutable_qg() {
  // @@protoc_insertion_point(field_mutable:pb.polygonGate.qg)
  return _internal_mutable_qg();
}
inline void polygonGate::set_allocated_qg(::pb::quadGate* qg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete qg_;
  }
  if (qg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(qg);
    if (message_arena != submessage_arena) {
      qg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  qg_ = qg;
  // @@protoc_insertion_point(field_set_allocated:pb.polygonGate.qg)
}

// -------------------------------------------------------------------

// coordinate

// required float x = 1;
inline bool coordinate::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool coordinate::has_x() const {
  return _internal_has_x();
}
inline void coordinate::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float coordinate::_internal_x() const {
  return x_;
}
inline float coordinate::x() const {
  // @@protoc_insertion_point(field_get:pb.coordinate.x)
  return _internal_x();
}
inline void coordinate::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void coordinate::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:pb.coordinate.x)
}

// required float y = 2;
inline bool coordinate::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool coordinate::has_y() const {
  return _internal_has_y();
}
inline void coordinate::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float coordinate::_internal_y() const {
  return y_;
}
inline float coordinate::y() const {
  // @@protoc_insertion_point(field_get:pb.coordinate.y)
  return _internal_y();
}
inline void coordinate::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void coordinate::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:pb.coordinate.y)
}

// -------------------------------------------------------------------

// ellipseGate

// required .pb.coordinate mu = 1;
inline bool ellipseGate::_internal_has_mu() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || mu_ != nullptr);
  return value;
}
inline bool ellipseGate::has_mu() const {
  return _internal_has_mu();
}
inline void ellipseGate::clear_mu() {
  if (mu_ != nullptr) mu_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::coordinate& ellipseGate::_internal_mu() const {
  const ::pb::coordinate* p = mu_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::coordinate*>(
      &::pb::_coordinate_default_instance_);
}
inline const ::pb::coordinate& ellipseGate::mu() const {
  // @@protoc_insertion_point(field_get:pb.ellipseGate.mu)
  return _internal_mu();
}
inline void ellipseGate::unsafe_arena_set_allocated_mu(
    ::pb::coordinate* mu) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mu_);
  }
  mu_ = mu;
  if (mu) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.ellipseGate.mu)
}
inline ::pb::coordinate* ellipseGate::release_mu() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::coordinate* temp = mu_;
  mu_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::coordinate* ellipseGate::unsafe_arena_release_mu() {
  // @@protoc_insertion_point(field_release:pb.ellipseGate.mu)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::coordinate* temp = mu_;
  mu_ = nullptr;
  return temp;
}
inline ::pb::coordinate* ellipseGate::_internal_mutable_mu() {
  _has_bits_[0] |= 0x00000001u;
  if (mu_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::coordinate>(GetArena());
    mu_ = p;
  }
  return mu_;
}
inline ::pb::coordinate* ellipseGate::mutable_mu() {
  // @@protoc_insertion_point(field_mutable:pb.ellipseGate.mu)
  return _internal_mutable_mu();
}
inline void ellipseGate::set_allocated_mu(::pb::coordinate* mu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mu_;
  }
  if (mu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mu);
    if (message_arena != submessage_arena) {
      mu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mu, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mu_ = mu;
  // @@protoc_insertion_point(field_set_allocated:pb.ellipseGate.mu)
}

// repeated .pb.coordinate cov = 2;
inline int ellipseGate::_internal_cov_size() const {
  return cov_.size();
}
inline int ellipseGate::cov_size() const {
  return _internal_cov_size();
}
inline void ellipseGate::clear_cov() {
  cov_.Clear();
}
inline ::pb::coordinate* ellipseGate::mutable_cov(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ellipseGate.cov)
  return cov_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >*
ellipseGate::mutable_cov() {
  // @@protoc_insertion_point(field_mutable_list:pb.ellipseGate.cov)
  return &cov_;
}
inline const ::pb::coordinate& ellipseGate::_internal_cov(int index) const {
  return cov_.Get(index);
}
inline const ::pb::coordinate& ellipseGate::cov(int index) const {
  // @@protoc_insertion_point(field_get:pb.ellipseGate.cov)
  return _internal_cov(index);
}
inline ::pb::coordinate* ellipseGate::_internal_add_cov() {
  return cov_.Add();
}
inline ::pb::coordinate* ellipseGate::add_cov() {
  // @@protoc_insertion_point(field_add:pb.ellipseGate.cov)
  return _internal_add_cov();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >&
ellipseGate::cov() const {
  // @@protoc_insertion_point(field_list:pb.ellipseGate.cov)
  return cov_;
}

// repeated .pb.coordinate antipodal_vertices = 3;
inline int ellipseGate::_internal_antipodal_vertices_size() const {
  return antipodal_vertices_.size();
}
inline int ellipseGate::antipodal_vertices_size() const {
  return _internal_antipodal_vertices_size();
}
inline void ellipseGate::clear_antipodal_vertices() {
  antipodal_vertices_.Clear();
}
inline ::pb::coordinate* ellipseGate::mutable_antipodal_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ellipseGate.antipodal_vertices)
  return antipodal_vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >*
ellipseGate::mutable_antipodal_vertices() {
  // @@protoc_insertion_point(field_mutable_list:pb.ellipseGate.antipodal_vertices)
  return &antipodal_vertices_;
}
inline const ::pb::coordinate& ellipseGate::_internal_antipodal_vertices(int index) const {
  return antipodal_vertices_.Get(index);
}
inline const ::pb::coordinate& ellipseGate::antipodal_vertices(int index) const {
  // @@protoc_insertion_point(field_get:pb.ellipseGate.antipodal_vertices)
  return _internal_antipodal_vertices(index);
}
inline ::pb::coordinate* ellipseGate::_internal_add_antipodal_vertices() {
  return antipodal_vertices_.Add();
}
inline ::pb::coordinate* ellipseGate::add_antipodal_vertices() {
  // @@protoc_insertion_point(field_add:pb.ellipseGate.antipodal_vertices)
  return _internal_add_antipodal_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::coordinate >&
ellipseGate::antipodal_vertices() const {
  // @@protoc_insertion_point(field_list:pb.ellipseGate.antipodal_vertices)
  return antipodal_vertices_;
}

// optional float dist = 4;
inline bool ellipseGate::_internal_has_dist() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ellipseGate::has_dist() const {
  return _internal_has_dist();
}
inline void ellipseGate::clear_dist() {
  dist_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ellipseGate::_internal_dist() const {
  return dist_;
}
inline float ellipseGate::dist() const {
  // @@protoc_insertion_point(field_get:pb.ellipseGate.dist)
  return _internal_dist();
}
inline void ellipseGate::_internal_set_dist(float value) {
  _has_bits_[0] |= 0x00000002u;
  dist_ = value;
}
inline void ellipseGate::set_dist(float value) {
  _internal_set_dist(value);
  // @@protoc_insertion_point(field_set:pb.ellipseGate.dist)
}

// -------------------------------------------------------------------

// BOOL_GATE_OP

// repeated string path = 1;
inline int BOOL_GATE_OP::_internal_path_size() const {
  return path_.size();
}
inline int BOOL_GATE_OP::path_size() const {
  return _internal_path_size();
}
inline void BOOL_GATE_OP::clear_path() {
  path_.Clear();
}
inline std::string* BOOL_GATE_OP::add_path() {
  // @@protoc_insertion_point(field_add_mutable:pb.BOOL_GATE_OP.path)
  return _internal_add_path();
}
inline const std::string& BOOL_GATE_OP::_internal_path(int index) const {
  return path_.Get(index);
}
inline const std::string& BOOL_GATE_OP::path(int index) const {
  // @@protoc_insertion_point(field_get:pb.BOOL_GATE_OP.path)
  return _internal_path(index);
}
inline std::string* BOOL_GATE_OP::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BOOL_GATE_OP.path)
  return path_.Mutable(index);
}
inline void BOOL_GATE_OP::set_path(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:pb.BOOL_GATE_OP.path)
  path_.Mutable(index)->assign(value);
}
inline void BOOL_GATE_OP::set_path(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.BOOL_GATE_OP.path)
  path_.Mutable(index)->assign(std::move(value));
}
inline void BOOL_GATE_OP::set_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BOOL_GATE_OP.path)
}
inline void BOOL_GATE_OP::set_path(int index, const char* value, size_t size) {
  path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BOOL_GATE_OP.path)
}
inline std::string* BOOL_GATE_OP::_internal_add_path() {
  return path_.Add();
}
inline void BOOL_GATE_OP::add_path(const std::string& value) {
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.BOOL_GATE_OP.path)
}
inline void BOOL_GATE_OP::add_path(std::string&& value) {
  path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.BOOL_GATE_OP.path)
}
inline void BOOL_GATE_OP::add_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.BOOL_GATE_OP.path)
}
inline void BOOL_GATE_OP::add_path(const char* value, size_t size) {
  path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.BOOL_GATE_OP.path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BOOL_GATE_OP::path() const {
  // @@protoc_insertion_point(field_list:pb.BOOL_GATE_OP.path)
  return path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BOOL_GATE_OP::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:pb.BOOL_GATE_OP.path)
  return &path_;
}

// required uint32 op = 2;
inline bool BOOL_GATE_OP::_internal_has_op() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BOOL_GATE_OP::has_op() const {
  return _internal_has_op();
}
inline void BOOL_GATE_OP::clear_op() {
  op_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BOOL_GATE_OP::_internal_op() const {
  return op_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BOOL_GATE_OP::op() const {
  // @@protoc_insertion_point(field_get:pb.BOOL_GATE_OP.op)
  return _internal_op();
}
inline void BOOL_GATE_OP::_internal_set_op(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  op_ = value;
}
inline void BOOL_GATE_OP::set_op(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:pb.BOOL_GATE_OP.op)
}

// required bool isNot = 3;
inline bool BOOL_GATE_OP::_internal_has_isnot() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BOOL_GATE_OP::has_isnot() const {
  return _internal_has_isnot();
}
inline void BOOL_GATE_OP::clear_isnot() {
  isnot_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool BOOL_GATE_OP::_internal_isnot() const {
  return isnot_;
}
inline bool BOOL_GATE_OP::isnot() const {
  // @@protoc_insertion_point(field_get:pb.BOOL_GATE_OP.isNot)
  return _internal_isnot();
}
inline void BOOL_GATE_OP::_internal_set_isnot(bool value) {
  _has_bits_[0] |= 0x00000002u;
  isnot_ = value;
}
inline void BOOL_GATE_OP::set_isnot(bool value) {
  _internal_set_isnot(value);
  // @@protoc_insertion_point(field_set:pb.BOOL_GATE_OP.isNot)
}

// -------------------------------------------------------------------

// boolGate

// repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
inline int boolGate::_internal_boolopspec_size() const {
  return boolopspec_.size();
}
inline int boolGate::boolopspec_size() const {
  return _internal_boolopspec_size();
}
inline void boolGate::clear_boolopspec() {
  boolopspec_.Clear();
}
inline ::pb::BOOL_GATE_OP* boolGate::mutable_boolopspec(int index) {
  // @@protoc_insertion_point(field_mutable:pb.boolGate.boolOpSpec)
  return boolopspec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::BOOL_GATE_OP >*
boolGate::mutable_boolopspec() {
  // @@protoc_insertion_point(field_mutable_list:pb.boolGate.boolOpSpec)
  return &boolopspec_;
}
inline const ::pb::BOOL_GATE_OP& boolGate::_internal_boolopspec(int index) const {
  return boolopspec_.Get(index);
}
inline const ::pb::BOOL_GATE_OP& boolGate::boolopspec(int index) const {
  // @@protoc_insertion_point(field_get:pb.boolGate.boolOpSpec)
  return _internal_boolopspec(index);
}
inline ::pb::BOOL_GATE_OP* boolGate::_internal_add_boolopspec() {
  return boolopspec_.Add();
}
inline ::pb::BOOL_GATE_OP* boolGate::add_boolopspec() {
  // @@protoc_insertion_point(field_add:pb.boolGate.boolOpSpec)
  return _internal_add_boolopspec();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::BOOL_GATE_OP >&
boolGate::boolopspec() const {
  // @@protoc_insertion_point(field_list:pb.boolGate.boolOpSpec)
  return boolopspec_;
}

// -------------------------------------------------------------------

// clusterGate

// required string cluster_method = 1;
inline bool clusterGate::_internal_has_cluster_method() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool clusterGate::has_cluster_method() const {
  return _internal_has_cluster_method();
}
inline void clusterGate::clear_cluster_method() {
  cluster_method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& clusterGate::cluster_method() const {
  // @@protoc_insertion_point(field_get:pb.clusterGate.cluster_method)
  return _internal_cluster_method();
}
inline void clusterGate::set_cluster_method(const std::string& value) {
  _internal_set_cluster_method(value);
  // @@protoc_insertion_point(field_set:pb.clusterGate.cluster_method)
}
inline std::string* clusterGate::mutable_cluster_method() {
  // @@protoc_insertion_point(field_mutable:pb.clusterGate.cluster_method)
  return _internal_mutable_cluster_method();
}
inline const std::string& clusterGate::_internal_cluster_method() const {
  return cluster_method_.Get();
}
inline void clusterGate::_internal_set_cluster_method(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cluster_method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void clusterGate::set_cluster_method(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  cluster_method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.clusterGate.cluster_method)
}
inline void clusterGate::set_cluster_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  cluster_method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.clusterGate.cluster_method)
}
inline void clusterGate::set_cluster_method(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  cluster_method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.clusterGate.cluster_method)
}
inline std::string* clusterGate::_internal_mutable_cluster_method() {
  _has_bits_[0] |= 0x00000001u;
  return cluster_method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* clusterGate::release_cluster_method() {
  // @@protoc_insertion_point(field_release:pb.clusterGate.cluster_method)
  if (!_internal_has_cluster_method()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cluster_method_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void clusterGate::set_allocated_cluster_method(std::string* cluster_method) {
  if (cluster_method != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cluster_method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cluster_method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.clusterGate.cluster_method)
}

// -------------------------------------------------------------------

// quadGate

// required string uid = 1;
inline bool quadGate::_internal_has_uid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool quadGate::has_uid() const {
  return _internal_has_uid();
}
inline void quadGate::clear_uid() {
  uid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& quadGate::uid() const {
  // @@protoc_insertion_point(field_get:pb.quadGate.uid)
  return _internal_uid();
}
inline void quadGate::set_uid(const std::string& value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:pb.quadGate.uid)
}
inline std::string* quadGate::mutable_uid() {
  // @@protoc_insertion_point(field_mutable:pb.quadGate.uid)
  return _internal_mutable_uid();
}
inline const std::string& quadGate::_internal_uid() const {
  return uid_.Get();
}
inline void quadGate::_internal_set_uid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void quadGate::set_uid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  uid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.quadGate.uid)
}
inline void quadGate::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.quadGate.uid)
}
inline void quadGate::set_uid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.quadGate.uid)
}
inline std::string* quadGate::_internal_mutable_uid() {
  _has_bits_[0] |= 0x00000001u;
  return uid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* quadGate::release_uid() {
  // @@protoc_insertion_point(field_release:pb.quadGate.uid)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return uid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void quadGate::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.quadGate.uid)
}

// required .pb.QUADRANT quadrant = 3;
inline bool quadGate::_internal_has_quadrant() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool quadGate::has_quadrant() const {
  return _internal_has_quadrant();
}
inline void quadGate::clear_quadrant() {
  quadrant_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::pb::QUADRANT quadGate::_internal_quadrant() const {
  return static_cast< ::pb::QUADRANT >(quadrant_);
}
inline ::pb::QUADRANT quadGate::quadrant() const {
  // @@protoc_insertion_point(field_get:pb.quadGate.quadrant)
  return _internal_quadrant();
}
inline void quadGate::_internal_set_quadrant(::pb::QUADRANT value) {
  assert(::pb::QUADRANT_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  quadrant_ = value;
}
inline void quadGate::set_quadrant(::pb::QUADRANT value) {
  _internal_set_quadrant(value);
  // @@protoc_insertion_point(field_set:pb.quadGate.quadrant)
}

// -------------------------------------------------------------------

// gate

// required bool neg = 1;
inline bool gate::_internal_has_neg() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool gate::has_neg() const {
  return _internal_has_neg();
}
inline void gate::clear_neg() {
  neg_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool gate::_internal_neg() const {
  return neg_;
}
inline bool gate::neg() const {
  // @@protoc_insertion_point(field_get:pb.gate.neg)
  return _internal_neg();
}
inline void gate::_internal_set_neg(bool value) {
  _has_bits_[0] |= 0x00000020u;
  neg_ = value;
}
inline void gate::set_neg(bool value) {
  _internal_set_neg(value);
  // @@protoc_insertion_point(field_set:pb.gate.neg)
}

// required bool isTransformed = 2;
inline bool gate::_internal_has_istransformed() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool gate::has_istransformed() const {
  return _internal_has_istransformed();
}
inline void gate::clear_istransformed() {
  istransformed_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool gate::_internal_istransformed() const {
  return istransformed_;
}
inline bool gate::istransformed() const {
  // @@protoc_insertion_point(field_get:pb.gate.isTransformed)
  return _internal_istransformed();
}
inline void gate::_internal_set_istransformed(bool value) {
  _has_bits_[0] |= 0x00000040u;
  istransformed_ = value;
}
inline void gate::set_istransformed(bool value) {
  _internal_set_istransformed(value);
  // @@protoc_insertion_point(field_set:pb.gate.isTransformed)
}

// required bool isGained = 3;
inline bool gate::_internal_has_isgained() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool gate::has_isgained() const {
  return _internal_has_isgained();
}
inline void gate::clear_isgained() {
  isgained_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool gate::_internal_isgained() const {
  return isgained_;
}
inline bool gate::isgained() const {
  // @@protoc_insertion_point(field_get:pb.gate.isGained)
  return _internal_isgained();
}
inline void gate::_internal_set_isgained(bool value) {
  _has_bits_[0] |= 0x00000080u;
  isgained_ = value;
}
inline void gate::set_isgained(bool value) {
  _internal_set_isgained(value);
  // @@protoc_insertion_point(field_set:pb.gate.isGained)
}

// required .pb.GATE_TYPE type = 4;
inline bool gate::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool gate::has_type() const {
  return _internal_has_type();
}
inline void gate::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::pb::GATE_TYPE gate::_internal_type() const {
  return static_cast< ::pb::GATE_TYPE >(type_);
}
inline ::pb::GATE_TYPE gate::type() const {
  // @@protoc_insertion_point(field_get:pb.gate.type)
  return _internal_type();
}
inline void gate::_internal_set_type(::pb::GATE_TYPE value) {
  assert(::pb::GATE_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  type_ = value;
}
inline void gate::set_type(::pb::GATE_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.gate.type)
}

// optional .pb.rangeGate rg = 5;
inline bool gate::_internal_has_rg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rg_ != nullptr);
  return value;
}
inline bool gate::has_rg() const {
  return _internal_has_rg();
}
inline void gate::clear_rg() {
  if (rg_ != nullptr) rg_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::rangeGate& gate::_internal_rg() const {
  const ::pb::rangeGate* p = rg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::rangeGate*>(
      &::pb::_rangeGate_default_instance_);
}
inline const ::pb::rangeGate& gate::rg() const {
  // @@protoc_insertion_point(field_get:pb.gate.rg)
  return _internal_rg();
}
inline void gate::unsafe_arena_set_allocated_rg(
    ::pb::rangeGate* rg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rg_);
  }
  rg_ = rg;
  if (rg) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.gate.rg)
}
inline ::pb::rangeGate* gate::release_rg() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::rangeGate* temp = rg_;
  rg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::rangeGate* gate::unsafe_arena_release_rg() {
  // @@protoc_insertion_point(field_release:pb.gate.rg)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::rangeGate* temp = rg_;
  rg_ = nullptr;
  return temp;
}
inline ::pb::rangeGate* gate::_internal_mutable_rg() {
  _has_bits_[0] |= 0x00000001u;
  if (rg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::rangeGate>(GetArena());
    rg_ = p;
  }
  return rg_;
}
inline ::pb::rangeGate* gate::mutable_rg() {
  // @@protoc_insertion_point(field_mutable:pb.gate.rg)
  return _internal_mutable_rg();
}
inline void gate::set_allocated_rg(::pb::rangeGate* rg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rg_;
  }
  if (rg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rg);
    if (message_arena != submessage_arena) {
      rg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rg_ = rg;
  // @@protoc_insertion_point(field_set_allocated:pb.gate.rg)
}

// optional .pb.polygonGate pg = 6;
inline bool gate::_internal_has_pg() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pg_ != nullptr);
  return value;
}
inline bool gate::has_pg() const {
  return _internal_has_pg();
}
inline void gate::clear_pg() {
  if (pg_ != nullptr) pg_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pb::polygonGate& gate::_internal_pg() const {
  const ::pb::polygonGate* p = pg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::polygonGate*>(
      &::pb::_polygonGate_default_instance_);
}
inline const ::pb::polygonGate& gate::pg() const {
  // @@protoc_insertion_point(field_get:pb.gate.pg)
  return _internal_pg();
}
inline void gate::unsafe_arena_set_allocated_pg(
    ::pb::polygonGate* pg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pg_);
  }
  pg_ = pg;
  if (pg) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.gate.pg)
}
inline ::pb::polygonGate* gate::release_pg() {
  _has_bits_[0] &= ~0x00000002u;
  ::pb::polygonGate* temp = pg_;
  pg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::polygonGate* gate::unsafe_arena_release_pg() {
  // @@protoc_insertion_point(field_release:pb.gate.pg)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::polygonGate* temp = pg_;
  pg_ = nullptr;
  return temp;
}
inline ::pb::polygonGate* gate::_internal_mutable_pg() {
  _has_bits_[0] |= 0x00000002u;
  if (pg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::polygonGate>(GetArena());
    pg_ = p;
  }
  return pg_;
}
inline ::pb::polygonGate* gate::mutable_pg() {
  // @@protoc_insertion_point(field_mutable:pb.gate.pg)
  return _internal_mutable_pg();
}
inline void gate::set_allocated_pg(::pb::polygonGate* pg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pg_;
  }
  if (pg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pg);
    if (message_arena != submessage_arena) {
      pg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pg_ = pg;
  // @@protoc_insertion_point(field_set_allocated:pb.gate.pg)
}

// optional .pb.ellipseGate eg = 7;
inline bool gate::_internal_has_eg() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || eg_ != nullptr);
  return value;
}
inline bool gate::has_eg() const {
  return _internal_has_eg();
}
inline void gate::clear_eg() {
  if (eg_ != nullptr) eg_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pb::ellipseGate& gate::_internal_eg() const {
  const ::pb::ellipseGate* p = eg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::ellipseGate*>(
      &::pb::_ellipseGate_default_instance_);
}
inline const ::pb::ellipseGate& gate::eg() const {
  // @@protoc_insertion_point(field_get:pb.gate.eg)
  return _internal_eg();
}
inline void gate::unsafe_arena_set_allocated_eg(
    ::pb::ellipseGate* eg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eg_);
  }
  eg_ = eg;
  if (eg) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.gate.eg)
}
inline ::pb::ellipseGate* gate::release_eg() {
  _has_bits_[0] &= ~0x00000004u;
  ::pb::ellipseGate* temp = eg_;
  eg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::ellipseGate* gate::unsafe_arena_release_eg() {
  // @@protoc_insertion_point(field_release:pb.gate.eg)
  _has_bits_[0] &= ~0x00000004u;
  ::pb::ellipseGate* temp = eg_;
  eg_ = nullptr;
  return temp;
}
inline ::pb::ellipseGate* gate::_internal_mutable_eg() {
  _has_bits_[0] |= 0x00000004u;
  if (eg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::ellipseGate>(GetArena());
    eg_ = p;
  }
  return eg_;
}
inline ::pb::ellipseGate* gate::mutable_eg() {
  // @@protoc_insertion_point(field_mutable:pb.gate.eg)
  return _internal_mutable_eg();
}
inline void gate::set_allocated_eg(::pb::ellipseGate* eg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete eg_;
  }
  if (eg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(eg);
    if (message_arena != submessage_arena) {
      eg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  eg_ = eg;
  // @@protoc_insertion_point(field_set_allocated:pb.gate.eg)
}

// optional .pb.boolGate bg = 8;
inline bool gate::_internal_has_bg() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || bg_ != nullptr);
  return value;
}
inline bool gate::has_bg() const {
  return _internal_has_bg();
}
inline void gate::clear_bg() {
  if (bg_ != nullptr) bg_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pb::boolGate& gate::_internal_bg() const {
  const ::pb::boolGate* p = bg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::boolGate*>(
      &::pb::_boolGate_default_instance_);
}
inline const ::pb::boolGate& gate::bg() const {
  // @@protoc_insertion_point(field_get:pb.gate.bg)
  return _internal_bg();
}
inline void gate::unsafe_arena_set_allocated_bg(
    ::pb::boolGate* bg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bg_);
  }
  bg_ = bg;
  if (bg) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.gate.bg)
}
inline ::pb::boolGate* gate::release_bg() {
  _has_bits_[0] &= ~0x00000008u;
  ::pb::boolGate* temp = bg_;
  bg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::boolGate* gate::unsafe_arena_release_bg() {
  // @@protoc_insertion_point(field_release:pb.gate.bg)
  _has_bits_[0] &= ~0x00000008u;
  ::pb::boolGate* temp = bg_;
  bg_ = nullptr;
  return temp;
}
inline ::pb::boolGate* gate::_internal_mutable_bg() {
  _has_bits_[0] |= 0x00000008u;
  if (bg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::boolGate>(GetArena());
    bg_ = p;
  }
  return bg_;
}
inline ::pb::boolGate* gate::mutable_bg() {
  // @@protoc_insertion_point(field_mutable:pb.gate.bg)
  return _internal_mutable_bg();
}
inline void gate::set_allocated_bg(::pb::boolGate* bg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bg_;
  }
  if (bg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bg);
    if (message_arena != submessage_arena) {
      bg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  bg_ = bg;
  // @@protoc_insertion_point(field_set_allocated:pb.gate.bg)
}

// optional .pb.clusterGate cg = 9;
inline bool gate::_internal_has_cg() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || cg_ != nullptr);
  return value;
}
inline bool gate::has_cg() const {
  return _internal_has_cg();
}
inline void gate::clear_cg() {
  if (cg_ != nullptr) cg_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::pb::clusterGate& gate::_internal_cg() const {
  const ::pb::clusterGate* p = cg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::clusterGate*>(
      &::pb::_clusterGate_default_instance_);
}
inline const ::pb::clusterGate& gate::cg() const {
  // @@protoc_insertion_point(field_get:pb.gate.cg)
  return _internal_cg();
}
inline void gate::unsafe_arena_set_allocated_cg(
    ::pb::clusterGate* cg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cg_);
  }
  cg_ = cg;
  if (cg) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.gate.cg)
}
inline ::pb::clusterGate* gate::release_cg() {
  _has_bits_[0] &= ~0x00000010u;
  ::pb::clusterGate* temp = cg_;
  cg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::clusterGate* gate::unsafe_arena_release_cg() {
  // @@protoc_insertion_point(field_release:pb.gate.cg)
  _has_bits_[0] &= ~0x00000010u;
  ::pb::clusterGate* temp = cg_;
  cg_ = nullptr;
  return temp;
}
inline ::pb::clusterGate* gate::_internal_mutable_cg() {
  _has_bits_[0] |= 0x00000010u;
  if (cg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::clusterGate>(GetArena());
    cg_ = p;
  }
  return cg_;
}
inline ::pb::clusterGate* gate::mutable_cg() {
  // @@protoc_insertion_point(field_mutable:pb.gate.cg)
  return _internal_mutable_cg();
}
inline void gate::set_allocated_cg(::pb::clusterGate* cg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cg_;
  }
  if (cg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cg);
    if (message_arena != submessage_arena) {
      cg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  cg_ = cg;
  // @@protoc_insertion_point(field_set_allocated:pb.gate.cg)
}

// -------------------------------------------------------------------

// POPSTATS

// required string statType = 1;
inline bool POPSTATS::_internal_has_stattype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool POPSTATS::has_stattype() const {
  return _internal_has_stattype();
}
inline void POPSTATS::clear_stattype() {
  stattype_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& POPSTATS::stattype() const {
  // @@protoc_insertion_point(field_get:pb.POPSTATS.statType)
  return _internal_stattype();
}
inline void POPSTATS::set_stattype(const std::string& value) {
  _internal_set_stattype(value);
  // @@protoc_insertion_point(field_set:pb.POPSTATS.statType)
}
inline std::string* POPSTATS::mutable_stattype() {
  // @@protoc_insertion_point(field_mutable:pb.POPSTATS.statType)
  return _internal_mutable_stattype();
}
inline const std::string& POPSTATS::_internal_stattype() const {
  return stattype_.Get();
}
inline void POPSTATS::_internal_set_stattype(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  stattype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void POPSTATS::set_stattype(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  stattype_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.POPSTATS.statType)
}
inline void POPSTATS::set_stattype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  stattype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.POPSTATS.statType)
}
inline void POPSTATS::set_stattype(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  stattype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.POPSTATS.statType)
}
inline std::string* POPSTATS::_internal_mutable_stattype() {
  _has_bits_[0] |= 0x00000001u;
  return stattype_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* POPSTATS::release_stattype() {
  // @@protoc_insertion_point(field_release:pb.POPSTATS.statType)
  if (!_internal_has_stattype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return stattype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void POPSTATS::set_allocated_stattype(std::string* stattype) {
  if (stattype != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stattype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stattype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.POPSTATS.statType)
}

// required float statVal = 2;
inline bool POPSTATS::_internal_has_statval() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool POPSTATS::has_statval() const {
  return _internal_has_statval();
}
inline void POPSTATS::clear_statval() {
  statval_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float POPSTATS::_internal_statval() const {
  return statval_;
}
inline float POPSTATS::statval() const {
  // @@protoc_insertion_point(field_get:pb.POPSTATS.statVal)
  return _internal_statval();
}
inline void POPSTATS::_internal_set_statval(float value) {
  _has_bits_[0] |= 0x00000002u;
  statval_ = value;
}
inline void POPSTATS::set_statval(float value) {
  _internal_set_statval(value);
  // @@protoc_insertion_point(field_set:pb.POPSTATS.statVal)
}

// -------------------------------------------------------------------

// calibrationTable

// repeated float x = 1 [packed = true];
inline int calibrationTable::_internal_x_size() const {
  return x_.size();
}
inline int calibrationTable::x_size() const {
  return _internal_x_size();
}
inline void calibrationTable::clear_x() {
  x_.Clear();
}
inline float calibrationTable::_internal_x(int index) const {
  return x_.Get(index);
}
inline float calibrationTable::x(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.x)
  return _internal_x(index);
}
inline void calibrationTable::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.x)
}
inline void calibrationTable::_internal_add_x(float value) {
  x_.Add(value);
}
inline void calibrationTable::add_x(float value) {
  _internal_add_x(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.x)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::_internal_x() const {
  return x_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::x() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.x)
  return _internal_x();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::_internal_mutable_x() {
  return &x_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.x)
  return _internal_mutable_x();
}

// repeated float y = 2 [packed = true];
inline int calibrationTable::_internal_y_size() const {
  return y_.size();
}
inline int calibrationTable::y_size() const {
  return _internal_y_size();
}
inline void calibrationTable::clear_y() {
  y_.Clear();
}
inline float calibrationTable::_internal_y(int index) const {
  return y_.Get(index);
}
inline float calibrationTable::y(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.y)
  return _internal_y(index);
}
inline void calibrationTable::set_y(int index, float value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.y)
}
inline void calibrationTable::_internal_add_y(float value) {
  y_.Add(value);
}
inline void calibrationTable::add_y(float value) {
  _internal_add_y(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.y)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::_internal_y() const {
  return y_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::y() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.y)
  return _internal_y();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::_internal_mutable_y() {
  return &y_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.y)
  return _internal_mutable_y();
}

// repeated float b = 3 [packed = true];
inline int calibrationTable::_internal_b_size() const {
  return b_.size();
}
inline int calibrationTable::b_size() const {
  return _internal_b_size();
}
inline void calibrationTable::clear_b() {
  b_.Clear();
}
inline float calibrationTable::_internal_b(int index) const {
  return b_.Get(index);
}
inline float calibrationTable::b(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.b)
  return _internal_b(index);
}
inline void calibrationTable::set_b(int index, float value) {
  b_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.b)
}
inline void calibrationTable::_internal_add_b(float value) {
  b_.Add(value);
}
inline void calibrationTable::add_b(float value) {
  _internal_add_b(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.b)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::_internal_b() const {
  return b_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::b() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.b)
  return _internal_b();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::_internal_mutable_b() {
  return &b_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::mutable_b() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.b)
  return _internal_mutable_b();
}

// repeated float c = 4 [packed = true];
inline int calibrationTable::_internal_c_size() const {
  return c_.size();
}
inline int calibrationTable::c_size() const {
  return _internal_c_size();
}
inline void calibrationTable::clear_c() {
  c_.Clear();
}
inline float calibrationTable::_internal_c(int index) const {
  return c_.Get(index);
}
inline float calibrationTable::c(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.c)
  return _internal_c(index);
}
inline void calibrationTable::set_c(int index, float value) {
  c_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.c)
}
inline void calibrationTable::_internal_add_c(float value) {
  c_.Add(value);
}
inline void calibrationTable::add_c(float value) {
  _internal_add_c(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.c)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::_internal_c() const {
  return c_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::c() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.c)
  return _internal_c();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::_internal_mutable_c() {
  return &c_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::mutable_c() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.c)
  return _internal_mutable_c();
}

// repeated float d = 5 [packed = true];
inline int calibrationTable::_internal_d_size() const {
  return d_.size();
}
inline int calibrationTable::d_size() const {
  return _internal_d_size();
}
inline void calibrationTable::clear_d() {
  d_.Clear();
}
inline float calibrationTable::_internal_d(int index) const {
  return d_.Get(index);
}
inline float calibrationTable::d(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.d)
  return _internal_d(index);
}
inline void calibrationTable::set_d(int index, float value) {
  d_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.d)
}
inline void calibrationTable::_internal_add_d(float value) {
  d_.Add(value);
}
inline void calibrationTable::add_d(float value) {
  _internal_add_d(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.d)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::_internal_d() const {
  return d_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
calibrationTable::d() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.d)
  return _internal_d();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::_internal_mutable_d() {
  return &d_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
calibrationTable::mutable_d() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.d)
  return _internal_mutable_d();
}

// optional uint32 spline_method = 6;
inline bool calibrationTable::_internal_has_spline_method() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool calibrationTable::has_spline_method() const {
  return _internal_has_spline_method();
}
inline void calibrationTable::clear_spline_method() {
  spline_method_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 calibrationTable::_internal_spline_method() const {
  return spline_method_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 calibrationTable::spline_method() const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.spline_method)
  return _internal_spline_method();
}
inline void calibrationTable::_internal_set_spline_method(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  spline_method_ = value;
}
inline void calibrationTable::set_spline_method(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_spline_method(value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.spline_method)
}

// optional string caltype = 7;
inline bool calibrationTable::_internal_has_caltype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool calibrationTable::has_caltype() const {
  return _internal_has_caltype();
}
inline void calibrationTable::clear_caltype() {
  caltype_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& calibrationTable::caltype() const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.caltype)
  return _internal_caltype();
}
inline void calibrationTable::set_caltype(const std::string& value) {
  _internal_set_caltype(value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.caltype)
}
inline std::string* calibrationTable::mutable_caltype() {
  // @@protoc_insertion_point(field_mutable:pb.calibrationTable.caltype)
  return _internal_mutable_caltype();
}
inline const std::string& calibrationTable::_internal_caltype() const {
  return caltype_.Get();
}
inline void calibrationTable::_internal_set_caltype(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  caltype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void calibrationTable::set_caltype(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  caltype_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.calibrationTable.caltype)
}
inline void calibrationTable::set_caltype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  caltype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.calibrationTable.caltype)
}
inline void calibrationTable::set_caltype(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  caltype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.calibrationTable.caltype)
}
inline std::string* calibrationTable::_internal_mutable_caltype() {
  _has_bits_[0] |= 0x00000001u;
  return caltype_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* calibrationTable::release_caltype() {
  // @@protoc_insertion_point(field_release:pb.calibrationTable.caltype)
  if (!_internal_has_caltype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return caltype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void calibrationTable::set_allocated_caltype(std::string* caltype) {
  if (caltype != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  caltype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caltype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.calibrationTable.caltype)
}

// optional bool flag = 8;
inline bool calibrationTable::_internal_has_flag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool calibrationTable::has_flag() const {
  return _internal_has_flag();
}
inline void calibrationTable::clear_flag() {
  flag_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool calibrationTable::_internal_flag() const {
  return flag_;
}
inline bool calibrationTable::flag() const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.flag)
  return _internal_flag();
}
inline void calibrationTable::_internal_set_flag(bool value) {
  _has_bits_[0] |= 0x00000004u;
  flag_ = value;
}
inline void calibrationTable::set_flag(bool value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.flag)
}

// -------------------------------------------------------------------

// biexpTrans

// optional uint32 channelRange = 1;
inline bool biexpTrans::_internal_has_channelrange() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool biexpTrans::has_channelrange() const {
  return _internal_has_channelrange();
}
inline void biexpTrans::clear_channelrange() {
  channelrange_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 biexpTrans::_internal_channelrange() const {
  return channelrange_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 biexpTrans::channelrange() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.channelRange)
  return _internal_channelrange();
}
inline void biexpTrans::_internal_set_channelrange(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channelrange_ = value;
}
inline void biexpTrans::set_channelrange(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channelrange(value);
  // @@protoc_insertion_point(field_set:pb.biexpTrans.channelRange)
}

// optional float pos = 2;
inline bool biexpTrans::_internal_has_pos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool biexpTrans::has_pos() const {
  return _internal_has_pos();
}
inline void biexpTrans::clear_pos() {
  pos_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float biexpTrans::_internal_pos() const {
  return pos_;
}
inline float biexpTrans::pos() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.pos)
  return _internal_pos();
}
inline void biexpTrans::_internal_set_pos(float value) {
  _has_bits_[0] |= 0x00000002u;
  pos_ = value;
}
inline void biexpTrans::set_pos(float value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:pb.biexpTrans.pos)
}

// optional float neg = 3;
inline bool biexpTrans::_internal_has_neg() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool biexpTrans::has_neg() const {
  return _internal_has_neg();
}
inline void biexpTrans::clear_neg() {
  neg_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float biexpTrans::_internal_neg() const {
  return neg_;
}
inline float biexpTrans::neg() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.neg)
  return _internal_neg();
}
inline void biexpTrans::_internal_set_neg(float value) {
  _has_bits_[0] |= 0x00000004u;
  neg_ = value;
}
inline void biexpTrans::set_neg(float value) {
  _internal_set_neg(value);
  // @@protoc_insertion_point(field_set:pb.biexpTrans.neg)
}

// optional float widthBasis = 4;
inline bool biexpTrans::_internal_has_widthbasis() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool biexpTrans::has_widthbasis() const {
  return _internal_has_widthbasis();
}
inline void biexpTrans::clear_widthbasis() {
  widthbasis_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float biexpTrans::_internal_widthbasis() const {
  return widthbasis_;
}
inline float biexpTrans::widthbasis() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.widthBasis)
  return _internal_widthbasis();
}
inline void biexpTrans::_internal_set_widthbasis(float value) {
  _has_bits_[0] |= 0x00000008u;
  widthbasis_ = value;
}
inline void biexpTrans::set_widthbasis(float value) {
  _internal_set_widthbasis(value);
  // @@protoc_insertion_point(field_set:pb.biexpTrans.widthBasis)
}

// optional float maxValue = 5;
inline bool biexpTrans::_internal_has_maxvalue() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool biexpTrans::has_maxvalue() const {
  return _internal_has_maxvalue();
}
inline void biexpTrans::clear_maxvalue() {
  maxvalue_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float biexpTrans::_internal_maxvalue() const {
  return maxvalue_;
}
inline float biexpTrans::maxvalue() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.maxValue)
  return _internal_maxvalue();
}
inline void biexpTrans::_internal_set_maxvalue(float value) {
  _has_bits_[0] |= 0x00000010u;
  maxvalue_ = value;
}
inline void biexpTrans::set_maxvalue(float value) {
  _internal_set_maxvalue(value);
  // @@protoc_insertion_point(field_set:pb.biexpTrans.maxValue)
}

// -------------------------------------------------------------------

// fasinhTrans

// optional float length = 1;
inline bool fasinhTrans::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool fasinhTrans::has_length() const {
  return _internal_has_length();
}
inline void fasinhTrans::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float fasinhTrans::_internal_length() const {
  return length_;
}
inline float fasinhTrans::length() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.length)
  return _internal_length();
}
inline void fasinhTrans::_internal_set_length(float value) {
  _has_bits_[0] |= 0x00000001u;
  length_ = value;
}
inline void fasinhTrans::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.length)
}

// optional float maxRange = 2;
inline bool fasinhTrans::_internal_has_maxrange() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool fasinhTrans::has_maxrange() const {
  return _internal_has_maxrange();
}
inline void fasinhTrans::clear_maxrange() {
  maxrange_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float fasinhTrans::_internal_maxrange() const {
  return maxrange_;
}
inline float fasinhTrans::maxrange() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.maxRange)
  return _internal_maxrange();
}
inline void fasinhTrans::_internal_set_maxrange(float value) {
  _has_bits_[0] |= 0x00000002u;
  maxrange_ = value;
}
inline void fasinhTrans::set_maxrange(float value) {
  _internal_set_maxrange(value);
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.maxRange)
}

// optional float T = 3;
inline bool fasinhTrans::_internal_has_t() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool fasinhTrans::has_t() const {
  return _internal_has_t();
}
inline void fasinhTrans::clear_t() {
  t_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float fasinhTrans::_internal_t() const {
  return t_;
}
inline float fasinhTrans::t() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.T)
  return _internal_t();
}
inline void fasinhTrans::_internal_set_t(float value) {
  _has_bits_[0] |= 0x00000004u;
  t_ = value;
}
inline void fasinhTrans::set_t(float value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.T)
}

// optional float A = 4;
inline bool fasinhTrans::_internal_has_a() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool fasinhTrans::has_a() const {
  return _internal_has_a();
}
inline void fasinhTrans::clear_a() {
  a_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float fasinhTrans::_internal_a() const {
  return a_;
}
inline float fasinhTrans::a() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.A)
  return _internal_a();
}
inline void fasinhTrans::_internal_set_a(float value) {
  _has_bits_[0] |= 0x00000008u;
  a_ = value;
}
inline void fasinhTrans::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.A)
}

// optional float M = 5;
inline bool fasinhTrans::_internal_has_m() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool fasinhTrans::has_m() const {
  return _internal_has_m();
}
inline void fasinhTrans::clear_m() {
  m_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float fasinhTrans::_internal_m() const {
  return m_;
}
inline float fasinhTrans::m() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.M)
  return _internal_m();
}
inline void fasinhTrans::_internal_set_m(float value) {
  _has_bits_[0] |= 0x00000010u;
  m_ = value;
}
inline void fasinhTrans::set_m(float value) {
  _internal_set_m(value);
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.M)
}

// -------------------------------------------------------------------

// scaleTrans

// optional float scale_factor = 1;
inline bool scaleTrans::_internal_has_scale_factor() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool scaleTrans::has_scale_factor() const {
  return _internal_has_scale_factor();
}
inline void scaleTrans::clear_scale_factor() {
  scale_factor_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float scaleTrans::_internal_scale_factor() const {
  return scale_factor_;
}
inline float scaleTrans::scale_factor() const {
  // @@protoc_insertion_point(field_get:pb.scaleTrans.scale_factor)
  return _internal_scale_factor();
}
inline void scaleTrans::_internal_set_scale_factor(float value) {
  _has_bits_[0] |= 0x00000001u;
  scale_factor_ = value;
}
inline void scaleTrans::set_scale_factor(float value) {
  _internal_set_scale_factor(value);
  // @@protoc_insertion_point(field_set:pb.scaleTrans.scale_factor)
}

// optional float t_scale = 2;
inline bool scaleTrans::_internal_has_t_scale() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool scaleTrans::has_t_scale() const {
  return _internal_has_t_scale();
}
inline void scaleTrans::clear_t_scale() {
  t_scale_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float scaleTrans::_internal_t_scale() const {
  return t_scale_;
}
inline float scaleTrans::t_scale() const {
  // @@protoc_insertion_point(field_get:pb.scaleTrans.t_scale)
  return _internal_t_scale();
}
inline void scaleTrans::_internal_set_t_scale(float value) {
  _has_bits_[0] |= 0x00000002u;
  t_scale_ = value;
}
inline void scaleTrans::set_t_scale(float value) {
  _internal_set_t_scale(value);
  // @@protoc_insertion_point(field_set:pb.scaleTrans.t_scale)
}

// optional float r_scale = 3;
inline bool scaleTrans::_internal_has_r_scale() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool scaleTrans::has_r_scale() const {
  return _internal_has_r_scale();
}
inline void scaleTrans::clear_r_scale() {
  r_scale_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float scaleTrans::_internal_r_scale() const {
  return r_scale_;
}
inline float scaleTrans::r_scale() const {
  // @@protoc_insertion_point(field_get:pb.scaleTrans.r_scale)
  return _internal_r_scale();
}
inline void scaleTrans::_internal_set_r_scale(float value) {
  _has_bits_[0] |= 0x00000004u;
  r_scale_ = value;
}
inline void scaleTrans::set_r_scale(float value) {
  _internal_set_r_scale(value);
  // @@protoc_insertion_point(field_set:pb.scaleTrans.r_scale)
}

// -------------------------------------------------------------------

// flinTrans

// optional float min = 1;
inline bool flinTrans::_internal_has_min() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool flinTrans::has_min() const {
  return _internal_has_min();
}
inline void flinTrans::clear_min() {
  min_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float flinTrans::_internal_min() const {
  return min_;
}
inline float flinTrans::min() const {
  // @@protoc_insertion_point(field_get:pb.flinTrans.min)
  return _internal_min();
}
inline void flinTrans::_internal_set_min(float value) {
  _has_bits_[0] |= 0x00000001u;
  min_ = value;
}
inline void flinTrans::set_min(float value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:pb.flinTrans.min)
}

// optional float max = 2;
inline bool flinTrans::_internal_has_max() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flinTrans::has_max() const {
  return _internal_has_max();
}
inline void flinTrans::clear_max() {
  max_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float flinTrans::_internal_max() const {
  return max_;
}
inline float flinTrans::max() const {
  // @@protoc_insertion_point(field_get:pb.flinTrans.max)
  return _internal_max();
}
inline void flinTrans::_internal_set_max(float value) {
  _has_bits_[0] |= 0x00000002u;
  max_ = value;
}
inline void flinTrans::set_max(float value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:pb.flinTrans.max)
}

// -------------------------------------------------------------------

// logTrans

// optional float offset = 1;
inline bool logTrans::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool logTrans::has_offset() const {
  return _internal_has_offset();
}
inline void logTrans::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float logTrans::_internal_offset() const {
  return offset_;
}
inline float logTrans::offset() const {
  // @@protoc_insertion_point(field_get:pb.logTrans.offset)
  return _internal_offset();
}
inline void logTrans::_internal_set_offset(float value) {
  _has_bits_[0] |= 0x00000001u;
  offset_ = value;
}
inline void logTrans::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:pb.logTrans.offset)
}

// optional float decade = 2;
inline bool logTrans::_internal_has_decade() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool logTrans::has_decade() const {
  return _internal_has_decade();
}
inline void logTrans::clear_decade() {
  decade_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float logTrans::_internal_decade() const {
  return decade_;
}
inline float logTrans::decade() const {
  // @@protoc_insertion_point(field_get:pb.logTrans.decade)
  return _internal_decade();
}
inline void logTrans::_internal_set_decade(float value) {
  _has_bits_[0] |= 0x00000002u;
  decade_ = value;
}
inline void logTrans::set_decade(float value) {
  _internal_set_decade(value);
  // @@protoc_insertion_point(field_set:pb.logTrans.decade)
}

// optional float T = 3;
inline bool logTrans::_internal_has_t() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool logTrans::has_t() const {
  return _internal_has_t();
}
inline void logTrans::clear_t() {
  t_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float logTrans::_internal_t() const {
  return t_;
}
inline float logTrans::t() const {
  // @@protoc_insertion_point(field_get:pb.logTrans.T)
  return _internal_t();
}
inline void logTrans::_internal_set_t(float value) {
  _has_bits_[0] |= 0x00000004u;
  t_ = value;
}
inline void logTrans::set_t(float value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:pb.logTrans.T)
}

// optional float scale = 4;
inline bool logTrans::_internal_has_scale() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool logTrans::has_scale() const {
  return _internal_has_scale();
}
inline void logTrans::clear_scale() {
  scale_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float logTrans::_internal_scale() const {
  return scale_;
}
inline float logTrans::scale() const {
  // @@protoc_insertion_point(field_get:pb.logTrans.scale)
  return _internal_scale();
}
inline void logTrans::_internal_set_scale(float value) {
  _has_bits_[0] |= 0x00000008u;
  scale_ = value;
}
inline void logTrans::set_scale(float value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:pb.logTrans.scale)
}

// -------------------------------------------------------------------

// logGML2Trans

// optional float T = 1;
inline bool logGML2Trans::_internal_has_t() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool logGML2Trans::has_t() const {
  return _internal_has_t();
}
inline void logGML2Trans::clear_t() {
  t_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float logGML2Trans::_internal_t() const {
  return t_;
}
inline float logGML2Trans::t() const {
  // @@protoc_insertion_point(field_get:pb.logGML2Trans.T)
  return _internal_t();
}
inline void logGML2Trans::_internal_set_t(float value) {
  _has_bits_[0] |= 0x00000001u;
  t_ = value;
}
inline void logGML2Trans::set_t(float value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:pb.logGML2Trans.T)
}

// optional float M = 2;
inline bool logGML2Trans::_internal_has_m() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool logGML2Trans::has_m() const {
  return _internal_has_m();
}
inline void logGML2Trans::clear_m() {
  m_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float logGML2Trans::_internal_m() const {
  return m_;
}
inline float logGML2Trans::m() const {
  // @@protoc_insertion_point(field_get:pb.logGML2Trans.M)
  return _internal_m();
}
inline void logGML2Trans::_internal_set_m(float value) {
  _has_bits_[0] |= 0x00000002u;
  m_ = value;
}
inline void logGML2Trans::set_m(float value) {
  _internal_set_m(value);
  // @@protoc_insertion_point(field_set:pb.logGML2Trans.M)
}

// -------------------------------------------------------------------

// logicleTrans

// optional float T = 1;
inline bool logicleTrans::_internal_has_t() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool logicleTrans::has_t() const {
  return _internal_has_t();
}
inline void logicleTrans::clear_t() {
  t_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float logicleTrans::_internal_t() const {
  return t_;
}
inline float logicleTrans::t() const {
  // @@protoc_insertion_point(field_get:pb.logicleTrans.T)
  return _internal_t();
}
inline void logicleTrans::_internal_set_t(float value) {
  _has_bits_[0] |= 0x00000001u;
  t_ = value;
}
inline void logicleTrans::set_t(float value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:pb.logicleTrans.T)
}

// optional float W = 2;
inline bool logicleTrans::_internal_has_w() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool logicleTrans::has_w() const {
  return _internal_has_w();
}
inline void logicleTrans::clear_w() {
  w_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float logicleTrans::_internal_w() const {
  return w_;
}
inline float logicleTrans::w() const {
  // @@protoc_insertion_point(field_get:pb.logicleTrans.W)
  return _internal_w();
}
inline void logicleTrans::_internal_set_w(float value) {
  _has_bits_[0] |= 0x00000002u;
  w_ = value;
}
inline void logicleTrans::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:pb.logicleTrans.W)
}

// optional float M = 3;
inline bool logicleTrans::_internal_has_m() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool logicleTrans::has_m() const {
  return _internal_has_m();
}
inline void logicleTrans::clear_m() {
  m_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float logicleTrans::_internal_m() const {
  return m_;
}
inline float logicleTrans::m() const {
  // @@protoc_insertion_point(field_get:pb.logicleTrans.M)
  return _internal_m();
}
inline void logicleTrans::_internal_set_m(float value) {
  _has_bits_[0] |= 0x00000004u;
  m_ = value;
}
inline void logicleTrans::set_m(float value) {
  _internal_set_m(value);
  // @@protoc_insertion_point(field_set:pb.logicleTrans.M)
}

// optional float A = 4;
inline bool logicleTrans::_internal_has_a() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool logicleTrans::has_a() const {
  return _internal_has_a();
}
inline void logicleTrans::clear_a() {
  a_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float logicleTrans::_internal_a() const {
  return a_;
}
inline float logicleTrans::a() const {
  // @@protoc_insertion_point(field_get:pb.logicleTrans.A)
  return _internal_a();
}
inline void logicleTrans::_internal_set_a(float value) {
  _has_bits_[0] |= 0x00000008u;
  a_ = value;
}
inline void logicleTrans::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:pb.logicleTrans.A)
}

// optional float bins = 5;
inline bool logicleTrans::_internal_has_bins() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool logicleTrans::has_bins() const {
  return _internal_has_bins();
}
inline void logicleTrans::clear_bins() {
  bins_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float logicleTrans::_internal_bins() const {
  return bins_;
}
inline float logicleTrans::bins() const {
  // @@protoc_insertion_point(field_get:pb.logicleTrans.bins)
  return _internal_bins();
}
inline void logicleTrans::_internal_set_bins(float value) {
  _has_bits_[0] |= 0x00000010u;
  bins_ = value;
}
inline void logicleTrans::set_bins(float value) {
  _internal_set_bins(value);
  // @@protoc_insertion_point(field_set:pb.logicleTrans.bins)
}

// optional bool isGml2 = 6;
inline bool logicleTrans::_internal_has_isgml2() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool logicleTrans::has_isgml2() const {
  return _internal_has_isgml2();
}
inline void logicleTrans::clear_isgml2() {
  isgml2_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool logicleTrans::_internal_isgml2() const {
  return isgml2_;
}
inline bool logicleTrans::isgml2() const {
  // @@protoc_insertion_point(field_get:pb.logicleTrans.isGml2)
  return _internal_isgml2();
}
inline void logicleTrans::_internal_set_isgml2(bool value) {
  _has_bits_[0] |= 0x00000020u;
  isgml2_ = value;
}
inline void logicleTrans::set_isgml2(bool value) {
  _internal_set_isgml2(value);
  // @@protoc_insertion_point(field_set:pb.logicleTrans.isGml2)
}

// optional bool isInverse = 7;
inline bool logicleTrans::_internal_has_isinverse() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool logicleTrans::has_isinverse() const {
  return _internal_has_isinverse();
}
inline void logicleTrans::clear_isinverse() {
  isinverse_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool logicleTrans::_internal_isinverse() const {
  return isinverse_;
}
inline bool logicleTrans::isinverse() const {
  // @@protoc_insertion_point(field_get:pb.logicleTrans.isInverse)
  return _internal_isinverse();
}
inline void logicleTrans::_internal_set_isinverse(bool value) {
  _has_bits_[0] |= 0x00000040u;
  isinverse_ = value;
}
inline void logicleTrans::set_isinverse(bool value) {
  _internal_set_isinverse(value);
  // @@protoc_insertion_point(field_set:pb.logicleTrans.isInverse)
}

// -------------------------------------------------------------------

// transformation

// optional .pb.calibrationTable calTbl = 1;
inline bool transformation::_internal_has_caltbl() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || caltbl_ != nullptr);
  return value;
}
inline bool transformation::has_caltbl() const {
  return _internal_has_caltbl();
}
inline void transformation::clear_caltbl() {
  if (caltbl_ != nullptr) caltbl_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pb::calibrationTable& transformation::_internal_caltbl() const {
  const ::pb::calibrationTable* p = caltbl_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::calibrationTable*>(
      &::pb::_calibrationTable_default_instance_);
}
inline const ::pb::calibrationTable& transformation::caltbl() const {
  // @@protoc_insertion_point(field_get:pb.transformation.calTbl)
  return _internal_caltbl();
}
inline void transformation::unsafe_arena_set_allocated_caltbl(
    ::pb::calibrationTable* caltbl) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caltbl_);
  }
  caltbl_ = caltbl;
  if (caltbl) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.transformation.calTbl)
}
inline ::pb::calibrationTable* transformation::release_caltbl() {
  _has_bits_[0] &= ~0x00000004u;
  ::pb::calibrationTable* temp = caltbl_;
  caltbl_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::calibrationTable* transformation::unsafe_arena_release_caltbl() {
  // @@protoc_insertion_point(field_release:pb.transformation.calTbl)
  _has_bits_[0] &= ~0x00000004u;
  ::pb::calibrationTable* temp = caltbl_;
  caltbl_ = nullptr;
  return temp;
}
inline ::pb::calibrationTable* transformation::_internal_mutable_caltbl() {
  _has_bits_[0] |= 0x00000004u;
  if (caltbl_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::calibrationTable>(GetArena());
    caltbl_ = p;
  }
  return caltbl_;
}
inline ::pb::calibrationTable* transformation::mutable_caltbl() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.calTbl)
  return _internal_mutable_caltbl();
}
inline void transformation::set_allocated_caltbl(::pb::calibrationTable* caltbl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete caltbl_;
  }
  if (caltbl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(caltbl);
    if (message_arena != submessage_arena) {
      caltbl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caltbl, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  caltbl_ = caltbl;
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.calTbl)
}

// optional bool isGateOnly = 2;
inline bool transformation::_internal_has_isgateonly() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool transformation::has_isgateonly() const {
  return _internal_has_isgateonly();
}
inline void transformation::clear_isgateonly() {
  isgateonly_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool transformation::_internal_isgateonly() const {
  return isgateonly_;
}
inline bool transformation::isgateonly() const {
  // @@protoc_insertion_point(field_get:pb.transformation.isGateOnly)
  return _internal_isgateonly();
}
inline void transformation::_internal_set_isgateonly(bool value) {
  _has_bits_[0] |= 0x00000800u;
  isgateonly_ = value;
}
inline void transformation::set_isgateonly(bool value) {
  _internal_set_isgateonly(value);
  // @@protoc_insertion_point(field_set:pb.transformation.isGateOnly)
}

// optional string name = 4;
inline bool transformation::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool transformation::has_name() const {
  return _internal_has_name();
}
inline void transformation::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& transformation::name() const {
  // @@protoc_insertion_point(field_get:pb.transformation.name)
  return _internal_name();
}
inline void transformation::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pb.transformation.name)
}
inline std::string* transformation::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.name)
  return _internal_mutable_name();
}
inline const std::string& transformation::_internal_name() const {
  return name_.Get();
}
inline void transformation::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void transformation::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.transformation.name)
}
inline void transformation::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.transformation.name)
}
inline void transformation::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.transformation.name)
}
inline std::string* transformation::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* transformation::release_name() {
  // @@protoc_insertion_point(field_release:pb.transformation.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void transformation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.name)
}

// optional string channel = 5;
inline bool transformation::_internal_has_channel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool transformation::has_channel() const {
  return _internal_has_channel();
}
inline void transformation::clear_channel() {
  channel_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& transformation::channel() const {
  // @@protoc_insertion_point(field_get:pb.transformation.channel)
  return _internal_channel();
}
inline void transformation::set_channel(const std::string& value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:pb.transformation.channel)
}
inline std::string* transformation::mutable_channel() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.channel)
  return _internal_mutable_channel();
}
inline const std::string& transformation::_internal_channel() const {
  return channel_.Get();
}
inline void transformation::_internal_set_channel(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  channel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void transformation::set_channel(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  channel_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.transformation.channel)
}
inline void transformation::set_channel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  channel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.transformation.channel)
}
inline void transformation::set_channel(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  channel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.transformation.channel)
}
inline std::string* transformation::_internal_mutable_channel() {
  _has_bits_[0] |= 0x00000002u;
  return channel_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* transformation::release_channel() {
  // @@protoc_insertion_point(field_release:pb.transformation.channel)
  if (!_internal_has_channel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return channel_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void transformation::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  channel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.channel)
}

// optional bool isComputed = 6;
inline bool transformation::_internal_has_iscomputed() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool transformation::has_iscomputed() const {
  return _internal_has_iscomputed();
}
inline void transformation::clear_iscomputed() {
  iscomputed_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool transformation::_internal_iscomputed() const {
  return iscomputed_;
}
inline bool transformation::iscomputed() const {
  // @@protoc_insertion_point(field_get:pb.transformation.isComputed)
  return _internal_iscomputed();
}
inline void transformation::_internal_set_iscomputed(bool value) {
  _has_bits_[0] |= 0x00001000u;
  iscomputed_ = value;
}
inline void transformation::set_iscomputed(bool value) {
  _internal_set_iscomputed(value);
  // @@protoc_insertion_point(field_set:pb.transformation.isComputed)
}

// optional uint32 type = 12;
inline bool transformation::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool transformation::has_type() const {
  return _internal_has_type();
}
inline void transformation::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 transformation::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 transformation::type() const {
  // @@protoc_insertion_point(field_get:pb.transformation.type)
  return _internal_type();
}
inline void transformation::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  type_ = value;
}
inline void transformation::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.transformation.type)
}

// optional .pb.TRANS_TYPE trans_type = 3;
inline bool transformation::_internal_has_trans_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool transformation::has_trans_type() const {
  return _internal_has_trans_type();
}
inline void transformation::clear_trans_type() {
  trans_type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::pb::TRANS_TYPE transformation::_internal_trans_type() const {
  return static_cast< ::pb::TRANS_TYPE >(trans_type_);
}
inline ::pb::TRANS_TYPE transformation::trans_type() const {
  // @@protoc_insertion_point(field_get:pb.transformation.trans_type)
  return _internal_trans_type();
}
inline void transformation::_internal_set_trans_type(::pb::TRANS_TYPE value) {
  assert(::pb::TRANS_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  trans_type_ = value;
}
inline void transformation::set_trans_type(::pb::TRANS_TYPE value) {
  _internal_set_trans_type(value);
  // @@protoc_insertion_point(field_set:pb.transformation.trans_type)
}

// optional .pb.biexpTrans bt = 7;
inline bool transformation::_internal_has_bt() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || bt_ != nullptr);
  return value;
}
inline bool transformation::has_bt() const {
  return _internal_has_bt();
}
inline void transformation::clear_bt() {
  if (bt_ != nullptr) bt_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pb::biexpTrans& transformation::_internal_bt() const {
  const ::pb::biexpTrans* p = bt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::biexpTrans*>(
      &::pb::_biexpTrans_default_instance_);
}
inline const ::pb::biexpTrans& transformation::bt() const {
  // @@protoc_insertion_point(field_get:pb.transformation.bt)
  return _internal_bt();
}
inline void transformation::unsafe_arena_set_allocated_bt(
    ::pb::biexpTrans* bt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bt_);
  }
  bt_ = bt;
  if (bt) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.transformation.bt)
}
inline ::pb::biexpTrans* transformation::release_bt() {
  _has_bits_[0] &= ~0x00000008u;
  ::pb::biexpTrans* temp = bt_;
  bt_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::biexpTrans* transformation::unsafe_arena_release_bt() {
  // @@protoc_insertion_point(field_release:pb.transformation.bt)
  _has_bits_[0] &= ~0x00000008u;
  ::pb::biexpTrans* temp = bt_;
  bt_ = nullptr;
  return temp;
}
inline ::pb::biexpTrans* transformation::_internal_mutable_bt() {
  _has_bits_[0] |= 0x00000008u;
  if (bt_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::biexpTrans>(GetArena());
    bt_ = p;
  }
  return bt_;
}
inline ::pb::biexpTrans* transformation::mutable_bt() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.bt)
  return _internal_mutable_bt();
}
inline void transformation::set_allocated_bt(::pb::biexpTrans* bt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bt_;
  }
  if (bt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bt);
    if (message_arena != submessage_arena) {
      bt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  bt_ = bt;
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.bt)
}

// optional .pb.logTrans lt = 8;
inline bool transformation::_internal_has_lt() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || lt_ != nullptr);
  return value;
}
inline bool transformation::has_lt() const {
  return _internal_has_lt();
}
inline void transformation::clear_lt() {
  if (lt_ != nullptr) lt_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::pb::logTrans& transformation::_internal_lt() const {
  const ::pb::logTrans* p = lt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::logTrans*>(
      &::pb::_logTrans_default_instance_);
}
inline const ::pb::logTrans& transformation::lt() const {
  // @@protoc_insertion_point(field_get:pb.transformation.lt)
  return _internal_lt();
}
inline void transformation::unsafe_arena_set_allocated_lt(
    ::pb::logTrans* lt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lt_);
  }
  lt_ = lt;
  if (lt) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.transformation.lt)
}
inline ::pb::logTrans* transformation::release_lt() {
  _has_bits_[0] &= ~0x00000010u;
  ::pb::logTrans* temp = lt_;
  lt_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::logTrans* transformation::unsafe_arena_release_lt() {
  // @@protoc_insertion_point(field_release:pb.transformation.lt)
  _has_bits_[0] &= ~0x00000010u;
  ::pb::logTrans* temp = lt_;
  lt_ = nullptr;
  return temp;
}
inline ::pb::logTrans* transformation::_internal_mutable_lt() {
  _has_bits_[0] |= 0x00000010u;
  if (lt_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::logTrans>(GetArena());
    lt_ = p;
  }
  return lt_;
}
inline ::pb::logTrans* transformation::mutable_lt() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.lt)
  return _internal_mutable_lt();
}
inline void transformation::set_allocated_lt(::pb::logTrans* lt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lt_;
  }
  if (lt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lt);
    if (message_arena != submessage_arena) {
      lt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  lt_ = lt;
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.lt)
}

// optional .pb.flinTrans flt = 9;
inline bool transformation::_internal_has_flt() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || flt_ != nullptr);
  return value;
}
inline bool transformation::has_flt() const {
  return _internal_has_flt();
}
inline void transformation::clear_flt() {
  if (flt_ != nullptr) flt_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::pb::flinTrans& transformation::_internal_flt() const {
  const ::pb::flinTrans* p = flt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::flinTrans*>(
      &::pb::_flinTrans_default_instance_);
}
inline const ::pb::flinTrans& transformation::flt() const {
  // @@protoc_insertion_point(field_get:pb.transformation.flt)
  return _internal_flt();
}
inline void transformation::unsafe_arena_set_allocated_flt(
    ::pb::flinTrans* flt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flt_);
  }
  flt_ = flt;
  if (flt) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.transformation.flt)
}
inline ::pb::flinTrans* transformation::release_flt() {
  _has_bits_[0] &= ~0x00000020u;
  ::pb::flinTrans* temp = flt_;
  flt_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::flinTrans* transformation::unsafe_arena_release_flt() {
  // @@protoc_insertion_point(field_release:pb.transformation.flt)
  _has_bits_[0] &= ~0x00000020u;
  ::pb::flinTrans* temp = flt_;
  flt_ = nullptr;
  return temp;
}
inline ::pb::flinTrans* transformation::_internal_mutable_flt() {
  _has_bits_[0] |= 0x00000020u;
  if (flt_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::flinTrans>(GetArena());
    flt_ = p;
  }
  return flt_;
}
inline ::pb::flinTrans* transformation::mutable_flt() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.flt)
  return _internal_mutable_flt();
}
inline void transformation::set_allocated_flt(::pb::flinTrans* flt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete flt_;
  }
  if (flt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(flt);
    if (message_arena != submessage_arena) {
      flt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  flt_ = flt;
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.flt)
}

// optional .pb.scaleTrans st = 10;
inline bool transformation::_internal_has_st() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || st_ != nullptr);
  return value;
}
inline bool transformation::has_st() const {
  return _internal_has_st();
}
inline void transformation::clear_st() {
  if (st_ != nullptr) st_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::pb::scaleTrans& transformation::_internal_st() const {
  const ::pb::scaleTrans* p = st_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::scaleTrans*>(
      &::pb::_scaleTrans_default_instance_);
}
inline const ::pb::scaleTrans& transformation::st() const {
  // @@protoc_insertion_point(field_get:pb.transformation.st)
  return _internal_st();
}
inline void transformation::unsafe_arena_set_allocated_st(
    ::pb::scaleTrans* st) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(st_);
  }
  st_ = st;
  if (st) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.transformation.st)
}
inline ::pb::scaleTrans* transformation::release_st() {
  _has_bits_[0] &= ~0x00000040u;
  ::pb::scaleTrans* temp = st_;
  st_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::scaleTrans* transformation::unsafe_arena_release_st() {
  // @@protoc_insertion_point(field_release:pb.transformation.st)
  _has_bits_[0] &= ~0x00000040u;
  ::pb::scaleTrans* temp = st_;
  st_ = nullptr;
  return temp;
}
inline ::pb::scaleTrans* transformation::_internal_mutable_st() {
  _has_bits_[0] |= 0x00000040u;
  if (st_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::scaleTrans>(GetArena());
    st_ = p;
  }
  return st_;
}
inline ::pb::scaleTrans* transformation::mutable_st() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.st)
  return _internal_mutable_st();
}
inline void transformation::set_allocated_st(::pb::scaleTrans* st) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete st_;
  }
  if (st) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(st);
    if (message_arena != submessage_arena) {
      st = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, st, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  st_ = st;
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.st)
}

// optional .pb.fasinhTrans ft = 11;
inline bool transformation::_internal_has_ft() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || ft_ != nullptr);
  return value;
}
inline bool transformation::has_ft() const {
  return _internal_has_ft();
}
inline void transformation::clear_ft() {
  if (ft_ != nullptr) ft_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::pb::fasinhTrans& transformation::_internal_ft() const {
  const ::pb::fasinhTrans* p = ft_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::fasinhTrans*>(
      &::pb::_fasinhTrans_default_instance_);
}
inline const ::pb::fasinhTrans& transformation::ft() const {
  // @@protoc_insertion_point(field_get:pb.transformation.ft)
  return _internal_ft();
}
inline void transformation::unsafe_arena_set_allocated_ft(
    ::pb::fasinhTrans* ft) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ft_);
  }
  ft_ = ft;
  if (ft) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.transformation.ft)
}
inline ::pb::fasinhTrans* transformation::release_ft() {
  _has_bits_[0] &= ~0x00000080u;
  ::pb::fasinhTrans* temp = ft_;
  ft_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::fasinhTrans* transformation::unsafe_arena_release_ft() {
  // @@protoc_insertion_point(field_release:pb.transformation.ft)
  _has_bits_[0] &= ~0x00000080u;
  ::pb::fasinhTrans* temp = ft_;
  ft_ = nullptr;
  return temp;
}
inline ::pb::fasinhTrans* transformation::_internal_mutable_ft() {
  _has_bits_[0] |= 0x00000080u;
  if (ft_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::fasinhTrans>(GetArena());
    ft_ = p;
  }
  return ft_;
}
inline ::pb::fasinhTrans* transformation::mutable_ft() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.ft)
  return _internal_mutable_ft();
}
inline void transformation::set_allocated_ft(::pb::fasinhTrans* ft) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ft_;
  }
  if (ft) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ft);
    if (message_arena != submessage_arena) {
      ft = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ft, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  ft_ = ft;
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.ft)
}

// optional .pb.logicleTrans lgt = 13;
inline bool transformation::_internal_has_lgt() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || lgt_ != nullptr);
  return value;
}
inline bool transformation::has_lgt() const {
  return _internal_has_lgt();
}
inline void transformation::clear_lgt() {
  if (lgt_ != nullptr) lgt_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::pb::logicleTrans& transformation::_internal_lgt() const {
  const ::pb::logicleTrans* p = lgt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::logicleTrans*>(
      &::pb::_logicleTrans_default_instance_);
}
inline const ::pb::logicleTrans& transformation::lgt() const {
  // @@protoc_insertion_point(field_get:pb.transformation.lgt)
  return _internal_lgt();
}
inline void transformation::unsafe_arena_set_allocated_lgt(
    ::pb::logicleTrans* lgt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lgt_);
  }
  lgt_ = lgt;
  if (lgt) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.transformation.lgt)
}
inline ::pb::logicleTrans* transformation::release_lgt() {
  _has_bits_[0] &= ~0x00000100u;
  ::pb::logicleTrans* temp = lgt_;
  lgt_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::logicleTrans* transformation::unsafe_arena_release_lgt() {
  // @@protoc_insertion_point(field_release:pb.transformation.lgt)
  _has_bits_[0] &= ~0x00000100u;
  ::pb::logicleTrans* temp = lgt_;
  lgt_ = nullptr;
  return temp;
}
inline ::pb::logicleTrans* transformation::_internal_mutable_lgt() {
  _has_bits_[0] |= 0x00000100u;
  if (lgt_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::logicleTrans>(GetArena());
    lgt_ = p;
  }
  return lgt_;
}
inline ::pb::logicleTrans* transformation::mutable_lgt() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.lgt)
  return _internal_mutable_lgt();
}
inline void transformation::set_allocated_lgt(::pb::logicleTrans* lgt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lgt_;
  }
  if (lgt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lgt);
    if (message_arena != submessage_arena) {
      lgt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lgt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  lgt_ = lgt;
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.lgt)
}

// optional .pb.logGML2Trans lgml2t = 14;
inline bool transformation::_internal_has_lgml2t() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || lgml2t_ != nullptr);
  return value;
}
inline bool transformation::has_lgml2t() const {
  return _internal_has_lgml2t();
}
inline void transformation::clear_lgml2t() {
  if (lgml2t_ != nullptr) lgml2t_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::pb::logGML2Trans& transformation::_internal_lgml2t() const {
  const ::pb::logGML2Trans* p = lgml2t_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::logGML2Trans*>(
      &::pb::_logGML2Trans_default_instance_);
}
inline const ::pb::logGML2Trans& transformation::lgml2t() const {
  // @@protoc_insertion_point(field_get:pb.transformation.lgml2t)
  return _internal_lgml2t();
}
inline void transformation::unsafe_arena_set_allocated_lgml2t(
    ::pb::logGML2Trans* lgml2t) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lgml2t_);
  }
  lgml2t_ = lgml2t;
  if (lgml2t) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.transformation.lgml2t)
}
inline ::pb::logGML2Trans* transformation::release_lgml2t() {
  _has_bits_[0] &= ~0x00000200u;
  ::pb::logGML2Trans* temp = lgml2t_;
  lgml2t_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::logGML2Trans* transformation::unsafe_arena_release_lgml2t() {
  // @@protoc_insertion_point(field_release:pb.transformation.lgml2t)
  _has_bits_[0] &= ~0x00000200u;
  ::pb::logGML2Trans* temp = lgml2t_;
  lgml2t_ = nullptr;
  return temp;
}
inline ::pb::logGML2Trans* transformation::_internal_mutable_lgml2t() {
  _has_bits_[0] |= 0x00000200u;
  if (lgml2t_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::logGML2Trans>(GetArena());
    lgml2t_ = p;
  }
  return lgml2t_;
}
inline ::pb::logGML2Trans* transformation::mutable_lgml2t() {
  // @@protoc_insertion_point(field_mutable:pb.transformation.lgml2t)
  return _internal_mutable_lgml2t();
}
inline void transformation::set_allocated_lgml2t(::pb::logGML2Trans* lgml2t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lgml2t_;
  }
  if (lgml2t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lgml2t);
    if (message_arena != submessage_arena) {
      lgml2t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lgml2t, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  lgml2t_ = lgml2t;
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.lgml2t)
}

// -------------------------------------------------------------------

// trans_pair

// required string name = 1;
inline bool trans_pair::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool trans_pair::has_name() const {
  return _internal_has_name();
}
inline void trans_pair::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& trans_pair::name() const {
  // @@protoc_insertion_point(field_get:pb.trans_pair.name)
  return _internal_name();
}
inline void trans_pair::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pb.trans_pair.name)
}
inline std::string* trans_pair::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pb.trans_pair.name)
  return _internal_mutable_name();
}
inline const std::string& trans_pair::_internal_name() const {
  return name_.Get();
}
inline void trans_pair::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void trans_pair::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.trans_pair.name)
}
inline void trans_pair::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.trans_pair.name)
}
inline void trans_pair::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.trans_pair.name)
}
inline std::string* trans_pair::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* trans_pair::release_name() {
  // @@protoc_insertion_point(field_release:pb.trans_pair.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void trans_pair::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.trans_pair.name)
}

// optional uint64 trans_address = 2;
inline bool trans_pair::_internal_has_trans_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool trans_pair::has_trans_address() const {
  return _internal_has_trans_address();
}
inline void trans_pair::clear_trans_address() {
  trans_address_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 trans_pair::_internal_trans_address() const {
  return trans_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 trans_pair::trans_address() const {
  // @@protoc_insertion_point(field_get:pb.trans_pair.trans_address)
  return _internal_trans_address();
}
inline void trans_pair::_internal_set_trans_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  trans_address_ = value;
}
inline void trans_pair::set_trans_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_trans_address(value);
  // @@protoc_insertion_point(field_set:pb.trans_pair.trans_address)
}

// optional .pb.transformation trans = 3;
inline bool trans_pair::_internal_has_trans() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || trans_ != nullptr);
  return value;
}
inline bool trans_pair::has_trans() const {
  return _internal_has_trans();
}
inline void trans_pair::clear_trans() {
  if (trans_ != nullptr) trans_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pb::transformation& trans_pair::_internal_trans() const {
  const ::pb::transformation* p = trans_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::transformation*>(
      &::pb::_transformation_default_instance_);
}
inline const ::pb::transformation& trans_pair::trans() const {
  // @@protoc_insertion_point(field_get:pb.trans_pair.trans)
  return _internal_trans();
}
inline void trans_pair::unsafe_arena_set_allocated_trans(
    ::pb::transformation* trans) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trans_);
  }
  trans_ = trans;
  if (trans) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.trans_pair.trans)
}
inline ::pb::transformation* trans_pair::release_trans() {
  _has_bits_[0] &= ~0x00000002u;
  ::pb::transformation* temp = trans_;
  trans_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::transformation* trans_pair::unsafe_arena_release_trans() {
  // @@protoc_insertion_point(field_release:pb.trans_pair.trans)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::transformation* temp = trans_;
  trans_ = nullptr;
  return temp;
}
inline ::pb::transformation* trans_pair::_internal_mutable_trans() {
  _has_bits_[0] |= 0x00000002u;
  if (trans_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::transformation>(GetArena());
    trans_ = p;
  }
  return trans_;
}
inline ::pb::transformation* trans_pair::mutable_trans() {
  // @@protoc_insertion_point(field_mutable:pb.trans_pair.trans)
  return _internal_mutable_trans();
}
inline void trans_pair::set_allocated_trans(::pb::transformation* trans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete trans_;
  }
  if (trans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(trans);
    if (message_arena != submessage_arena) {
      trans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trans, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  trans_ = trans;
  // @@protoc_insertion_point(field_set_allocated:pb.trans_pair.trans)
}

// -------------------------------------------------------------------

// trans_local

// repeated .pb.trans_pair tp = 1;
inline int trans_local::_internal_tp_size() const {
  return tp_.size();
}
inline int trans_local::tp_size() const {
  return _internal_tp_size();
}
inline void trans_local::clear_tp() {
  tp_.Clear();
}
inline ::pb::trans_pair* trans_local::mutable_tp(int index) {
  // @@protoc_insertion_point(field_mutable:pb.trans_local.tp)
  return tp_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_pair >*
trans_local::mutable_tp() {
  // @@protoc_insertion_point(field_mutable_list:pb.trans_local.tp)
  return &tp_;
}
inline const ::pb::trans_pair& trans_local::_internal_tp(int index) const {
  return tp_.Get(index);
}
inline const ::pb::trans_pair& trans_local::tp(int index) const {
  // @@protoc_insertion_point(field_get:pb.trans_local.tp)
  return _internal_tp(index);
}
inline ::pb::trans_pair* trans_local::_internal_add_tp() {
  return tp_.Add();
}
inline ::pb::trans_pair* trans_local::add_tp() {
  // @@protoc_insertion_point(field_add:pb.trans_local.tp)
  return _internal_add_tp();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_pair >&
trans_local::tp() const {
  // @@protoc_insertion_point(field_list:pb.trans_local.tp)
  return tp_;
}

// optional string groupName = 2;
inline bool trans_local::_internal_has_groupname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool trans_local::has_groupname() const {
  return _internal_has_groupname();
}
inline void trans_local::clear_groupname() {
  groupname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& trans_local::groupname() const {
  // @@protoc_insertion_point(field_get:pb.trans_local.groupName)
  return _internal_groupname();
}
inline void trans_local::set_groupname(const std::string& value) {
  _internal_set_groupname(value);
  // @@protoc_insertion_point(field_set:pb.trans_local.groupName)
}
inline std::string* trans_local::mutable_groupname() {
  // @@protoc_insertion_point(field_mutable:pb.trans_local.groupName)
  return _internal_mutable_groupname();
}
inline const std::string& trans_local::_internal_groupname() const {
  return groupname_.Get();
}
inline void trans_local::_internal_set_groupname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  groupname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void trans_local::set_groupname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  groupname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.trans_local.groupName)
}
inline void trans_local::set_groupname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  groupname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.trans_local.groupName)
}
inline void trans_local::set_groupname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  groupname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.trans_local.groupName)
}
inline std::string* trans_local::_internal_mutable_groupname() {
  _has_bits_[0] |= 0x00000001u;
  return groupname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* trans_local::release_groupname() {
  // @@protoc_insertion_point(field_release:pb.trans_local.groupName)
  if (!_internal_has_groupname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return groupname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void trans_local::set_allocated_groupname(std::string* groupname) {
  if (groupname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  groupname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.trans_local.groupName)
}

// repeated uint32 sampleIDs = 3 [packed = true];
inline int trans_local::_internal_sampleids_size() const {
  return sampleids_.size();
}
inline int trans_local::sampleids_size() const {
  return _internal_sampleids_size();
}
inline void trans_local::clear_sampleids() {
  sampleids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 trans_local::_internal_sampleids(int index) const {
  return sampleids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 trans_local::sampleids(int index) const {
  // @@protoc_insertion_point(field_get:pb.trans_local.sampleIDs)
  return _internal_sampleids(index);
}
inline void trans_local::set_sampleids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  sampleids_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.trans_local.sampleIDs)
}
inline void trans_local::_internal_add_sampleids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  sampleids_.Add(value);
}
inline void trans_local::add_sampleids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_sampleids(value);
  // @@protoc_insertion_point(field_add:pb.trans_local.sampleIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
trans_local::_internal_sampleids() const {
  return sampleids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
trans_local::sampleids() const {
  // @@protoc_insertion_point(field_list:pb.trans_local.sampleIDs)
  return _internal_sampleids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
trans_local::_internal_mutable_sampleids() {
  return &sampleids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
trans_local::mutable_sampleids() {
  // @@protoc_insertion_point(field_mutable_list:pb.trans_local.sampleIDs)
  return _internal_mutable_sampleids();
}

// -------------------------------------------------------------------

// POPINDICES

// required uint32 nEvents = 1;
inline bool POPINDICES::_internal_has_nevents() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool POPINDICES::has_nevents() const {
  return _internal_has_nevents();
}
inline void POPINDICES::clear_nevents() {
  nevents_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 POPINDICES::_internal_nevents() const {
  return nevents_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 POPINDICES::nevents() const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.nEvents)
  return _internal_nevents();
}
inline void POPINDICES::_internal_set_nevents(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  nevents_ = value;
}
inline void POPINDICES::set_nevents(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_nevents(value);
  // @@protoc_insertion_point(field_set:pb.POPINDICES.nEvents)
}

// required .pb.ind_type indtype = 2;
inline bool POPINDICES::_internal_has_indtype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool POPINDICES::has_indtype() const {
  return _internal_has_indtype();
}
inline void POPINDICES::clear_indtype() {
  indtype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::pb::ind_type POPINDICES::_internal_indtype() const {
  return static_cast< ::pb::ind_type >(indtype_);
}
inline ::pb::ind_type POPINDICES::indtype() const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.indtype)
  return _internal_indtype();
}
inline void POPINDICES::_internal_set_indtype(::pb::ind_type value) {
  assert(::pb::ind_type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  indtype_ = value;
}
inline void POPINDICES::set_indtype(::pb::ind_type value) {
  _internal_set_indtype(value);
  // @@protoc_insertion_point(field_set:pb.POPINDICES.indtype)
}

// repeated uint32 iInd = 3 [packed = true];
inline int POPINDICES::_internal_iind_size() const {
  return iind_.size();
}
inline int POPINDICES::iind_size() const {
  return _internal_iind_size();
}
inline void POPINDICES::clear_iind() {
  iind_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 POPINDICES::_internal_iind(int index) const {
  return iind_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 POPINDICES::iind(int index) const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.iInd)
  return _internal_iind(index);
}
inline void POPINDICES::set_iind(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  iind_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.POPINDICES.iInd)
}
inline void POPINDICES::_internal_add_iind(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  iind_.Add(value);
}
inline void POPINDICES::add_iind(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_iind(value);
  // @@protoc_insertion_point(field_add:pb.POPINDICES.iInd)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
POPINDICES::_internal_iind() const {
  return iind_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
POPINDICES::iind() const {
  // @@protoc_insertion_point(field_list:pb.POPINDICES.iInd)
  return _internal_iind();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
POPINDICES::_internal_mutable_iind() {
  return &iind_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
POPINDICES::mutable_iind() {
  // @@protoc_insertion_point(field_mutable_list:pb.POPINDICES.iInd)
  return _internal_mutable_iind();
}

// optional bytes bInd = 4;
inline bool POPINDICES::_internal_has_bind() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool POPINDICES::has_bind() const {
  return _internal_has_bind();
}
inline void POPINDICES::clear_bind() {
  bind_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& POPINDICES::bind() const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.bInd)
  return _internal_bind();
}
inline void POPINDICES::set_bind(const std::string& value) {
  _internal_set_bind(value);
  // @@protoc_insertion_point(field_set:pb.POPINDICES.bInd)
}
inline std::string* POPINDICES::mutable_bind() {
  // @@protoc_insertion_point(field_mutable:pb.POPINDICES.bInd)
  return _internal_mutable_bind();
}
inline const std::string& POPINDICES::_internal_bind() const {
  return bind_.Get();
}
inline void POPINDICES::_internal_set_bind(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bind_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void POPINDICES::set_bind(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  bind_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.POPINDICES.bInd)
}
inline void POPINDICES::set_bind(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  bind_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.POPINDICES.bInd)
}
inline void POPINDICES::set_bind(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  bind_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.POPINDICES.bInd)
}
inline std::string* POPINDICES::_internal_mutable_bind() {
  _has_bits_[0] |= 0x00000001u;
  return bind_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* POPINDICES::release_bind() {
  // @@protoc_insertion_point(field_release:pb.POPINDICES.bInd)
  if (!_internal_has_bind()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return bind_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void POPINDICES::set_allocated_bind(std::string* bind) {
  if (bind != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bind_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bind,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.POPINDICES.bInd)
}

// -------------------------------------------------------------------

// nodeProperties

// required string thisName = 1;
inline bool nodeProperties::_internal_has_thisname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool nodeProperties::has_thisname() const {
  return _internal_has_thisname();
}
inline void nodeProperties::clear_thisname() {
  thisname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& nodeProperties::thisname() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.thisName)
  return _internal_thisname();
}
inline void nodeProperties::set_thisname(const std::string& value) {
  _internal_set_thisname(value);
  // @@protoc_insertion_point(field_set:pb.nodeProperties.thisName)
}
inline std::string* nodeProperties::mutable_thisname() {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.thisName)
  return _internal_mutable_thisname();
}
inline const std::string& nodeProperties::_internal_thisname() const {
  return thisname_.Get();
}
inline void nodeProperties::_internal_set_thisname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  thisname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void nodeProperties::set_thisname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  thisname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.nodeProperties.thisName)
}
inline void nodeProperties::set_thisname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  thisname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.nodeProperties.thisName)
}
inline void nodeProperties::set_thisname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  thisname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.nodeProperties.thisName)
}
inline std::string* nodeProperties::_internal_mutable_thisname() {
  _has_bits_[0] |= 0x00000001u;
  return thisname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* nodeProperties::release_thisname() {
  // @@protoc_insertion_point(field_release:pb.nodeProperties.thisName)
  if (!_internal_has_thisname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return thisname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void nodeProperties::set_allocated_thisname(std::string* thisname) {
  if (thisname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  thisname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thisname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.thisName)
}

// repeated .pb.POPSTATS fjStats = 2;
inline int nodeProperties::_internal_fjstats_size() const {
  return fjstats_.size();
}
inline int nodeProperties::fjstats_size() const {
  return _internal_fjstats_size();
}
inline void nodeProperties::clear_fjstats() {
  fjstats_.Clear();
}
inline ::pb::POPSTATS* nodeProperties::mutable_fjstats(int index) {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.fjStats)
  return fjstats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS >*
nodeProperties::mutable_fjstats() {
  // @@protoc_insertion_point(field_mutable_list:pb.nodeProperties.fjStats)
  return &fjstats_;
}
inline const ::pb::POPSTATS& nodeProperties::_internal_fjstats(int index) const {
  return fjstats_.Get(index);
}
inline const ::pb::POPSTATS& nodeProperties::fjstats(int index) const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.fjStats)
  return _internal_fjstats(index);
}
inline ::pb::POPSTATS* nodeProperties::_internal_add_fjstats() {
  return fjstats_.Add();
}
inline ::pb::POPSTATS* nodeProperties::add_fjstats() {
  // @@protoc_insertion_point(field_add:pb.nodeProperties.fjStats)
  return _internal_add_fjstats();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS >&
nodeProperties::fjstats() const {
  // @@protoc_insertion_point(field_list:pb.nodeProperties.fjStats)
  return fjstats_;
}

// repeated .pb.POPSTATS fcStats = 3;
inline int nodeProperties::_internal_fcstats_size() const {
  return fcstats_.size();
}
inline int nodeProperties::fcstats_size() const {
  return _internal_fcstats_size();
}
inline void nodeProperties::clear_fcstats() {
  fcstats_.Clear();
}
inline ::pb::POPSTATS* nodeProperties::mutable_fcstats(int index) {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.fcStats)
  return fcstats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS >*
nodeProperties::mutable_fcstats() {
  // @@protoc_insertion_point(field_mutable_list:pb.nodeProperties.fcStats)
  return &fcstats_;
}
inline const ::pb::POPSTATS& nodeProperties::_internal_fcstats(int index) const {
  return fcstats_.Get(index);
}
inline const ::pb::POPSTATS& nodeProperties::fcstats(int index) const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.fcStats)
  return _internal_fcstats(index);
}
inline ::pb::POPSTATS* nodeProperties::_internal_add_fcstats() {
  return fcstats_.Add();
}
inline ::pb::POPSTATS* nodeProperties::add_fcstats() {
  // @@protoc_insertion_point(field_add:pb.nodeProperties.fcStats)
  return _internal_add_fcstats();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::POPSTATS >&
nodeProperties::fcstats() const {
  // @@protoc_insertion_point(field_list:pb.nodeProperties.fcStats)
  return fcstats_;
}

// required bool hidden = 4;
inline bool nodeProperties::_internal_has_hidden() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool nodeProperties::has_hidden() const {
  return _internal_has_hidden();
}
inline void nodeProperties::clear_hidden() {
  hidden_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool nodeProperties::_internal_hidden() const {
  return hidden_;
}
inline bool nodeProperties::hidden() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.hidden)
  return _internal_hidden();
}
inline void nodeProperties::_internal_set_hidden(bool value) {
  _has_bits_[0] |= 0x00000008u;
  hidden_ = value;
}
inline void nodeProperties::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:pb.nodeProperties.hidden)
}

// optional .pb.POPINDICES indices = 5;
inline bool nodeProperties::_internal_has_indices() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || indices_ != nullptr);
  return value;
}
inline bool nodeProperties::has_indices() const {
  return _internal_has_indices();
}
inline void nodeProperties::clear_indices() {
  if (indices_ != nullptr) indices_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pb::POPINDICES& nodeProperties::_internal_indices() const {
  const ::pb::POPINDICES* p = indices_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::POPINDICES*>(
      &::pb::_POPINDICES_default_instance_);
}
inline const ::pb::POPINDICES& nodeProperties::indices() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.indices)
  return _internal_indices();
}
inline void nodeProperties::unsafe_arena_set_allocated_indices(
    ::pb::POPINDICES* indices) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(indices_);
  }
  indices_ = indices;
  if (indices) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.nodeProperties.indices)
}
inline ::pb::POPINDICES* nodeProperties::release_indices() {
  _has_bits_[0] &= ~0x00000002u;
  ::pb::POPINDICES* temp = indices_;
  indices_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::POPINDICES* nodeProperties::unsafe_arena_release_indices() {
  // @@protoc_insertion_point(field_release:pb.nodeProperties.indices)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::POPINDICES* temp = indices_;
  indices_ = nullptr;
  return temp;
}
inline ::pb::POPINDICES* nodeProperties::_internal_mutable_indices() {
  _has_bits_[0] |= 0x00000002u;
  if (indices_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::POPINDICES>(GetArena());
    indices_ = p;
  }
  return indices_;
}
inline ::pb::POPINDICES* nodeProperties::mutable_indices() {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.indices)
  return _internal_mutable_indices();
}
inline void nodeProperties::set_allocated_indices(::pb::POPINDICES* indices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete indices_;
  }
  if (indices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(indices);
    if (message_arena != submessage_arena) {
      indices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, indices, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  indices_ = indices;
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.indices)
}

// optional .pb.gate thisGate = 6;
inline bool nodeProperties::_internal_has_thisgate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || thisgate_ != nullptr);
  return value;
}
inline bool nodeProperties::has_thisgate() const {
  return _internal_has_thisgate();
}
inline void nodeProperties::clear_thisgate() {
  if (thisgate_ != nullptr) thisgate_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pb::gate& nodeProperties::_internal_thisgate() const {
  const ::pb::gate* p = thisgate_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::gate*>(
      &::pb::_gate_default_instance_);
}
inline const ::pb::gate& nodeProperties::thisgate() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.thisGate)
  return _internal_thisgate();
}
inline void nodeProperties::unsafe_arena_set_allocated_thisgate(
    ::pb::gate* thisgate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thisgate_);
  }
  thisgate_ = thisgate;
  if (thisgate) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.nodeProperties.thisGate)
}
inline ::pb::gate* nodeProperties::release_thisgate() {
  _has_bits_[0] &= ~0x00000004u;
  ::pb::gate* temp = thisgate_;
  thisgate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::gate* nodeProperties::unsafe_arena_release_thisgate() {
  // @@protoc_insertion_point(field_release:pb.nodeProperties.thisGate)
  _has_bits_[0] &= ~0x00000004u;
  ::pb::gate* temp = thisgate_;
  thisgate_ = nullptr;
  return temp;
}
inline ::pb::gate* nodeProperties::_internal_mutable_thisgate() {
  _has_bits_[0] |= 0x00000004u;
  if (thisgate_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::gate>(GetArena());
    thisgate_ = p;
  }
  return thisgate_;
}
inline ::pb::gate* nodeProperties::mutable_thisgate() {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.thisGate)
  return _internal_mutable_thisgate();
}
inline void nodeProperties::set_allocated_thisgate(::pb::gate* thisgate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete thisgate_;
  }
  if (thisgate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(thisgate);
    if (message_arena != submessage_arena) {
      thisgate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thisgate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  thisgate_ = thisgate;
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.thisGate)
}

// -------------------------------------------------------------------

// treeNodes

// required .pb.nodeProperties node = 1;
inline bool treeNodes::_internal_has_node() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || node_ != nullptr);
  return value;
}
inline bool treeNodes::has_node() const {
  return _internal_has_node();
}
inline void treeNodes::clear_node() {
  if (node_ != nullptr) node_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::nodeProperties& treeNodes::_internal_node() const {
  const ::pb::nodeProperties* p = node_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::nodeProperties*>(
      &::pb::_nodeProperties_default_instance_);
}
inline const ::pb::nodeProperties& treeNodes::node() const {
  // @@protoc_insertion_point(field_get:pb.treeNodes.node)
  return _internal_node();
}
inline void treeNodes::unsafe_arena_set_allocated_node(
    ::pb::nodeProperties* node) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.treeNodes.node)
}
inline ::pb::nodeProperties* treeNodes::release_node() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::nodeProperties* temp = node_;
  node_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::nodeProperties* treeNodes::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:pb.treeNodes.node)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::nodeProperties* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::pb::nodeProperties* treeNodes::_internal_mutable_node() {
  _has_bits_[0] |= 0x00000001u;
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::nodeProperties>(GetArena());
    node_ = p;
  }
  return node_;
}
inline ::pb::nodeProperties* treeNodes::mutable_node() {
  // @@protoc_insertion_point(field_mutable:pb.treeNodes.node)
  return _internal_mutable_node();
}
inline void treeNodes::set_allocated_node(::pb::nodeProperties* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:pb.treeNodes.node)
}

// optional uint32 parent = 2;
inline bool treeNodes::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool treeNodes::has_parent() const {
  return _internal_has_parent();
}
inline void treeNodes::clear_parent() {
  parent_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 treeNodes::_internal_parent() const {
  return parent_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 treeNodes::parent() const {
  // @@protoc_insertion_point(field_get:pb.treeNodes.parent)
  return _internal_parent();
}
inline void treeNodes::_internal_set_parent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  parent_ = value;
}
inline void treeNodes::set_parent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_parent(value);
  // @@protoc_insertion_point(field_set:pb.treeNodes.parent)
}

// -------------------------------------------------------------------

// populationTree

// repeated .pb.treeNodes node = 1;
inline int populationTree::_internal_node_size() const {
  return node_.size();
}
inline int populationTree::node_size() const {
  return _internal_node_size();
}
inline void populationTree::clear_node() {
  node_.Clear();
}
inline ::pb::treeNodes* populationTree::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:pb.populationTree.node)
  return node_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::treeNodes >*
populationTree::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:pb.populationTree.node)
  return &node_;
}
inline const ::pb::treeNodes& populationTree::_internal_node(int index) const {
  return node_.Get(index);
}
inline const ::pb::treeNodes& populationTree::node(int index) const {
  // @@protoc_insertion_point(field_get:pb.populationTree.node)
  return _internal_node(index);
}
inline ::pb::treeNodes* populationTree::_internal_add_node() {
  return node_.Add();
}
inline ::pb::treeNodes* populationTree::add_node() {
  // @@protoc_insertion_point(field_add:pb.populationTree.node)
  return _internal_add_node();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::treeNodes >&
populationTree::node() const {
  // @@protoc_insertion_point(field_list:pb.populationTree.node)
  return node_;
}

// -------------------------------------------------------------------

// COMP

// optional string cid = 1;
inline bool COMP::_internal_has_cid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool COMP::has_cid() const {
  return _internal_has_cid();
}
inline void COMP::clear_cid() {
  cid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& COMP::cid() const {
  // @@protoc_insertion_point(field_get:pb.COMP.cid)
  return _internal_cid();
}
inline void COMP::set_cid(const std::string& value) {
  _internal_set_cid(value);
  // @@protoc_insertion_point(field_set:pb.COMP.cid)
}
inline std::string* COMP::mutable_cid() {
  // @@protoc_insertion_point(field_mutable:pb.COMP.cid)
  return _internal_mutable_cid();
}
inline const std::string& COMP::_internal_cid() const {
  return cid_.Get();
}
inline void COMP::_internal_set_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void COMP::set_cid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.COMP.cid)
}
inline void COMP::set_cid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.COMP.cid)
}
inline void COMP::set_cid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.cid)
}
inline std::string* COMP::_internal_mutable_cid() {
  _has_bits_[0] |= 0x00000001u;
  return cid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* COMP::release_cid() {
  // @@protoc_insertion_point(field_release:pb.COMP.cid)
  if (!_internal_has_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void COMP::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.cid)
}

// optional string prefix = 2;
inline bool COMP::_internal_has_prefix() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool COMP::has_prefix() const {
  return _internal_has_prefix();
}
inline void COMP::clear_prefix() {
  prefix_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& COMP::prefix() const {
  // @@protoc_insertion_point(field_get:pb.COMP.prefix)
  return _internal_prefix();
}
inline void COMP::set_prefix(const std::string& value) {
  _internal_set_prefix(value);
  // @@protoc_insertion_point(field_set:pb.COMP.prefix)
}
inline std::string* COMP::mutable_prefix() {
  // @@protoc_insertion_point(field_mutable:pb.COMP.prefix)
  return _internal_mutable_prefix();
}
inline const std::string& COMP::_internal_prefix() const {
  return prefix_.Get();
}
inline void COMP::_internal_set_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void COMP::set_prefix(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  prefix_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.COMP.prefix)
}
inline void COMP::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.COMP.prefix)
}
inline void COMP::set_prefix(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.prefix)
}
inline std::string* COMP::_internal_mutable_prefix() {
  _has_bits_[0] |= 0x00000002u;
  return prefix_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* COMP::release_prefix() {
  // @@protoc_insertion_point(field_release:pb.COMP.prefix)
  if (!_internal_has_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return prefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void COMP::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.prefix)
}

// optional string suffix = 3;
inline bool COMP::_internal_has_suffix() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool COMP::has_suffix() const {
  return _internal_has_suffix();
}
inline void COMP::clear_suffix() {
  suffix_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& COMP::suffix() const {
  // @@protoc_insertion_point(field_get:pb.COMP.suffix)
  return _internal_suffix();
}
inline void COMP::set_suffix(const std::string& value) {
  _internal_set_suffix(value);
  // @@protoc_insertion_point(field_set:pb.COMP.suffix)
}
inline std::string* COMP::mutable_suffix() {
  // @@protoc_insertion_point(field_mutable:pb.COMP.suffix)
  return _internal_mutable_suffix();
}
inline const std::string& COMP::_internal_suffix() const {
  return suffix_.Get();
}
inline void COMP::_internal_set_suffix(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  suffix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void COMP::set_suffix(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  suffix_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.COMP.suffix)
}
inline void COMP::set_suffix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  suffix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.COMP.suffix)
}
inline void COMP::set_suffix(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  suffix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.suffix)
}
inline std::string* COMP::_internal_mutable_suffix() {
  _has_bits_[0] |= 0x00000004u;
  return suffix_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* COMP::release_suffix() {
  // @@protoc_insertion_point(field_release:pb.COMP.suffix)
  if (!_internal_has_suffix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return suffix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void COMP::set_allocated_suffix(std::string* suffix) {
  if (suffix != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  suffix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), suffix,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.suffix)
}

// optional string name = 4;
inline bool COMP::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool COMP::has_name() const {
  return _internal_has_name();
}
inline void COMP::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& COMP::name() const {
  // @@protoc_insertion_point(field_get:pb.COMP.name)
  return _internal_name();
}
inline void COMP::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pb.COMP.name)
}
inline std::string* COMP::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pb.COMP.name)
  return _internal_mutable_name();
}
inline const std::string& COMP::_internal_name() const {
  return name_.Get();
}
inline void COMP::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void COMP::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.COMP.name)
}
inline void COMP::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.COMP.name)
}
inline void COMP::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.name)
}
inline std::string* COMP::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000008u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* COMP::release_name() {
  // @@protoc_insertion_point(field_release:pb.COMP.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void COMP::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.name)
}

// optional string comment = 5;
inline bool COMP::_internal_has_comment() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool COMP::has_comment() const {
  return _internal_has_comment();
}
inline void COMP::clear_comment() {
  comment_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& COMP::comment() const {
  // @@protoc_insertion_point(field_get:pb.COMP.comment)
  return _internal_comment();
}
inline void COMP::set_comment(const std::string& value) {
  _internal_set_comment(value);
  // @@protoc_insertion_point(field_set:pb.COMP.comment)
}
inline std::string* COMP::mutable_comment() {
  // @@protoc_insertion_point(field_mutable:pb.COMP.comment)
  return _internal_mutable_comment();
}
inline const std::string& COMP::_internal_comment() const {
  return comment_.Get();
}
inline void COMP::_internal_set_comment(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  comment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void COMP::set_comment(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  comment_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.COMP.comment)
}
inline void COMP::set_comment(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  comment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.COMP.comment)
}
inline void COMP::set_comment(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  comment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.comment)
}
inline std::string* COMP::_internal_mutable_comment() {
  _has_bits_[0] |= 0x00000010u;
  return comment_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* COMP::release_comment() {
  // @@protoc_insertion_point(field_release:pb.COMP.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return comment_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void COMP::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  comment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.comment)
}

// repeated string marker = 6;
inline int COMP::_internal_marker_size() const {
  return marker_.size();
}
inline int COMP::marker_size() const {
  return _internal_marker_size();
}
inline void COMP::clear_marker() {
  marker_.Clear();
}
inline std::string* COMP::add_marker() {
  // @@protoc_insertion_point(field_add_mutable:pb.COMP.marker)
  return _internal_add_marker();
}
inline const std::string& COMP::_internal_marker(int index) const {
  return marker_.Get(index);
}
inline const std::string& COMP::marker(int index) const {
  // @@protoc_insertion_point(field_get:pb.COMP.marker)
  return _internal_marker(index);
}
inline std::string* COMP::mutable_marker(int index) {
  // @@protoc_insertion_point(field_mutable:pb.COMP.marker)
  return marker_.Mutable(index);
}
inline void COMP::set_marker(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:pb.COMP.marker)
  marker_.Mutable(index)->assign(value);
}
inline void COMP::set_marker(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.COMP.marker)
  marker_.Mutable(index)->assign(std::move(value));
}
inline void COMP::set_marker(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  marker_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.COMP.marker)
}
inline void COMP::set_marker(int index, const char* value, size_t size) {
  marker_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.marker)
}
inline std::string* COMP::_internal_add_marker() {
  return marker_.Add();
}
inline void COMP::add_marker(const std::string& value) {
  marker_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.COMP.marker)
}
inline void COMP::add_marker(std::string&& value) {
  marker_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.COMP.marker)
}
inline void COMP::add_marker(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  marker_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.COMP.marker)
}
inline void COMP::add_marker(const char* value, size_t size) {
  marker_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.COMP.marker)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
COMP::marker() const {
  // @@protoc_insertion_point(field_list:pb.COMP.marker)
  return marker_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
COMP::mutable_marker() {
  // @@protoc_insertion_point(field_mutable_list:pb.COMP.marker)
  return &marker_;
}

// repeated float spillOver = 7;
inline int COMP::_internal_spillover_size() const {
  return spillover_.size();
}
inline int COMP::spillover_size() const {
  return _internal_spillover_size();
}
inline void COMP::clear_spillover() {
  spillover_.Clear();
}
inline float COMP::_internal_spillover(int index) const {
  return spillover_.Get(index);
}
inline float COMP::spillover(int index) const {
  // @@protoc_insertion_point(field_get:pb.COMP.spillOver)
  return _internal_spillover(index);
}
inline void COMP::set_spillover(int index, float value) {
  spillover_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.COMP.spillOver)
}
inline void COMP::_internal_add_spillover(float value) {
  spillover_.Add(value);
}
inline void COMP::add_spillover(float value) {
  _internal_add_spillover(value);
  // @@protoc_insertion_point(field_add:pb.COMP.spillOver)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
COMP::_internal_spillover() const {
  return spillover_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
COMP::spillover() const {
  // @@protoc_insertion_point(field_list:pb.COMP.spillOver)
  return _internal_spillover();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
COMP::_internal_mutable_spillover() {
  return &spillover_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
COMP::mutable_spillover() {
  // @@protoc_insertion_point(field_mutable_list:pb.COMP.spillOver)
  return _internal_mutable_spillover();
}

// -------------------------------------------------------------------

// PARAM

// optional string param = 1;
inline bool PARAM::_internal_has_param() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PARAM::has_param() const {
  return _internal_has_param();
}
inline void PARAM::clear_param() {
  param_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PARAM::param() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.param)
  return _internal_param();
}
inline void PARAM::set_param(const std::string& value) {
  _internal_set_param(value);
  // @@protoc_insertion_point(field_set:pb.PARAM.param)
}
inline std::string* PARAM::mutable_param() {
  // @@protoc_insertion_point(field_mutable:pb.PARAM.param)
  return _internal_mutable_param();
}
inline const std::string& PARAM::_internal_param() const {
  return param_.Get();
}
inline void PARAM::_internal_set_param(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  param_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PARAM::set_param(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  param_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PARAM.param)
}
inline void PARAM::set_param(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  param_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PARAM.param)
}
inline void PARAM::set_param(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  param_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PARAM.param)
}
inline std::string* PARAM::_internal_mutable_param() {
  _has_bits_[0] |= 0x00000001u;
  return param_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PARAM::release_param() {
  // @@protoc_insertion_point(field_release:pb.PARAM.param)
  if (!_internal_has_param()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return param_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PARAM::set_allocated_param(std::string* param) {
  if (param != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  param_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), param,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PARAM.param)
}

// optional bool log = 2;
inline bool PARAM::_internal_has_log() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PARAM::has_log() const {
  return _internal_has_log();
}
inline void PARAM::clear_log() {
  log_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PARAM::_internal_log() const {
  return log_;
}
inline bool PARAM::log() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.log)
  return _internal_log();
}
inline void PARAM::_internal_set_log(bool value) {
  _has_bits_[0] |= 0x00000002u;
  log_ = value;
}
inline void PARAM::set_log(bool value) {
  _internal_set_log(value);
  // @@protoc_insertion_point(field_set:pb.PARAM.log)
}

// optional uint32 range = 3;
inline bool PARAM::_internal_has_range() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PARAM::has_range() const {
  return _internal_has_range();
}
inline void PARAM::clear_range() {
  range_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PARAM::_internal_range() const {
  return range_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PARAM::range() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.range)
  return _internal_range();
}
inline void PARAM::_internal_set_range(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  range_ = value;
}
inline void PARAM::set_range(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:pb.PARAM.range)
}

// optional uint32 highValue = 4;
inline bool PARAM::_internal_has_highvalue() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PARAM::has_highvalue() const {
  return _internal_has_highvalue();
}
inline void PARAM::clear_highvalue() {
  highvalue_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PARAM::_internal_highvalue() const {
  return highvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PARAM::highvalue() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.highValue)
  return _internal_highvalue();
}
inline void PARAM::_internal_set_highvalue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  highvalue_ = value;
}
inline void PARAM::set_highvalue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_highvalue(value);
  // @@protoc_insertion_point(field_set:pb.PARAM.highValue)
}

// optional uint32 calibrationIndex = 5;
inline bool PARAM::_internal_has_calibrationindex() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PARAM::has_calibrationindex() const {
  return _internal_has_calibrationindex();
}
inline void PARAM::clear_calibrationindex() {
  calibrationindex_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PARAM::_internal_calibrationindex() const {
  return calibrationindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PARAM::calibrationindex() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.calibrationIndex)
  return _internal_calibrationindex();
}
inline void PARAM::_internal_set_calibrationindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  calibrationindex_ = value;
}
inline void PARAM::set_calibrationindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_calibrationindex(value);
  // @@protoc_insertion_point(field_set:pb.PARAM.calibrationIndex)
}

// -------------------------------------------------------------------

// GatingHierarchy

// required .pb.populationTree tree = 2;
inline bool GatingHierarchy::_internal_has_tree() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || tree_ != nullptr);
  return value;
}
inline bool GatingHierarchy::has_tree() const {
  return _internal_has_tree();
}
inline void GatingHierarchy::clear_tree() {
  if (tree_ != nullptr) tree_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pb::populationTree& GatingHierarchy::_internal_tree() const {
  const ::pb::populationTree* p = tree_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::populationTree*>(
      &::pb::_populationTree_default_instance_);
}
inline const ::pb::populationTree& GatingHierarchy::tree() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.tree)
  return _internal_tree();
}
inline void GatingHierarchy::unsafe_arena_set_allocated_tree(
    ::pb::populationTree* tree) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tree_);
  }
  tree_ = tree;
  if (tree) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.GatingHierarchy.tree)
}
inline ::pb::populationTree* GatingHierarchy::release_tree() {
  _has_bits_[0] &= ~0x00000002u;
  ::pb::populationTree* temp = tree_;
  tree_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::populationTree* GatingHierarchy::unsafe_arena_release_tree() {
  // @@protoc_insertion_point(field_release:pb.GatingHierarchy.tree)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::populationTree* temp = tree_;
  tree_ = nullptr;
  return temp;
}
inline ::pb::populationTree* GatingHierarchy::_internal_mutable_tree() {
  _has_bits_[0] |= 0x00000002u;
  if (tree_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::populationTree>(GetArena());
    tree_ = p;
  }
  return tree_;
}
inline ::pb::populationTree* GatingHierarchy::mutable_tree() {
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.tree)
  return _internal_mutable_tree();
}
inline void GatingHierarchy::set_allocated_tree(::pb::populationTree* tree) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tree_;
  }
  if (tree) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tree);
    if (message_arena != submessage_arena) {
      tree = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tree, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tree_ = tree;
  // @@protoc_insertion_point(field_set_allocated:pb.GatingHierarchy.tree)
}

// optional .pb.COMP comp = 1;
inline bool GatingHierarchy::_internal_has_comp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || comp_ != nullptr);
  return value;
}
inline bool GatingHierarchy::has_comp() const {
  return _internal_has_comp();
}
inline void GatingHierarchy::clear_comp() {
  if (comp_ != nullptr) comp_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::COMP& GatingHierarchy::_internal_comp() const {
  const ::pb::COMP* p = comp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::COMP*>(
      &::pb::_COMP_default_instance_);
}
inline const ::pb::COMP& GatingHierarchy::comp() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.comp)
  return _internal_comp();
}
inline void GatingHierarchy::unsafe_arena_set_allocated_comp(
    ::pb::COMP* comp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(comp_);
  }
  comp_ = comp;
  if (comp) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.GatingHierarchy.comp)
}
inline ::pb::COMP* GatingHierarchy::release_comp() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::COMP* temp = comp_;
  comp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::COMP* GatingHierarchy::unsafe_arena_release_comp() {
  // @@protoc_insertion_point(field_release:pb.GatingHierarchy.comp)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::COMP* temp = comp_;
  comp_ = nullptr;
  return temp;
}
inline ::pb::COMP* GatingHierarchy::_internal_mutable_comp() {
  _has_bits_[0] |= 0x00000001u;
  if (comp_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::COMP>(GetArena());
    comp_ = p;
  }
  return comp_;
}
inline ::pb::COMP* GatingHierarchy::mutable_comp() {
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.comp)
  return _internal_mutable_comp();
}
inline void GatingHierarchy::set_allocated_comp(::pb::COMP* comp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete comp_;
  }
  if (comp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(comp);
    if (message_arena != submessage_arena) {
      comp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comp_ = comp;
  // @@protoc_insertion_point(field_set_allocated:pb.GatingHierarchy.comp)
}

// optional bool isLoaded = 3;
inline bool GatingHierarchy::_internal_has_isloaded() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GatingHierarchy::has_isloaded() const {
  return _internal_has_isloaded();
}
inline void GatingHierarchy::clear_isloaded() {
  isloaded_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool GatingHierarchy::_internal_isloaded() const {
  return isloaded_;
}
inline bool GatingHierarchy::isloaded() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.isLoaded)
  return _internal_isloaded();
}
inline void GatingHierarchy::_internal_set_isloaded(bool value) {
  _has_bits_[0] |= 0x00000010u;
  isloaded_ = value;
}
inline void GatingHierarchy::set_isloaded(bool value) {
  _internal_set_isloaded(value);
  // @@protoc_insertion_point(field_set:pb.GatingHierarchy.isLoaded)
}

// repeated .pb.PARAM transFlag = 4;
inline int GatingHierarchy::_internal_transflag_size() const {
  return transflag_.size();
}
inline int GatingHierarchy::transflag_size() const {
  return _internal_transflag_size();
}
inline void GatingHierarchy::clear_transflag() {
  transflag_.Clear();
}
inline ::pb::PARAM* GatingHierarchy::mutable_transflag(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.transFlag)
  return transflag_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PARAM >*
GatingHierarchy::mutable_transflag() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingHierarchy.transFlag)
  return &transflag_;
}
inline const ::pb::PARAM& GatingHierarchy::_internal_transflag(int index) const {
  return transflag_.Get(index);
}
inline const ::pb::PARAM& GatingHierarchy::transflag(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.transFlag)
  return _internal_transflag(index);
}
inline ::pb::PARAM* GatingHierarchy::_internal_add_transflag() {
  return transflag_.Add();
}
inline ::pb::PARAM* GatingHierarchy::add_transflag() {
  // @@protoc_insertion_point(field_add:pb.GatingHierarchy.transFlag)
  return _internal_add_transflag();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PARAM >&
GatingHierarchy::transflag() const {
  // @@protoc_insertion_point(field_list:pb.GatingHierarchy.transFlag)
  return transflag_;
}

// optional .pb.trans_local trans = 5;
inline bool GatingHierarchy::_internal_has_trans() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || trans_ != nullptr);
  return value;
}
inline bool GatingHierarchy::has_trans() const {
  return _internal_has_trans();
}
inline void GatingHierarchy::clear_trans() {
  if (trans_ != nullptr) trans_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pb::trans_local& GatingHierarchy::_internal_trans() const {
  const ::pb::trans_local* p = trans_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::trans_local*>(
      &::pb::_trans_local_default_instance_);
}
inline const ::pb::trans_local& GatingHierarchy::trans() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.trans)
  return _internal_trans();
}
inline void GatingHierarchy::unsafe_arena_set_allocated_trans(
    ::pb::trans_local* trans) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trans_);
  }
  trans_ = trans;
  if (trans) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.GatingHierarchy.trans)
}
inline ::pb::trans_local* GatingHierarchy::release_trans() {
  _has_bits_[0] &= ~0x00000004u;
  ::pb::trans_local* temp = trans_;
  trans_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::trans_local* GatingHierarchy::unsafe_arena_release_trans() {
  // @@protoc_insertion_point(field_release:pb.GatingHierarchy.trans)
  _has_bits_[0] &= ~0x00000004u;
  ::pb::trans_local* temp = trans_;
  trans_ = nullptr;
  return temp;
}
inline ::pb::trans_local* GatingHierarchy::_internal_mutable_trans() {
  _has_bits_[0] |= 0x00000004u;
  if (trans_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::trans_local>(GetArena());
    trans_ = p;
  }
  return trans_;
}
inline ::pb::trans_local* GatingHierarchy::mutable_trans() {
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.trans)
  return _internal_mutable_trans();
}
inline void GatingHierarchy::set_allocated_trans(::pb::trans_local* trans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete trans_;
  }
  if (trans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(trans);
    if (message_arena != submessage_arena) {
      trans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trans, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  trans_ = trans;
  // @@protoc_insertion_point(field_set_allocated:pb.GatingHierarchy.trans)
}

// optional .pb.CytoFrame frame = 6;
inline bool GatingHierarchy::_internal_has_frame() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || frame_ != nullptr);
  return value;
}
inline bool GatingHierarchy::has_frame() const {
  return _internal_has_frame();
}
inline void GatingHierarchy::clear_frame() {
  if (frame_ != nullptr) frame_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pb::CytoFrame& GatingHierarchy::_internal_frame() const {
  const ::pb::CytoFrame* p = frame_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::CytoFrame*>(
      &::pb::_CytoFrame_default_instance_);
}
inline const ::pb::CytoFrame& GatingHierarchy::frame() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.frame)
  return _internal_frame();
}
inline void GatingHierarchy::unsafe_arena_set_allocated_frame(
    ::pb::CytoFrame* frame) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.GatingHierarchy.frame)
}
inline ::pb::CytoFrame* GatingHierarchy::release_frame() {
  _has_bits_[0] &= ~0x00000008u;
  ::pb::CytoFrame* temp = frame_;
  frame_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::CytoFrame* GatingHierarchy::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:pb.GatingHierarchy.frame)
  _has_bits_[0] &= ~0x00000008u;
  ::pb::CytoFrame* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::pb::CytoFrame* GatingHierarchy::_internal_mutable_frame() {
  _has_bits_[0] |= 0x00000008u;
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::CytoFrame>(GetArena());
    frame_ = p;
  }
  return frame_;
}
inline ::pb::CytoFrame* GatingHierarchy::mutable_frame() {
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.frame)
  return _internal_mutable_frame();
}
inline void GatingHierarchy::set_allocated_frame(::pb::CytoFrame* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:pb.GatingHierarchy.frame)
}

// -------------------------------------------------------------------

// CytoFrame

// required bool is_h5 = 1;
inline bool CytoFrame::_internal_has_is_h5() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CytoFrame::has_is_h5() const {
  return _internal_has_is_h5();
}
inline void CytoFrame::clear_is_h5() {
  is_h5_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CytoFrame::_internal_is_h5() const {
  return is_h5_;
}
inline bool CytoFrame::is_h5() const {
  // @@protoc_insertion_point(field_get:pb.CytoFrame.is_h5)
  return _internal_is_h5();
}
inline void CytoFrame::_internal_set_is_h5(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_h5_ = value;
}
inline void CytoFrame::set_is_h5(bool value) {
  _internal_set_is_h5(value);
  // @@protoc_insertion_point(field_set:pb.CytoFrame.is_h5)
}

// -------------------------------------------------------------------

// TRANS_TBL

// optional uint64 trans_address = 1;
inline bool TRANS_TBL::_internal_has_trans_address() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TRANS_TBL::has_trans_address() const {
  return _internal_has_trans_address();
}
inline void TRANS_TBL::clear_trans_address() {
  trans_address_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TRANS_TBL::_internal_trans_address() const {
  return trans_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TRANS_TBL::trans_address() const {
  // @@protoc_insertion_point(field_get:pb.TRANS_TBL.trans_address)
  return _internal_trans_address();
}
inline void TRANS_TBL::_internal_set_trans_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  trans_address_ = value;
}
inline void TRANS_TBL::set_trans_address(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_trans_address(value);
  // @@protoc_insertion_point(field_set:pb.TRANS_TBL.trans_address)
}

// optional .pb.transformation trans = 2;
inline bool TRANS_TBL::_internal_has_trans() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || trans_ != nullptr);
  return value;
}
inline bool TRANS_TBL::has_trans() const {
  return _internal_has_trans();
}
inline void TRANS_TBL::clear_trans() {
  if (trans_ != nullptr) trans_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::transformation& TRANS_TBL::_internal_trans() const {
  const ::pb::transformation* p = trans_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::transformation*>(
      &::pb::_transformation_default_instance_);
}
inline const ::pb::transformation& TRANS_TBL::trans() const {
  // @@protoc_insertion_point(field_get:pb.TRANS_TBL.trans)
  return _internal_trans();
}
inline void TRANS_TBL::unsafe_arena_set_allocated_trans(
    ::pb::transformation* trans) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trans_);
  }
  trans_ = trans;
  if (trans) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.TRANS_TBL.trans)
}
inline ::pb::transformation* TRANS_TBL::release_trans() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::transformation* temp = trans_;
  trans_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::transformation* TRANS_TBL::unsafe_arena_release_trans() {
  // @@protoc_insertion_point(field_release:pb.TRANS_TBL.trans)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::transformation* temp = trans_;
  trans_ = nullptr;
  return temp;
}
inline ::pb::transformation* TRANS_TBL::_internal_mutable_trans() {
  _has_bits_[0] |= 0x00000001u;
  if (trans_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::transformation>(GetArena());
    trans_ = p;
  }
  return trans_;
}
inline ::pb::transformation* TRANS_TBL::mutable_trans() {
  // @@protoc_insertion_point(field_mutable:pb.TRANS_TBL.trans)
  return _internal_mutable_trans();
}
inline void TRANS_TBL::set_allocated_trans(::pb::transformation* trans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete trans_;
  }
  if (trans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(trans);
    if (message_arena != submessage_arena) {
      trans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trans, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  trans_ = trans;
  // @@protoc_insertion_point(field_set_allocated:pb.TRANS_TBL.trans)
}

// -------------------------------------------------------------------

// GatingSet

// repeated .pb.TRANS_TBL trans_tbl = 2;
inline int GatingSet::_internal_trans_tbl_size() const {
  return trans_tbl_.size();
}
inline int GatingSet::trans_tbl_size() const {
  return _internal_trans_tbl_size();
}
inline void GatingSet::clear_trans_tbl() {
  trans_tbl_.Clear();
}
inline ::pb::TRANS_TBL* GatingSet::mutable_trans_tbl(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.trans_tbl)
  return trans_tbl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::TRANS_TBL >*
GatingSet::mutable_trans_tbl() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingSet.trans_tbl)
  return &trans_tbl_;
}
inline const ::pb::TRANS_TBL& GatingSet::_internal_trans_tbl(int index) const {
  return trans_tbl_.Get(index);
}
inline const ::pb::TRANS_TBL& GatingSet::trans_tbl(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.trans_tbl)
  return _internal_trans_tbl(index);
}
inline ::pb::TRANS_TBL* GatingSet::_internal_add_trans_tbl() {
  return trans_tbl_.Add();
}
inline ::pb::TRANS_TBL* GatingSet::add_trans_tbl() {
  // @@protoc_insertion_point(field_add:pb.GatingSet.trans_tbl)
  return _internal_add_trans_tbl();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::TRANS_TBL >&
GatingSet::trans_tbl() const {
  // @@protoc_insertion_point(field_list:pb.GatingSet.trans_tbl)
  return trans_tbl_;
}

// repeated string sampleName = 1;
inline int GatingSet::_internal_samplename_size() const {
  return samplename_.size();
}
inline int GatingSet::samplename_size() const {
  return _internal_samplename_size();
}
inline void GatingSet::clear_samplename() {
  samplename_.Clear();
}
inline std::string* GatingSet::add_samplename() {
  // @@protoc_insertion_point(field_add_mutable:pb.GatingSet.sampleName)
  return _internal_add_samplename();
}
inline const std::string& GatingSet::_internal_samplename(int index) const {
  return samplename_.Get(index);
}
inline const std::string& GatingSet::samplename(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.sampleName)
  return _internal_samplename(index);
}
inline std::string* GatingSet::mutable_samplename(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.sampleName)
  return samplename_.Mutable(index);
}
inline void GatingSet::set_samplename(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:pb.GatingSet.sampleName)
  samplename_.Mutable(index)->assign(value);
}
inline void GatingSet::set_samplename(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.GatingSet.sampleName)
  samplename_.Mutable(index)->assign(std::move(value));
}
inline void GatingSet::set_samplename(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  samplename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GatingSet.sampleName)
}
inline void GatingSet::set_samplename(int index, const char* value, size_t size) {
  samplename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GatingSet.sampleName)
}
inline std::string* GatingSet::_internal_add_samplename() {
  return samplename_.Add();
}
inline void GatingSet::add_samplename(const std::string& value) {
  samplename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.GatingSet.sampleName)
}
inline void GatingSet::add_samplename(std::string&& value) {
  samplename_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.GatingSet.sampleName)
}
inline void GatingSet::add_samplename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  samplename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.GatingSet.sampleName)
}
inline void GatingSet::add_samplename(const char* value, size_t size) {
  samplename_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.GatingSet.sampleName)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GatingSet::samplename() const {
  // @@protoc_insertion_point(field_list:pb.GatingSet.sampleName)
  return samplename_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GatingSet::mutable_samplename() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingSet.sampleName)
  return &samplename_;
}

// optional uint64 globalBiExpTrans = 3;
inline bool GatingSet::_internal_has_globalbiexptrans() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GatingSet::has_globalbiexptrans() const {
  return _internal_has_globalbiexptrans();
}
inline void GatingSet::clear_globalbiexptrans() {
  globalbiexptrans_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GatingSet::_internal_globalbiexptrans() const {
  return globalbiexptrans_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GatingSet::globalbiexptrans() const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.globalBiExpTrans)
  return _internal_globalbiexptrans();
}
inline void GatingSet::_internal_set_globalbiexptrans(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  globalbiexptrans_ = value;
}
inline void GatingSet::set_globalbiexptrans(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_globalbiexptrans(value);
  // @@protoc_insertion_point(field_set:pb.GatingSet.globalBiExpTrans)
}

// optional uint64 globalLinTrans = 4;
inline bool GatingSet::_internal_has_globallintrans() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GatingSet::has_globallintrans() const {
  return _internal_has_globallintrans();
}
inline void GatingSet::clear_globallintrans() {
  globallintrans_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GatingSet::_internal_globallintrans() const {
  return globallintrans_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GatingSet::globallintrans() const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.globalLinTrans)
  return _internal_globallintrans();
}
inline void GatingSet::_internal_set_globallintrans(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  globallintrans_ = value;
}
inline void GatingSet::set_globallintrans(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_globallintrans(value);
  // @@protoc_insertion_point(field_set:pb.GatingSet.globalLinTrans)
}

// repeated .pb.trans_local gTrans = 5;
inline int GatingSet::_internal_gtrans_size() const {
  return gtrans_.size();
}
inline int GatingSet::gtrans_size() const {
  return _internal_gtrans_size();
}
inline void GatingSet::clear_gtrans() {
  gtrans_.Clear();
}
inline ::pb::trans_local* GatingSet::mutable_gtrans(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.gTrans)
  return gtrans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_local >*
GatingSet::mutable_gtrans() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingSet.gTrans)
  return &gtrans_;
}
inline const ::pb::trans_local& GatingSet::_internal_gtrans(int index) const {
  return gtrans_.Get(index);
}
inline const ::pb::trans_local& GatingSet::gtrans(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.gTrans)
  return _internal_gtrans(index);
}
inline ::pb::trans_local* GatingSet::_internal_add_gtrans() {
  return gtrans_.Add();
}
inline ::pb::trans_local* GatingSet::add_gtrans() {
  // @@protoc_insertion_point(field_add:pb.GatingSet.gTrans)
  return _internal_add_gtrans();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::trans_local >&
GatingSet::gtrans() const {
  // @@protoc_insertion_point(field_list:pb.GatingSet.gTrans)
  return gtrans_;
}

// optional string guid = 6;
inline bool GatingSet::_internal_has_guid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GatingSet::has_guid() const {
  return _internal_has_guid();
}
inline void GatingSet::clear_guid() {
  guid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GatingSet::guid() const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.guid)
  return _internal_guid();
}
inline void GatingSet::set_guid(const std::string& value) {
  _internal_set_guid(value);
  // @@protoc_insertion_point(field_set:pb.GatingSet.guid)
}
inline std::string* GatingSet::mutable_guid() {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.guid)
  return _internal_mutable_guid();
}
inline const std::string& GatingSet::_internal_guid() const {
  return guid_.Get();
}
inline void GatingSet::_internal_set_guid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GatingSet::set_guid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  guid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.GatingSet.guid)
}
inline void GatingSet::set_guid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.GatingSet.guid)
}
inline void GatingSet::set_guid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.GatingSet.guid)
}
inline std::string* GatingSet::_internal_mutable_guid() {
  _has_bits_[0] |= 0x00000001u;
  return guid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GatingSet::release_guid() {
  // @@protoc_insertion_point(field_release:pb.GatingSet.guid)
  if (!_internal_has_guid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return guid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GatingSet::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  guid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), guid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.GatingSet.guid)
}

// optional string cytolib_verion = 7;
inline bool GatingSet::_internal_has_cytolib_verion() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GatingSet::has_cytolib_verion() const {
  return _internal_has_cytolib_verion();
}
inline void GatingSet::clear_cytolib_verion() {
  cytolib_verion_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GatingSet::cytolib_verion() const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.cytolib_verion)
  return _internal_cytolib_verion();
}
inline void GatingSet::set_cytolib_verion(const std::string& value) {
  _internal_set_cytolib_verion(value);
  // @@protoc_insertion_point(field_set:pb.GatingSet.cytolib_verion)
}
inline std::string* GatingSet::mutable_cytolib_verion() {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.cytolib_verion)
  return _internal_mutable_cytolib_verion();
}
inline const std::string& GatingSet::_internal_cytolib_verion() const {
  return cytolib_verion_.Get();
}
inline void GatingSet::_internal_set_cytolib_verion(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  cytolib_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GatingSet::set_cytolib_verion(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  cytolib_verion_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.GatingSet.cytolib_verion)
}
inline void GatingSet::set_cytolib_verion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  cytolib_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.GatingSet.cytolib_verion)
}
inline void GatingSet::set_cytolib_verion(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  cytolib_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.GatingSet.cytolib_verion)
}
inline std::string* GatingSet::_internal_mutable_cytolib_verion() {
  _has_bits_[0] |= 0x00000002u;
  return cytolib_verion_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GatingSet::release_cytolib_verion() {
  // @@protoc_insertion_point(field_release:pb.GatingSet.cytolib_verion)
  if (!_internal_has_cytolib_verion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return cytolib_verion_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GatingSet::set_allocated_cytolib_verion(std::string* cytolib_verion) {
  if (cytolib_verion != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cytolib_verion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cytolib_verion,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.GatingSet.cytolib_verion)
}

// optional string pb_verion = 8;
inline bool GatingSet::_internal_has_pb_verion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GatingSet::has_pb_verion() const {
  return _internal_has_pb_verion();
}
inline void GatingSet::clear_pb_verion() {
  pb_verion_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GatingSet::pb_verion() const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.pb_verion)
  return _internal_pb_verion();
}
inline void GatingSet::set_pb_verion(const std::string& value) {
  _internal_set_pb_verion(value);
  // @@protoc_insertion_point(field_set:pb.GatingSet.pb_verion)
}
inline std::string* GatingSet::mutable_pb_verion() {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.pb_verion)
  return _internal_mutable_pb_verion();
}
inline const std::string& GatingSet::_internal_pb_verion() const {
  return pb_verion_.Get();
}
inline void GatingSet::_internal_set_pb_verion(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  pb_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GatingSet::set_pb_verion(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  pb_verion_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.GatingSet.pb_verion)
}
inline void GatingSet::set_pb_verion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  pb_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.GatingSet.pb_verion)
}
inline void GatingSet::set_pb_verion(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  pb_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.GatingSet.pb_verion)
}
inline std::string* GatingSet::_internal_mutable_pb_verion() {
  _has_bits_[0] |= 0x00000004u;
  return pb_verion_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GatingSet::release_pb_verion() {
  // @@protoc_insertion_point(field_release:pb.GatingSet.pb_verion)
  if (!_internal_has_pb_verion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return pb_verion_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GatingSet::set_allocated_pb_verion(std::string* pb_verion) {
  if (pb_verion != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pb_verion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pb_verion,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.GatingSet.pb_verion)
}

// optional string h5_verion = 9;
inline bool GatingSet::_internal_has_h5_verion() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GatingSet::has_h5_verion() const {
  return _internal_has_h5_verion();
}
inline void GatingSet::clear_h5_verion() {
  h5_verion_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GatingSet::h5_verion() const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.h5_verion)
  return _internal_h5_verion();
}
inline void GatingSet::set_h5_verion(const std::string& value) {
  _internal_set_h5_verion(value);
  // @@protoc_insertion_point(field_set:pb.GatingSet.h5_verion)
}
inline std::string* GatingSet::mutable_h5_verion() {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.h5_verion)
  return _internal_mutable_h5_verion();
}
inline const std::string& GatingSet::_internal_h5_verion() const {
  return h5_verion_.Get();
}
inline void GatingSet::_internal_set_h5_verion(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  h5_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GatingSet::set_h5_verion(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  h5_verion_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.GatingSet.h5_verion)
}
inline void GatingSet::set_h5_verion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  h5_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pb.GatingSet.h5_verion)
}
inline void GatingSet::set_h5_verion(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  h5_verion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.GatingSet.h5_verion)
}
inline std::string* GatingSet::_internal_mutable_h5_verion() {
  _has_bits_[0] |= 0x00000008u;
  return h5_verion_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GatingSet::release_h5_verion() {
  // @@protoc_insertion_point(field_release:pb.GatingSet.h5_verion)
  if (!_internal_has_h5_verion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return h5_verion_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GatingSet::set_allocated_h5_verion(std::string* h5_verion) {
  if (h5_verion != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  h5_verion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), h5_verion,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.GatingSet.h5_verion)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::QUADRANT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::QUADRANT>() {
  return ::pb::QUADRANT_descriptor();
}
template <> struct is_proto_enum< ::pb::GATE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::GATE_TYPE>() {
  return ::pb::GATE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::pb::ind_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ind_type>() {
  return ::pb::ind_type_descriptor();
}
template <> struct is_proto_enum< ::pb::TRANS_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::TRANS_TYPE>() {
  return ::pb::TRANS_TYPE_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_GatingSet_2eproto
