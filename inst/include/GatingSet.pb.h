// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GatingSet.proto

#ifndef PROTOBUF_GatingSet_2eproto__INCLUDED
#define PROTOBUF_GatingSet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
//#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GatingSet_2eproto();
void protobuf_AssignDesc_GatingSet_2eproto();
void protobuf_ShutdownFile_GatingSet_2eproto();

class paramRange;
class rangeGate;
class paramPoly;
class polygonGate;
class coordinate;
class ellipseGate;
class BOOL_GATE_OP;
class boolGate;
class gate;
class POPSTATS;
class calibrationTable;
class biexpTrans;
class fasinhTrans;
class scaleTrans;
class flinTrans;
class logTrans;
class transformation;
class trans_pair;
class trans_local;
class POPINDICES;
class nodeProperties;
class treeNodes;
class populationTree;
class COMP;
class PARAM;
class GatingHierarchy;
class TRANS_TBL;
class GatingSet;

enum GATE_TYPE {
  POLYGON_GATE = 1,
  RANGE_GATE = 2,
  BOOL_GATE = 3,
  ELLIPSE_GATE = 4,
  RECT_GATE = 5,
  LOGICAL_GATE = 6,
  ELLIPSOID_GATE = 7
};
bool GATE_TYPE_IsValid(int value);
const GATE_TYPE GATE_TYPE_MIN = POLYGON_GATE;
const GATE_TYPE GATE_TYPE_MAX = ELLIPSOID_GATE;
const int GATE_TYPE_ARRAYSIZE = GATE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GATE_TYPE_descriptor();
inline const ::std::string& GATE_TYPE_Name(GATE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GATE_TYPE_descriptor(), value);
}
inline bool GATE_TYPE_Parse(
    const ::std::string& name, GATE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GATE_TYPE>(
    GATE_TYPE_descriptor(), name, value);
}
enum ind_type {
  BOOL = 0,
  INT = 1,
  ROOT = 2
};
bool ind_type_IsValid(int value);
const ind_type ind_type_MIN = BOOL;
const ind_type ind_type_MAX = ROOT;
const int ind_type_ARRAYSIZE = ind_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ind_type_descriptor();
inline const ::std::string& ind_type_Name(ind_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ind_type_descriptor(), value);
}
inline bool ind_type_Parse(
    const ::std::string& name, ind_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ind_type>(
    ind_type_descriptor(), name, value);
}
enum TRANS_TYPE {
  PB_CALTBL = 0,
  PB_LOG = 1,
  PB_LIN = 2,
  PB_FLIN = 3,
  PB_FASIGNH = 4,
  PB_BIEXP = 5
};
bool TRANS_TYPE_IsValid(int value);
const TRANS_TYPE TRANS_TYPE_MIN = PB_CALTBL;
const TRANS_TYPE TRANS_TYPE_MAX = PB_BIEXP;
const int TRANS_TYPE_ARRAYSIZE = TRANS_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* TRANS_TYPE_descriptor();
inline const ::std::string& TRANS_TYPE_Name(TRANS_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    TRANS_TYPE_descriptor(), value);
}
inline bool TRANS_TYPE_Parse(
    const ::std::string& name, TRANS_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TRANS_TYPE>(
    TRANS_TYPE_descriptor(), name, value);
}
// ===================================================================

class paramRange : public ::google::protobuf::Message {
 public:
  paramRange();
  virtual ~paramRange();

  paramRange(const paramRange& from);

  inline paramRange& operator=(const paramRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const paramRange& default_instance();

  void Swap(paramRange* other);

  // implements Message ----------------------------------------------

  paramRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const paramRange& from);
  void MergeFrom(const paramRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required float min = 2;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 2;
  inline float min() const;
  inline void set_min(float value);

  // required float max = 3;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 3;
  inline float max() const;
  inline void set_max(float value);

  // @@protoc_insertion_point(class_scope:pb.paramRange)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  float min_;
  float max_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static paramRange* default_instance_;
};
// -------------------------------------------------------------------

class rangeGate : public ::google::protobuf::Message {
 public:
  rangeGate();
  virtual ~rangeGate();

  rangeGate(const rangeGate& from);

  inline rangeGate& operator=(const rangeGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rangeGate& default_instance();

  void Swap(rangeGate* other);

  // implements Message ----------------------------------------------

  rangeGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rangeGate& from);
  void MergeFrom(const rangeGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.paramRange param = 1;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline const ::pb::paramRange& param() const;
  inline ::pb::paramRange* mutable_param();
  inline ::pb::paramRange* release_param();
  inline void set_allocated_param(::pb::paramRange* param);

  // @@protoc_insertion_point(class_scope:pb.rangeGate)
 private:
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::paramRange* param_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static rangeGate* default_instance_;
};
// -------------------------------------------------------------------

class paramPoly : public ::google::protobuf::Message {
 public:
  paramPoly();
  virtual ~paramPoly();

  paramPoly(const paramPoly& from);

  inline paramPoly& operator=(const paramPoly& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const paramPoly& default_instance();

  void Swap(paramPoly* other);

  // implements Message ----------------------------------------------

  paramPoly* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const paramPoly& from);
  void MergeFrom(const paramPoly& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string params = 1;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 1;
  inline const ::std::string& params(int index) const;
  inline ::std::string* mutable_params(int index);
  inline void set_params(int index, const ::std::string& value);
  inline void set_params(int index, const char* value);
  inline void set_params(int index, const char* value, size_t size);
  inline ::std::string* add_params();
  inline void add_params(const ::std::string& value);
  inline void add_params(const char* value);
  inline void add_params(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // repeated .pb.coordinate vertices = 2;
  inline int vertices_size() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 2;
  inline const ::pb::coordinate& vertices(int index) const;
  inline ::pb::coordinate* mutable_vertices(int index);
  inline ::pb::coordinate* add_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::coordinate >&
      vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::coordinate >*
      mutable_vertices();

  // @@protoc_insertion_point(class_scope:pb.paramPoly)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;
  ::google::protobuf::RepeatedPtrField< ::pb::coordinate > vertices_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static paramPoly* default_instance_;
};
// -------------------------------------------------------------------

class polygonGate : public ::google::protobuf::Message {
 public:
  polygonGate();
  virtual ~polygonGate();

  polygonGate(const polygonGate& from);

  inline polygonGate& operator=(const polygonGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const polygonGate& default_instance();

  void Swap(polygonGate* other);

  // implements Message ----------------------------------------------

  polygonGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const polygonGate& from);
  void MergeFrom(const polygonGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.paramPoly param = 1;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline const ::pb::paramPoly& param() const;
  inline ::pb::paramPoly* mutable_param();
  inline ::pb::paramPoly* release_param();
  inline void set_allocated_param(::pb::paramPoly* param);

  // @@protoc_insertion_point(class_scope:pb.polygonGate)
 private:
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::paramPoly* param_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static polygonGate* default_instance_;
};
// -------------------------------------------------------------------

class coordinate : public ::google::protobuf::Message {
 public:
  coordinate();
  virtual ~coordinate();

  coordinate(const coordinate& from);

  inline coordinate& operator=(const coordinate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const coordinate& default_instance();

  void Swap(coordinate* other);

  // implements Message ----------------------------------------------

  coordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const coordinate& from);
  void MergeFrom(const coordinate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:pb.coordinate)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static coordinate* default_instance_;
};
// -------------------------------------------------------------------

class ellipseGate : public ::google::protobuf::Message {
 public:
  ellipseGate();
  virtual ~ellipseGate();

  ellipseGate(const ellipseGate& from);

  inline ellipseGate& operator=(const ellipseGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ellipseGate& default_instance();

  void Swap(ellipseGate* other);

  // implements Message ----------------------------------------------

  ellipseGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ellipseGate& from);
  void MergeFrom(const ellipseGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.coordinate mu = 1;
  inline bool has_mu() const;
  inline void clear_mu();
  static const int kMuFieldNumber = 1;
  inline const ::pb::coordinate& mu() const;
  inline ::pb::coordinate* mutable_mu();
  inline ::pb::coordinate* release_mu();
  inline void set_allocated_mu(::pb::coordinate* mu);

  // repeated .pb.coordinate cov = 2;
  inline int cov_size() const;
  inline void clear_cov();
  static const int kCovFieldNumber = 2;
  inline const ::pb::coordinate& cov(int index) const;
  inline ::pb::coordinate* mutable_cov(int index);
  inline ::pb::coordinate* add_cov();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::coordinate >&
      cov() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::coordinate >*
      mutable_cov();

  // repeated .pb.coordinate antipodal_vertices = 3;
  inline int antipodal_vertices_size() const;
  inline void clear_antipodal_vertices();
  static const int kAntipodalVerticesFieldNumber = 3;
  inline const ::pb::coordinate& antipodal_vertices(int index) const;
  inline ::pb::coordinate* mutable_antipodal_vertices(int index);
  inline ::pb::coordinate* add_antipodal_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::coordinate >&
      antipodal_vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::coordinate >*
      mutable_antipodal_vertices();

  // optional float dist = 4;
  inline bool has_dist() const;
  inline void clear_dist();
  static const int kDistFieldNumber = 4;
  inline float dist() const;
  inline void set_dist(float value);

  // @@protoc_insertion_point(class_scope:pb.ellipseGate)
 private:
  inline void set_has_mu();
  inline void clear_has_mu();
  inline void set_has_dist();
  inline void clear_has_dist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::coordinate* mu_;
  ::google::protobuf::RepeatedPtrField< ::pb::coordinate > cov_;
  ::google::protobuf::RepeatedPtrField< ::pb::coordinate > antipodal_vertices_;
  float dist_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static ellipseGate* default_instance_;
};
// -------------------------------------------------------------------

class BOOL_GATE_OP : public ::google::protobuf::Message {
 public:
  BOOL_GATE_OP();
  virtual ~BOOL_GATE_OP();

  BOOL_GATE_OP(const BOOL_GATE_OP& from);

  inline BOOL_GATE_OP& operator=(const BOOL_GATE_OP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BOOL_GATE_OP& default_instance();

  void Swap(BOOL_GATE_OP* other);

  // implements Message ----------------------------------------------

  BOOL_GATE_OP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BOOL_GATE_OP& from);
  void MergeFrom(const BOOL_GATE_OP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string path = 1;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path(int index) const;
  inline ::std::string* mutable_path(int index);
  inline void set_path(int index, const ::std::string& value);
  inline void set_path(int index, const char* value);
  inline void set_path(int index, const char* value, size_t size);
  inline ::std::string* add_path();
  inline void add_path(const ::std::string& value);
  inline void add_path(const char* value);
  inline void add_path(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& path() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_path();

  // required uint32 op = 2;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 2;
  inline ::google::protobuf::uint32 op() const;
  inline void set_op(::google::protobuf::uint32 value);

  // required bool isNot = 3;
  inline bool has_isnot() const;
  inline void clear_isnot();
  static const int kIsNotFieldNumber = 3;
  inline bool isnot() const;
  inline void set_isnot(bool value);

  // @@protoc_insertion_point(class_scope:pb.BOOL_GATE_OP)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_isnot();
  inline void clear_has_isnot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> path_;
  ::google::protobuf::uint32 op_;
  bool isnot_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static BOOL_GATE_OP* default_instance_;
};
// -------------------------------------------------------------------

class boolGate : public ::google::protobuf::Message {
 public:
  boolGate();
  virtual ~boolGate();

  boolGate(const boolGate& from);

  inline boolGate& operator=(const boolGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boolGate& default_instance();

  void Swap(boolGate* other);

  // implements Message ----------------------------------------------

  boolGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boolGate& from);
  void MergeFrom(const boolGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
  inline int boolopspec_size() const;
  inline void clear_boolopspec();
  static const int kBoolOpSpecFieldNumber = 1;
  inline const ::pb::BOOL_GATE_OP& boolopspec(int index) const;
  inline ::pb::BOOL_GATE_OP* mutable_boolopspec(int index);
  inline ::pb::BOOL_GATE_OP* add_boolopspec();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BOOL_GATE_OP >&
      boolopspec() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BOOL_GATE_OP >*
      mutable_boolopspec();

  // @@protoc_insertion_point(class_scope:pb.boolGate)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::BOOL_GATE_OP > boolopspec_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static boolGate* default_instance_;
};
// -------------------------------------------------------------------

class gate : public ::google::protobuf::Message {
 public:
  gate();
  virtual ~gate();

  gate(const gate& from);

  inline gate& operator=(const gate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gate& default_instance();

  void Swap(gate* other);

  // implements Message ----------------------------------------------

  gate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gate& from);
  void MergeFrom(const gate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool neg = 1;
  inline bool has_neg() const;
  inline void clear_neg();
  static const int kNegFieldNumber = 1;
  inline bool neg() const;
  inline void set_neg(bool value);

  // required bool isTransformed = 2;
  inline bool has_istransformed() const;
  inline void clear_istransformed();
  static const int kIsTransformedFieldNumber = 2;
  inline bool istransformed() const;
  inline void set_istransformed(bool value);

  // required bool isGained = 3;
  inline bool has_isgained() const;
  inline void clear_isgained();
  static const int kIsGainedFieldNumber = 3;
  inline bool isgained() const;
  inline void set_isgained(bool value);

  // required .pb.GATE_TYPE type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::pb::GATE_TYPE type() const;
  inline void set_type(::pb::GATE_TYPE value);

  // optional .pb.rangeGate rg = 5;
  inline bool has_rg() const;
  inline void clear_rg();
  static const int kRgFieldNumber = 5;
  inline const ::pb::rangeGate& rg() const;
  inline ::pb::rangeGate* mutable_rg();
  inline ::pb::rangeGate* release_rg();
  inline void set_allocated_rg(::pb::rangeGate* rg);

  // optional .pb.polygonGate pg = 6;
  inline bool has_pg() const;
  inline void clear_pg();
  static const int kPgFieldNumber = 6;
  inline const ::pb::polygonGate& pg() const;
  inline ::pb::polygonGate* mutable_pg();
  inline ::pb::polygonGate* release_pg();
  inline void set_allocated_pg(::pb::polygonGate* pg);

  // optional .pb.ellipseGate eg = 7;
  inline bool has_eg() const;
  inline void clear_eg();
  static const int kEgFieldNumber = 7;
  inline const ::pb::ellipseGate& eg() const;
  inline ::pb::ellipseGate* mutable_eg();
  inline ::pb::ellipseGate* release_eg();
  inline void set_allocated_eg(::pb::ellipseGate* eg);

  // optional .pb.boolGate bg = 8;
  inline bool has_bg() const;
  inline void clear_bg();
  static const int kBgFieldNumber = 8;
  inline const ::pb::boolGate& bg() const;
  inline ::pb::boolGate* mutable_bg();
  inline ::pb::boolGate* release_bg();
  inline void set_allocated_bg(::pb::boolGate* bg);

  // @@protoc_insertion_point(class_scope:pb.gate)
 private:
  inline void set_has_neg();
  inline void clear_has_neg();
  inline void set_has_istransformed();
  inline void clear_has_istransformed();
  inline void set_has_isgained();
  inline void clear_has_isgained();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_rg();
  inline void clear_has_rg();
  inline void set_has_pg();
  inline void clear_has_pg();
  inline void set_has_eg();
  inline void clear_has_eg();
  inline void set_has_bg();
  inline void clear_has_bg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool neg_;
  bool istransformed_;
  bool isgained_;
  int type_;
  ::pb::rangeGate* rg_;
  ::pb::polygonGate* pg_;
  ::pb::ellipseGate* eg_;
  ::pb::boolGate* bg_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static gate* default_instance_;
};
// -------------------------------------------------------------------

class POPSTATS : public ::google::protobuf::Message {
 public:
  POPSTATS();
  virtual ~POPSTATS();

  POPSTATS(const POPSTATS& from);

  inline POPSTATS& operator=(const POPSTATS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const POPSTATS& default_instance();

  void Swap(POPSTATS* other);

  // implements Message ----------------------------------------------

  POPSTATS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const POPSTATS& from);
  void MergeFrom(const POPSTATS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string statType = 1;
  inline bool has_stattype() const;
  inline void clear_stattype();
  static const int kStatTypeFieldNumber = 1;
  inline const ::std::string& stattype() const;
  inline void set_stattype(const ::std::string& value);
  inline void set_stattype(const char* value);
  inline void set_stattype(const char* value, size_t size);
  inline ::std::string* mutable_stattype();
  inline ::std::string* release_stattype();
  inline void set_allocated_stattype(::std::string* stattype);

  // required float statVal = 2;
  inline bool has_statval() const;
  inline void clear_statval();
  static const int kStatValFieldNumber = 2;
  inline float statval() const;
  inline void set_statval(float value);

  // @@protoc_insertion_point(class_scope:pb.POPSTATS)
 private:
  inline void set_has_stattype();
  inline void clear_has_stattype();
  inline void set_has_statval();
  inline void clear_has_statval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* stattype_;
  float statval_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static POPSTATS* default_instance_;
};
// -------------------------------------------------------------------

class calibrationTable : public ::google::protobuf::Message {
 public:
  calibrationTable();
  virtual ~calibrationTable();

  calibrationTable(const calibrationTable& from);

  inline calibrationTable& operator=(const calibrationTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const calibrationTable& default_instance();

  void Swap(calibrationTable* other);

  // implements Message ----------------------------------------------

  calibrationTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const calibrationTable& from);
  void MergeFrom(const calibrationTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float x = 1 [packed = true];
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x(int index) const;
  inline void set_x(int index, float value);
  inline void add_x(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      x() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // repeated float y = 2 [packed = true];
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y(int index) const;
  inline void set_y(int index, float value);
  inline void add_y(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      y() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_y();

  // repeated float b = 3 [packed = true];
  inline int b_size() const;
  inline void clear_b();
  static const int kBFieldNumber = 3;
  inline float b(int index) const;
  inline void set_b(int index, float value);
  inline void add_b(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      b() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_b();

  // repeated float c = 4 [packed = true];
  inline int c_size() const;
  inline void clear_c();
  static const int kCFieldNumber = 4;
  inline float c(int index) const;
  inline void set_c(int index, float value);
  inline void add_c(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      c() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_c();

  // repeated float d = 5 [packed = true];
  inline int d_size() const;
  inline void clear_d();
  static const int kDFieldNumber = 5;
  inline float d(int index) const;
  inline void set_d(int index, float value);
  inline void add_d(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      d() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_d();

  // optional uint32 spline_method = 6;
  inline bool has_spline_method() const;
  inline void clear_spline_method();
  static const int kSplineMethodFieldNumber = 6;
  inline ::google::protobuf::uint32 spline_method() const;
  inline void set_spline_method(::google::protobuf::uint32 value);

  // optional string caltype = 7;
  inline bool has_caltype() const;
  inline void clear_caltype();
  static const int kCaltypeFieldNumber = 7;
  inline const ::std::string& caltype() const;
  inline void set_caltype(const ::std::string& value);
  inline void set_caltype(const char* value);
  inline void set_caltype(const char* value, size_t size);
  inline ::std::string* mutable_caltype();
  inline ::std::string* release_caltype();
  inline void set_allocated_caltype(::std::string* caltype);

  // optional bool flag = 8;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 8;
  inline bool flag() const;
  inline void set_flag(bool value);

  // @@protoc_insertion_point(class_scope:pb.calibrationTable)
 private:
  inline void set_has_spline_method();
  inline void clear_has_spline_method();
  inline void set_has_caltype();
  inline void clear_has_caltype();
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > y_;
  mutable int _y_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > b_;
  mutable int _b_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > c_;
  mutable int _c_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > d_;
  mutable int _d_cached_byte_size_;
  ::std::string* caltype_;
  ::google::protobuf::uint32 spline_method_;
  bool flag_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static calibrationTable* default_instance_;
};
// -------------------------------------------------------------------

class biexpTrans : public ::google::protobuf::Message {
 public:
  biexpTrans();
  virtual ~biexpTrans();

  biexpTrans(const biexpTrans& from);

  inline biexpTrans& operator=(const biexpTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const biexpTrans& default_instance();

  void Swap(biexpTrans* other);

  // implements Message ----------------------------------------------

  biexpTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const biexpTrans& from);
  void MergeFrom(const biexpTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 channelRange = 1;
  inline bool has_channelrange() const;
  inline void clear_channelrange();
  static const int kChannelRangeFieldNumber = 1;
  inline ::google::protobuf::uint32 channelrange() const;
  inline void set_channelrange(::google::protobuf::uint32 value);

  // optional float pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline float pos() const;
  inline void set_pos(float value);

  // optional float neg = 3;
  inline bool has_neg() const;
  inline void clear_neg();
  static const int kNegFieldNumber = 3;
  inline float neg() const;
  inline void set_neg(float value);

  // optional float widthBasis = 4;
  inline bool has_widthbasis() const;
  inline void clear_widthbasis();
  static const int kWidthBasisFieldNumber = 4;
  inline float widthbasis() const;
  inline void set_widthbasis(float value);

  // optional float maxValue = 5;
  inline bool has_maxvalue() const;
  inline void clear_maxvalue();
  static const int kMaxValueFieldNumber = 5;
  inline float maxvalue() const;
  inline void set_maxvalue(float value);

  // @@protoc_insertion_point(class_scope:pb.biexpTrans)
 private:
  inline void set_has_channelrange();
  inline void clear_has_channelrange();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_neg();
  inline void clear_has_neg();
  inline void set_has_widthbasis();
  inline void clear_has_widthbasis();
  inline void set_has_maxvalue();
  inline void clear_has_maxvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 channelrange_;
  float pos_;
  float neg_;
  float widthbasis_;
  float maxvalue_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static biexpTrans* default_instance_;
};
// -------------------------------------------------------------------

class fasinhTrans : public ::google::protobuf::Message {
 public:
  fasinhTrans();
  virtual ~fasinhTrans();

  fasinhTrans(const fasinhTrans& from);

  inline fasinhTrans& operator=(const fasinhTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fasinhTrans& default_instance();

  void Swap(fasinhTrans* other);

  // implements Message ----------------------------------------------

  fasinhTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fasinhTrans& from);
  void MergeFrom(const fasinhTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline float length() const;
  inline void set_length(float value);

  // optional float maxRange = 2;
  inline bool has_maxrange() const;
  inline void clear_maxrange();
  static const int kMaxRangeFieldNumber = 2;
  inline float maxrange() const;
  inline void set_maxrange(float value);

  // optional float T = 3;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 3;
  inline float t() const;
  inline void set_t(float value);

  // optional float A = 4;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 4;
  inline float a() const;
  inline void set_a(float value);

  // optional float M = 5;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 5;
  inline float m() const;
  inline void set_m(float value);

  // @@protoc_insertion_point(class_scope:pb.fasinhTrans)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_maxrange();
  inline void clear_has_maxrange();
  inline void set_has_t();
  inline void clear_has_t();
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_m();
  inline void clear_has_m();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float length_;
  float maxrange_;
  float t_;
  float a_;
  float m_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static fasinhTrans* default_instance_;
};
// -------------------------------------------------------------------

class scaleTrans : public ::google::protobuf::Message {
 public:
  scaleTrans();
  virtual ~scaleTrans();

  scaleTrans(const scaleTrans& from);

  inline scaleTrans& operator=(const scaleTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scaleTrans& default_instance();

  void Swap(scaleTrans* other);

  // implements Message ----------------------------------------------

  scaleTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scaleTrans& from);
  void MergeFrom(const scaleTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float scale_factor = 1;
  inline bool has_scale_factor() const;
  inline void clear_scale_factor();
  static const int kScaleFactorFieldNumber = 1;
  inline float scale_factor() const;
  inline void set_scale_factor(float value);

  // @@protoc_insertion_point(class_scope:pb.scaleTrans)
 private:
  inline void set_has_scale_factor();
  inline void clear_has_scale_factor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float scale_factor_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static scaleTrans* default_instance_;
};
// -------------------------------------------------------------------

class flinTrans : public ::google::protobuf::Message {
 public:
  flinTrans();
  virtual ~flinTrans();

  flinTrans(const flinTrans& from);

  inline flinTrans& operator=(const flinTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flinTrans& default_instance();

  void Swap(flinTrans* other);

  // implements Message ----------------------------------------------

  flinTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const flinTrans& from);
  void MergeFrom(const flinTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min = 1;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 1;
  inline float min() const;
  inline void set_min(float value);

  // optional float max = 2;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 2;
  inline float max() const;
  inline void set_max(float value);

  // @@protoc_insertion_point(class_scope:pb.flinTrans)
 private:
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float min_;
  float max_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static flinTrans* default_instance_;
};
// -------------------------------------------------------------------

class logTrans : public ::google::protobuf::Message {
 public:
  logTrans();
  virtual ~logTrans();

  logTrans(const logTrans& from);

  inline logTrans& operator=(const logTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const logTrans& default_instance();

  void Swap(logTrans* other);

  // implements Message ----------------------------------------------

  logTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const logTrans& from);
  void MergeFrom(const logTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline float offset() const;
  inline void set_offset(float value);

  // optional float decade = 2;
  inline bool has_decade() const;
  inline void clear_decade();
  static const int kDecadeFieldNumber = 2;
  inline float decade() const;
  inline void set_decade(float value);

  // optional float T = 3;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 3;
  inline float t() const;
  inline void set_t(float value);

  // @@protoc_insertion_point(class_scope:pb.logTrans)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_decade();
  inline void clear_has_decade();
  inline void set_has_t();
  inline void clear_has_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float offset_;
  float decade_;
  float t_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static logTrans* default_instance_;
};
// -------------------------------------------------------------------

class transformation : public ::google::protobuf::Message {
 public:
  transformation();
  virtual ~transformation();

  transformation(const transformation& from);

  inline transformation& operator=(const transformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const transformation& default_instance();

  void Swap(transformation* other);

  // implements Message ----------------------------------------------

  transformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const transformation& from);
  void MergeFrom(const transformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.calibrationTable calTbl = 1;
  inline bool has_caltbl() const;
  inline void clear_caltbl();
  static const int kCalTblFieldNumber = 1;
  inline const ::pb::calibrationTable& caltbl() const;
  inline ::pb::calibrationTable* mutable_caltbl();
  inline ::pb::calibrationTable* release_caltbl();
  inline void set_allocated_caltbl(::pb::calibrationTable* caltbl);

  // optional bool isGateOnly = 2;
  inline bool has_isgateonly() const;
  inline void clear_isgateonly();
  static const int kIsGateOnlyFieldNumber = 2;
  inline bool isgateonly() const;
  inline void set_isgateonly(bool value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional bool isComputed = 6;
  inline bool has_iscomputed() const;
  inline void clear_iscomputed();
  static const int kIsComputedFieldNumber = 6;
  inline bool iscomputed() const;
  inline void set_iscomputed(bool value);

  // optional uint32 type = 12;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 12;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional .pb.TRANS_TYPE trans_type = 3;
  inline bool has_trans_type() const;
  inline void clear_trans_type();
  static const int kTransTypeFieldNumber = 3;
  inline ::pb::TRANS_TYPE trans_type() const;
  inline void set_trans_type(::pb::TRANS_TYPE value);

  // optional .pb.biexpTrans bt = 7;
  inline bool has_bt() const;
  inline void clear_bt();
  static const int kBtFieldNumber = 7;
  inline const ::pb::biexpTrans& bt() const;
  inline ::pb::biexpTrans* mutable_bt();
  inline ::pb::biexpTrans* release_bt();
  inline void set_allocated_bt(::pb::biexpTrans* bt);

  // optional .pb.logTrans lt = 8;
  inline bool has_lt() const;
  inline void clear_lt();
  static const int kLtFieldNumber = 8;
  inline const ::pb::logTrans& lt() const;
  inline ::pb::logTrans* mutable_lt();
  inline ::pb::logTrans* release_lt();
  inline void set_allocated_lt(::pb::logTrans* lt);

  // optional .pb.flinTrans flt = 9;
  inline bool has_flt() const;
  inline void clear_flt();
  static const int kFltFieldNumber = 9;
  inline const ::pb::flinTrans& flt() const;
  inline ::pb::flinTrans* mutable_flt();
  inline ::pb::flinTrans* release_flt();
  inline void set_allocated_flt(::pb::flinTrans* flt);

  // optional .pb.scaleTrans st = 10;
  inline bool has_st() const;
  inline void clear_st();
  static const int kStFieldNumber = 10;
  inline const ::pb::scaleTrans& st() const;
  inline ::pb::scaleTrans* mutable_st();
  inline ::pb::scaleTrans* release_st();
  inline void set_allocated_st(::pb::scaleTrans* st);

  // optional .pb.fasinhTrans ft = 11;
  inline bool has_ft() const;
  inline void clear_ft();
  static const int kFtFieldNumber = 11;
  inline const ::pb::fasinhTrans& ft() const;
  inline ::pb::fasinhTrans* mutable_ft();
  inline ::pb::fasinhTrans* release_ft();
  inline void set_allocated_ft(::pb::fasinhTrans* ft);

  // @@protoc_insertion_point(class_scope:pb.transformation)
 private:
  inline void set_has_caltbl();
  inline void clear_has_caltbl();
  inline void set_has_isgateonly();
  inline void clear_has_isgateonly();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_iscomputed();
  inline void clear_has_iscomputed();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_trans_type();
  inline void clear_has_trans_type();
  inline void set_has_bt();
  inline void clear_has_bt();
  inline void set_has_lt();
  inline void clear_has_lt();
  inline void set_has_flt();
  inline void clear_has_flt();
  inline void set_has_st();
  inline void clear_has_st();
  inline void set_has_ft();
  inline void clear_has_ft();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::calibrationTable* caltbl_;
  ::std::string* name_;
  ::std::string* channel_;
  bool isgateonly_;
  bool iscomputed_;
  ::google::protobuf::uint32 type_;
  ::pb::biexpTrans* bt_;
  ::pb::logTrans* lt_;
  ::pb::flinTrans* flt_;
  ::pb::scaleTrans* st_;
  ::pb::fasinhTrans* ft_;
  int trans_type_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static transformation* default_instance_;
};
// -------------------------------------------------------------------

class trans_pair : public ::google::protobuf::Message {
 public:
  trans_pair();
  virtual ~trans_pair();

  trans_pair(const trans_pair& from);

  inline trans_pair& operator=(const trans_pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trans_pair& default_instance();

  void Swap(trans_pair* other);

  // implements Message ----------------------------------------------

  trans_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trans_pair& from);
  void MergeFrom(const trans_pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint64 trans_address = 2;
  inline bool has_trans_address() const;
  inline void clear_trans_address();
  static const int kTransAddressFieldNumber = 2;
  inline ::google::protobuf::uint64 trans_address() const;
  inline void set_trans_address(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.trans_pair)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_trans_address();
  inline void clear_has_trans_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint64 trans_address_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static trans_pair* default_instance_;
};
// -------------------------------------------------------------------

class trans_local : public ::google::protobuf::Message {
 public:
  trans_local();
  virtual ~trans_local();

  trans_local(const trans_local& from);

  inline trans_local& operator=(const trans_local& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trans_local& default_instance();

  void Swap(trans_local* other);

  // implements Message ----------------------------------------------

  trans_local* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trans_local& from);
  void MergeFrom(const trans_local& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.trans_pair tp = 1;
  inline int tp_size() const;
  inline void clear_tp();
  static const int kTpFieldNumber = 1;
  inline const ::pb::trans_pair& tp(int index) const;
  inline ::pb::trans_pair* mutable_tp(int index);
  inline ::pb::trans_pair* add_tp();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::trans_pair >&
      tp() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::trans_pair >*
      mutable_tp();

  // optional string groupName = 2;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 2;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // repeated uint32 sampleIDs = 3 [packed = true];
  inline int sampleids_size() const;
  inline void clear_sampleids();
  static const int kSampleIDsFieldNumber = 3;
  inline ::google::protobuf::uint32 sampleids(int index) const;
  inline void set_sampleids(int index, ::google::protobuf::uint32 value);
  inline void add_sampleids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      sampleids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_sampleids();

  // @@protoc_insertion_point(class_scope:pb.trans_local)
 private:
  inline void set_has_groupname();
  inline void clear_has_groupname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::trans_pair > tp_;
  ::std::string* groupname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > sampleids_;
  mutable int _sampleids_cached_byte_size_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static trans_local* default_instance_;
};
// -------------------------------------------------------------------

class POPINDICES : public ::google::protobuf::Message {
 public:
  POPINDICES();
  virtual ~POPINDICES();

  POPINDICES(const POPINDICES& from);

  inline POPINDICES& operator=(const POPINDICES& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const POPINDICES& default_instance();

  void Swap(POPINDICES* other);

  // implements Message ----------------------------------------------

  POPINDICES* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const POPINDICES& from);
  void MergeFrom(const POPINDICES& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nEvents = 1;
  inline bool has_nevents() const;
  inline void clear_nevents();
  static const int kNEventsFieldNumber = 1;
  inline ::google::protobuf::uint32 nevents() const;
  inline void set_nevents(::google::protobuf::uint32 value);

  // required .pb.ind_type indtype = 2;
  inline bool has_indtype() const;
  inline void clear_indtype();
  static const int kIndtypeFieldNumber = 2;
  inline ::pb::ind_type indtype() const;
  inline void set_indtype(::pb::ind_type value);

  // repeated uint32 iInd = 3 [packed = true];
  inline int iind_size() const;
  inline void clear_iind();
  static const int kIIndFieldNumber = 3;
  inline ::google::protobuf::uint32 iind(int index) const;
  inline void set_iind(int index, ::google::protobuf::uint32 value);
  inline void add_iind(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iind() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iind();

  // optional bytes bInd = 4;
  inline bool has_bind() const;
  inline void clear_bind();
  static const int kBIndFieldNumber = 4;
  inline const ::std::string& bind() const;
  inline void set_bind(const ::std::string& value);
  inline void set_bind(const char* value);
  inline void set_bind(const void* value, size_t size);
  inline ::std::string* mutable_bind();
  inline ::std::string* release_bind();
  inline void set_allocated_bind(::std::string* bind);

  // @@protoc_insertion_point(class_scope:pb.POPINDICES)
 private:
  inline void set_has_nevents();
  inline void clear_has_nevents();
  inline void set_has_indtype();
  inline void clear_has_indtype();
  inline void set_has_bind();
  inline void clear_has_bind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 nevents_;
  int indtype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iind_;
  mutable int _iind_cached_byte_size_;
  ::std::string* bind_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static POPINDICES* default_instance_;
};
// -------------------------------------------------------------------

class nodeProperties : public ::google::protobuf::Message {
 public:
  nodeProperties();
  virtual ~nodeProperties();

  nodeProperties(const nodeProperties& from);

  inline nodeProperties& operator=(const nodeProperties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const nodeProperties& default_instance();

  void Swap(nodeProperties* other);

  // implements Message ----------------------------------------------

  nodeProperties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const nodeProperties& from);
  void MergeFrom(const nodeProperties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string thisName = 1;
  inline bool has_thisname() const;
  inline void clear_thisname();
  static const int kThisNameFieldNumber = 1;
  inline const ::std::string& thisname() const;
  inline void set_thisname(const ::std::string& value);
  inline void set_thisname(const char* value);
  inline void set_thisname(const char* value, size_t size);
  inline ::std::string* mutable_thisname();
  inline ::std::string* release_thisname();
  inline void set_allocated_thisname(::std::string* thisname);

  // repeated .pb.POPSTATS fjStats = 2;
  inline int fjstats_size() const;
  inline void clear_fjstats();
  static const int kFjStatsFieldNumber = 2;
  inline const ::pb::POPSTATS& fjstats(int index) const;
  inline ::pb::POPSTATS* mutable_fjstats(int index);
  inline ::pb::POPSTATS* add_fjstats();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >&
      fjstats() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >*
      mutable_fjstats();

  // repeated .pb.POPSTATS fcStats = 3;
  inline int fcstats_size() const;
  inline void clear_fcstats();
  static const int kFcStatsFieldNumber = 3;
  inline const ::pb::POPSTATS& fcstats(int index) const;
  inline ::pb::POPSTATS* mutable_fcstats(int index);
  inline ::pb::POPSTATS* add_fcstats();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >&
      fcstats() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >*
      mutable_fcstats();

  // required bool hidden = 4;
  inline bool has_hidden() const;
  inline void clear_hidden();
  static const int kHiddenFieldNumber = 4;
  inline bool hidden() const;
  inline void set_hidden(bool value);

  // optional .pb.POPINDICES indices = 5;
  inline bool has_indices() const;
  inline void clear_indices();
  static const int kIndicesFieldNumber = 5;
  inline const ::pb::POPINDICES& indices() const;
  inline ::pb::POPINDICES* mutable_indices();
  inline ::pb::POPINDICES* release_indices();
  inline void set_allocated_indices(::pb::POPINDICES* indices);

  // optional .pb.gate thisGate = 6;
  inline bool has_thisgate() const;
  inline void clear_thisgate();
  static const int kThisGateFieldNumber = 6;
  inline const ::pb::gate& thisgate() const;
  inline ::pb::gate* mutable_thisgate();
  inline ::pb::gate* release_thisgate();
  inline void set_allocated_thisgate(::pb::gate* thisgate);

  // @@protoc_insertion_point(class_scope:pb.nodeProperties)
 private:
  inline void set_has_thisname();
  inline void clear_has_thisname();
  inline void set_has_hidden();
  inline void clear_has_hidden();
  inline void set_has_indices();
  inline void clear_has_indices();
  inline void set_has_thisgate();
  inline void clear_has_thisgate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* thisname_;
  ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS > fjstats_;
  ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS > fcstats_;
  ::pb::POPINDICES* indices_;
  ::pb::gate* thisgate_;
  bool hidden_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static nodeProperties* default_instance_;
};
// -------------------------------------------------------------------

class treeNodes : public ::google::protobuf::Message {
 public:
  treeNodes();
  virtual ~treeNodes();

  treeNodes(const treeNodes& from);

  inline treeNodes& operator=(const treeNodes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const treeNodes& default_instance();

  void Swap(treeNodes* other);

  // implements Message ----------------------------------------------

  treeNodes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const treeNodes& from);
  void MergeFrom(const treeNodes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.nodeProperties node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::pb::nodeProperties& node() const;
  inline ::pb::nodeProperties* mutable_node();
  inline ::pb::nodeProperties* release_node();
  inline void set_allocated_node(::pb::nodeProperties* node);

  // optional uint32 parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline ::google::protobuf::uint32 parent() const;
  inline void set_parent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.treeNodes)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::nodeProperties* node_;
  ::google::protobuf::uint32 parent_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static treeNodes* default_instance_;
};
// -------------------------------------------------------------------

class populationTree : public ::google::protobuf::Message {
 public:
  populationTree();
  virtual ~populationTree();

  populationTree(const populationTree& from);

  inline populationTree& operator=(const populationTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const populationTree& default_instance();

  void Swap(populationTree* other);

  // implements Message ----------------------------------------------

  populationTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const populationTree& from);
  void MergeFrom(const populationTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.treeNodes node = 1;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::pb::treeNodes& node(int index) const;
  inline ::pb::treeNodes* mutable_node(int index);
  inline ::pb::treeNodes* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::treeNodes >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::treeNodes >*
      mutable_node();

  // @@protoc_insertion_point(class_scope:pb.populationTree)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::treeNodes > node_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static populationTree* default_instance_;
};
// -------------------------------------------------------------------

class COMP : public ::google::protobuf::Message {
 public:
  COMP();
  virtual ~COMP();

  COMP(const COMP& from);

  inline COMP& operator=(const COMP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const COMP& default_instance();

  void Swap(COMP* other);

  // implements Message ----------------------------------------------

  COMP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const COMP& from);
  void MergeFrom(const COMP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string prefix = 2;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 2;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // optional string suffix = 3;
  inline bool has_suffix() const;
  inline void clear_suffix();
  static const int kSuffixFieldNumber = 3;
  inline const ::std::string& suffix() const;
  inline void set_suffix(const ::std::string& value);
  inline void set_suffix(const char* value);
  inline void set_suffix(const char* value, size_t size);
  inline ::std::string* mutable_suffix();
  inline ::std::string* release_suffix();
  inline void set_allocated_suffix(::std::string* suffix);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string comment = 5;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 5;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated string marker = 6;
  inline int marker_size() const;
  inline void clear_marker();
  static const int kMarkerFieldNumber = 6;
  inline const ::std::string& marker(int index) const;
  inline ::std::string* mutable_marker(int index);
  inline void set_marker(int index, const ::std::string& value);
  inline void set_marker(int index, const char* value);
  inline void set_marker(int index, const char* value, size_t size);
  inline ::std::string* add_marker();
  inline void add_marker(const ::std::string& value);
  inline void add_marker(const char* value);
  inline void add_marker(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& marker() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_marker();

  // repeated float spillOver = 7;
  inline int spillover_size() const;
  inline void clear_spillover();
  static const int kSpillOverFieldNumber = 7;
  inline float spillover(int index) const;
  inline void set_spillover(int index, float value);
  inline void add_spillover(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      spillover() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_spillover();

  // @@protoc_insertion_point(class_scope:pb.COMP)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_suffix();
  inline void clear_has_suffix();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cid_;
  ::std::string* prefix_;
  ::std::string* suffix_;
  ::std::string* name_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::std::string> marker_;
  ::google::protobuf::RepeatedField< float > spillover_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static COMP* default_instance_;
};
// -------------------------------------------------------------------

class PARAM : public ::google::protobuf::Message {
 public:
  PARAM();
  virtual ~PARAM();

  PARAM(const PARAM& from);

  inline PARAM& operator=(const PARAM& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PARAM& default_instance();

  void Swap(PARAM* other);

  // implements Message ----------------------------------------------

  PARAM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PARAM& from);
  void MergeFrom(const PARAM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string param = 1;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // optional bool log = 2;
  inline bool has_log() const;
  inline void clear_log();
  static const int kLogFieldNumber = 2;
  inline bool log() const;
  inline void set_log(bool value);

  // optional uint32 range = 3;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 3;
  inline ::google::protobuf::uint32 range() const;
  inline void set_range(::google::protobuf::uint32 value);

  // optional uint32 highValue = 4;
  inline bool has_highvalue() const;
  inline void clear_highvalue();
  static const int kHighValueFieldNumber = 4;
  inline ::google::protobuf::uint32 highvalue() const;
  inline void set_highvalue(::google::protobuf::uint32 value);

  // optional uint32 calibrationIndex = 5;
  inline bool has_calibrationindex() const;
  inline void clear_calibrationindex();
  static const int kCalibrationIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 calibrationindex() const;
  inline void set_calibrationindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.PARAM)
 private:
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_log();
  inline void clear_has_log();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_highvalue();
  inline void clear_has_highvalue();
  inline void set_has_calibrationindex();
  inline void clear_has_calibrationindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* param_;
  bool log_;
  ::google::protobuf::uint32 range_;
  ::google::protobuf::uint32 highvalue_;
  ::google::protobuf::uint32 calibrationindex_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static PARAM* default_instance_;
};
// -------------------------------------------------------------------

class GatingHierarchy : public ::google::protobuf::Message {
 public:
  GatingHierarchy();
  virtual ~GatingHierarchy();

  GatingHierarchy(const GatingHierarchy& from);

  inline GatingHierarchy& operator=(const GatingHierarchy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GatingHierarchy& default_instance();

  void Swap(GatingHierarchy* other);

  // implements Message ----------------------------------------------

  GatingHierarchy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GatingHierarchy& from);
  void MergeFrom(const GatingHierarchy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.populationTree tree = 2;
  inline bool has_tree() const;
  inline void clear_tree();
  static const int kTreeFieldNumber = 2;
  inline const ::pb::populationTree& tree() const;
  inline ::pb::populationTree* mutable_tree();
  inline ::pb::populationTree* release_tree();
  inline void set_allocated_tree(::pb::populationTree* tree);

  // optional .pb.COMP comp = 1;
  inline bool has_comp() const;
  inline void clear_comp();
  static const int kCompFieldNumber = 1;
  inline const ::pb::COMP& comp() const;
  inline ::pb::COMP* mutable_comp();
  inline ::pb::COMP* release_comp();
  inline void set_allocated_comp(::pb::COMP* comp);

  // optional bool isLoaded = 3;
  inline bool has_isloaded() const;
  inline void clear_isloaded();
  static const int kIsLoadedFieldNumber = 3;
  inline bool isloaded() const;
  inline void set_isloaded(bool value);

  // repeated .pb.PARAM transFlag = 4;
  inline int transflag_size() const;
  inline void clear_transflag();
  static const int kTransFlagFieldNumber = 4;
  inline const ::pb::PARAM& transflag(int index) const;
  inline ::pb::PARAM* mutable_transflag(int index);
  inline ::pb::PARAM* add_transflag();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PARAM >&
      transflag() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PARAM >*
      mutable_transflag();

  // optional .pb.trans_local trans = 5;
  inline bool has_trans() const;
  inline void clear_trans();
  static const int kTransFieldNumber = 5;
  inline const ::pb::trans_local& trans() const;
  inline ::pb::trans_local* mutable_trans();
  inline ::pb::trans_local* release_trans();
  inline void set_allocated_trans(::pb::trans_local* trans);

  // @@protoc_insertion_point(class_scope:pb.GatingHierarchy)
 private:
  inline void set_has_tree();
  inline void clear_has_tree();
  inline void set_has_comp();
  inline void clear_has_comp();
  inline void set_has_isloaded();
  inline void clear_has_isloaded();
  inline void set_has_trans();
  inline void clear_has_trans();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::populationTree* tree_;
  ::pb::COMP* comp_;
  ::google::protobuf::RepeatedPtrField< ::pb::PARAM > transflag_;
  ::pb::trans_local* trans_;
  bool isloaded_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static GatingHierarchy* default_instance_;
};
// -------------------------------------------------------------------

class TRANS_TBL : public ::google::protobuf::Message {
 public:
  TRANS_TBL();
  virtual ~TRANS_TBL();

  TRANS_TBL(const TRANS_TBL& from);

  inline TRANS_TBL& operator=(const TRANS_TBL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRANS_TBL& default_instance();

  void Swap(TRANS_TBL* other);

  // implements Message ----------------------------------------------

  TRANS_TBL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRANS_TBL& from);
  void MergeFrom(const TRANS_TBL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 trans_address = 1;
  inline bool has_trans_address() const;
  inline void clear_trans_address();
  static const int kTransAddressFieldNumber = 1;
  inline ::google::protobuf::uint64 trans_address() const;
  inline void set_trans_address(::google::protobuf::uint64 value);

  // optional .pb.transformation trans = 2;
  inline bool has_trans() const;
  inline void clear_trans();
  static const int kTransFieldNumber = 2;
  inline const ::pb::transformation& trans() const;
  inline ::pb::transformation* mutable_trans();
  inline ::pb::transformation* release_trans();
  inline void set_allocated_trans(::pb::transformation* trans);

  // @@protoc_insertion_point(class_scope:pb.TRANS_TBL)
 private:
  inline void set_has_trans_address();
  inline void clear_has_trans_address();
  inline void set_has_trans();
  inline void clear_has_trans();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 trans_address_;
  ::pb::transformation* trans_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static TRANS_TBL* default_instance_;
};
// -------------------------------------------------------------------

class GatingSet : public ::google::protobuf::Message {
 public:
  GatingSet();
  virtual ~GatingSet();

  GatingSet(const GatingSet& from);

  inline GatingSet& operator=(const GatingSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GatingSet& default_instance();

  void Swap(GatingSet* other);

  // implements Message ----------------------------------------------

  GatingSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GatingSet& from);
  void MergeFrom(const GatingSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.TRANS_TBL trans_tbl = 2;
  inline int trans_tbl_size() const;
  inline void clear_trans_tbl();
  static const int kTransTblFieldNumber = 2;
  inline const ::pb::TRANS_TBL& trans_tbl(int index) const;
  inline ::pb::TRANS_TBL* mutable_trans_tbl(int index);
  inline ::pb::TRANS_TBL* add_trans_tbl();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TRANS_TBL >&
      trans_tbl() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TRANS_TBL >*
      mutable_trans_tbl();

  // repeated string sampleName = 1;
  inline int samplename_size() const;
  inline void clear_samplename();
  static const int kSampleNameFieldNumber = 1;
  inline const ::std::string& samplename(int index) const;
  inline ::std::string* mutable_samplename(int index);
  inline void set_samplename(int index, const ::std::string& value);
  inline void set_samplename(int index, const char* value);
  inline void set_samplename(int index, const char* value, size_t size);
  inline ::std::string* add_samplename();
  inline void add_samplename(const ::std::string& value);
  inline void add_samplename(const char* value);
  inline void add_samplename(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& samplename() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_samplename();

  // optional uint64 globalBiExpTrans = 3;
  inline bool has_globalbiexptrans() const;
  inline void clear_globalbiexptrans();
  static const int kGlobalBiExpTransFieldNumber = 3;
  inline ::google::protobuf::uint64 globalbiexptrans() const;
  inline void set_globalbiexptrans(::google::protobuf::uint64 value);

  // optional uint64 globalLinTrans = 4;
  inline bool has_globallintrans() const;
  inline void clear_globallintrans();
  static const int kGlobalLinTransFieldNumber = 4;
  inline ::google::protobuf::uint64 globallintrans() const;
  inline void set_globallintrans(::google::protobuf::uint64 value);

  // repeated .pb.trans_local gTrans = 5;
  inline int gtrans_size() const;
  inline void clear_gtrans();
  static const int kGTransFieldNumber = 5;
  inline const ::pb::trans_local& gtrans(int index) const;
  inline ::pb::trans_local* mutable_gtrans(int index);
  inline ::pb::trans_local* add_gtrans();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::trans_local >&
      gtrans() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::trans_local >*
      mutable_gtrans();

  // @@protoc_insertion_point(class_scope:pb.GatingSet)
 private:
  inline void set_has_globalbiexptrans();
  inline void clear_has_globalbiexptrans();
  inline void set_has_globallintrans();
  inline void clear_has_globallintrans();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::TRANS_TBL > trans_tbl_;
  ::google::protobuf::RepeatedPtrField< ::std::string> samplename_;
  ::google::protobuf::uint64 globalbiexptrans_;
  ::google::protobuf::uint64 globallintrans_;
  ::google::protobuf::RepeatedPtrField< ::pb::trans_local > gtrans_;
  friend void  protobuf_AddDesc_GatingSet_2eproto();
  friend void protobuf_AssignDesc_GatingSet_2eproto();
  friend void protobuf_ShutdownFile_GatingSet_2eproto();

  void InitAsDefaultInstance();
  static GatingSet* default_instance_;
};
// ===================================================================


// ===================================================================

// paramRange

// required string name = 1;
inline bool paramRange::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void paramRange::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void paramRange::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void paramRange::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& paramRange::name() const {
  // @@protoc_insertion_point(field_get:pb.paramRange.name)
  return *name_;
}
inline void paramRange::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.paramRange.name)
}
inline void paramRange::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.paramRange.name)
}
inline void paramRange::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.paramRange.name)
}
inline ::std::string* paramRange::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.paramRange.name)
  return name_;
}
inline ::std::string* paramRange::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void paramRange::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.paramRange.name)
}

// required float min = 2;
inline bool paramRange::has_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void paramRange::set_has_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void paramRange::clear_has_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void paramRange::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline float paramRange::min() const {
  // @@protoc_insertion_point(field_get:pb.paramRange.min)
  return min_;
}
inline void paramRange::set_min(float value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:pb.paramRange.min)
}

// required float max = 3;
inline bool paramRange::has_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void paramRange::set_has_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void paramRange::clear_has_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void paramRange::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline float paramRange::max() const {
  // @@protoc_insertion_point(field_get:pb.paramRange.max)
  return max_;
}
inline void paramRange::set_max(float value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:pb.paramRange.max)
}

// -------------------------------------------------------------------

// rangeGate

// required .pb.paramRange param = 1;
inline bool rangeGate::has_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rangeGate::set_has_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rangeGate::clear_has_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rangeGate::clear_param() {
  if (param_ != NULL) param_->::pb::paramRange::Clear();
  clear_has_param();
}
inline const ::pb::paramRange& rangeGate::param() const {
  // @@protoc_insertion_point(field_get:pb.rangeGate.param)
  return param_ != NULL ? *param_ : *default_instance_->param_;
}
inline ::pb::paramRange* rangeGate::mutable_param() {
  set_has_param();
  if (param_ == NULL) param_ = new ::pb::paramRange;
  // @@protoc_insertion_point(field_mutable:pb.rangeGate.param)
  return param_;
}
inline ::pb::paramRange* rangeGate::release_param() {
  clear_has_param();
  ::pb::paramRange* temp = param_;
  param_ = NULL;
  return temp;
}
inline void rangeGate::set_allocated_param(::pb::paramRange* param) {
  delete param_;
  param_ = param;
  if (param) {
    set_has_param();
  } else {
    clear_has_param();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.rangeGate.param)
}

// -------------------------------------------------------------------

// paramPoly

// repeated string params = 1;
inline int paramPoly::params_size() const {
  return params_.size();
}
inline void paramPoly::clear_params() {
  params_.Clear();
}
inline const ::std::string& paramPoly::params(int index) const {
  // @@protoc_insertion_point(field_get:pb.paramPoly.params)
  return params_.Get(index);
}
inline ::std::string* paramPoly::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:pb.paramPoly.params)
  return params_.Mutable(index);
}
inline void paramPoly::set_params(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.paramPoly.params)
  params_.Mutable(index)->assign(value);
}
inline void paramPoly::set_params(int index, const char* value) {
  params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.paramPoly.params)
}
inline void paramPoly::set_params(int index, const char* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.paramPoly.params)
}
inline ::std::string* paramPoly::add_params() {
  return params_.Add();
}
inline void paramPoly::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.paramPoly.params)
}
inline void paramPoly::add_params(const char* value) {
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.paramPoly.params)
}
inline void paramPoly::add_params(const char* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.paramPoly.params)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
paramPoly::params() const {
  // @@protoc_insertion_point(field_list:pb.paramPoly.params)
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
paramPoly::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:pb.paramPoly.params)
  return &params_;
}

// repeated .pb.coordinate vertices = 2;
inline int paramPoly::vertices_size() const {
  return vertices_.size();
}
inline void paramPoly::clear_vertices() {
  vertices_.Clear();
}
inline const ::pb::coordinate& paramPoly::vertices(int index) const {
  // @@protoc_insertion_point(field_get:pb.paramPoly.vertices)
  return vertices_.Get(index);
}
inline ::pb::coordinate* paramPoly::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:pb.paramPoly.vertices)
  return vertices_.Mutable(index);
}
inline ::pb::coordinate* paramPoly::add_vertices() {
  // @@protoc_insertion_point(field_add:pb.paramPoly.vertices)
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::coordinate >&
paramPoly::vertices() const {
  // @@protoc_insertion_point(field_list:pb.paramPoly.vertices)
  return vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::coordinate >*
paramPoly::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:pb.paramPoly.vertices)
  return &vertices_;
}

// -------------------------------------------------------------------

// polygonGate

// required .pb.paramPoly param = 1;
inline bool polygonGate::has_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void polygonGate::set_has_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void polygonGate::clear_has_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void polygonGate::clear_param() {
  if (param_ != NULL) param_->::pb::paramPoly::Clear();
  clear_has_param();
}
inline const ::pb::paramPoly& polygonGate::param() const {
  // @@protoc_insertion_point(field_get:pb.polygonGate.param)
  return param_ != NULL ? *param_ : *default_instance_->param_;
}
inline ::pb::paramPoly* polygonGate::mutable_param() {
  set_has_param();
  if (param_ == NULL) param_ = new ::pb::paramPoly;
  // @@protoc_insertion_point(field_mutable:pb.polygonGate.param)
  return param_;
}
inline ::pb::paramPoly* polygonGate::release_param() {
  clear_has_param();
  ::pb::paramPoly* temp = param_;
  param_ = NULL;
  return temp;
}
inline void polygonGate::set_allocated_param(::pb::paramPoly* param) {
  delete param_;
  param_ = param;
  if (param) {
    set_has_param();
  } else {
    clear_has_param();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.polygonGate.param)
}

// -------------------------------------------------------------------

// coordinate

// required float x = 1;
inline bool coordinate::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void coordinate::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void coordinate::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void coordinate::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float coordinate::x() const {
  // @@protoc_insertion_point(field_get:pb.coordinate.x)
  return x_;
}
inline void coordinate::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:pb.coordinate.x)
}

// required float y = 2;
inline bool coordinate::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void coordinate::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void coordinate::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void coordinate::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float coordinate::y() const {
  // @@protoc_insertion_point(field_get:pb.coordinate.y)
  return y_;
}
inline void coordinate::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:pb.coordinate.y)
}

// -------------------------------------------------------------------

// ellipseGate

// required .pb.coordinate mu = 1;
inline bool ellipseGate::has_mu() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ellipseGate::set_has_mu() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ellipseGate::clear_has_mu() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ellipseGate::clear_mu() {
  if (mu_ != NULL) mu_->::pb::coordinate::Clear();
  clear_has_mu();
}
inline const ::pb::coordinate& ellipseGate::mu() const {
  // @@protoc_insertion_point(field_get:pb.ellipseGate.mu)
  return mu_ != NULL ? *mu_ : *default_instance_->mu_;
}
inline ::pb::coordinate* ellipseGate::mutable_mu() {
  set_has_mu();
  if (mu_ == NULL) mu_ = new ::pb::coordinate;
  // @@protoc_insertion_point(field_mutable:pb.ellipseGate.mu)
  return mu_;
}
inline ::pb::coordinate* ellipseGate::release_mu() {
  clear_has_mu();
  ::pb::coordinate* temp = mu_;
  mu_ = NULL;
  return temp;
}
inline void ellipseGate::set_allocated_mu(::pb::coordinate* mu) {
  delete mu_;
  mu_ = mu;
  if (mu) {
    set_has_mu();
  } else {
    clear_has_mu();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ellipseGate.mu)
}

// repeated .pb.coordinate cov = 2;
inline int ellipseGate::cov_size() const {
  return cov_.size();
}
inline void ellipseGate::clear_cov() {
  cov_.Clear();
}
inline const ::pb::coordinate& ellipseGate::cov(int index) const {
  // @@protoc_insertion_point(field_get:pb.ellipseGate.cov)
  return cov_.Get(index);
}
inline ::pb::coordinate* ellipseGate::mutable_cov(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ellipseGate.cov)
  return cov_.Mutable(index);
}
inline ::pb::coordinate* ellipseGate::add_cov() {
  // @@protoc_insertion_point(field_add:pb.ellipseGate.cov)
  return cov_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::coordinate >&
ellipseGate::cov() const {
  // @@protoc_insertion_point(field_list:pb.ellipseGate.cov)
  return cov_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::coordinate >*
ellipseGate::mutable_cov() {
  // @@protoc_insertion_point(field_mutable_list:pb.ellipseGate.cov)
  return &cov_;
}

// repeated .pb.coordinate antipodal_vertices = 3;
inline int ellipseGate::antipodal_vertices_size() const {
  return antipodal_vertices_.size();
}
inline void ellipseGate::clear_antipodal_vertices() {
  antipodal_vertices_.Clear();
}
inline const ::pb::coordinate& ellipseGate::antipodal_vertices(int index) const {
  // @@protoc_insertion_point(field_get:pb.ellipseGate.antipodal_vertices)
  return antipodal_vertices_.Get(index);
}
inline ::pb::coordinate* ellipseGate::mutable_antipodal_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ellipseGate.antipodal_vertices)
  return antipodal_vertices_.Mutable(index);
}
inline ::pb::coordinate* ellipseGate::add_antipodal_vertices() {
  // @@protoc_insertion_point(field_add:pb.ellipseGate.antipodal_vertices)
  return antipodal_vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::coordinate >&
ellipseGate::antipodal_vertices() const {
  // @@protoc_insertion_point(field_list:pb.ellipseGate.antipodal_vertices)
  return antipodal_vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::coordinate >*
ellipseGate::mutable_antipodal_vertices() {
  // @@protoc_insertion_point(field_mutable_list:pb.ellipseGate.antipodal_vertices)
  return &antipodal_vertices_;
}

// optional float dist = 4;
inline bool ellipseGate::has_dist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ellipseGate::set_has_dist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ellipseGate::clear_has_dist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ellipseGate::clear_dist() {
  dist_ = 0;
  clear_has_dist();
}
inline float ellipseGate::dist() const {
  // @@protoc_insertion_point(field_get:pb.ellipseGate.dist)
  return dist_;
}
inline void ellipseGate::set_dist(float value) {
  set_has_dist();
  dist_ = value;
  // @@protoc_insertion_point(field_set:pb.ellipseGate.dist)
}

// -------------------------------------------------------------------

// BOOL_GATE_OP

// repeated string path = 1;
inline int BOOL_GATE_OP::path_size() const {
  return path_.size();
}
inline void BOOL_GATE_OP::clear_path() {
  path_.Clear();
}
inline const ::std::string& BOOL_GATE_OP::path(int index) const {
  // @@protoc_insertion_point(field_get:pb.BOOL_GATE_OP.path)
  return path_.Get(index);
}
inline ::std::string* BOOL_GATE_OP::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BOOL_GATE_OP.path)
  return path_.Mutable(index);
}
inline void BOOL_GATE_OP::set_path(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.BOOL_GATE_OP.path)
  path_.Mutable(index)->assign(value);
}
inline void BOOL_GATE_OP::set_path(int index, const char* value) {
  path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.BOOL_GATE_OP.path)
}
inline void BOOL_GATE_OP::set_path(int index, const char* value, size_t size) {
  path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.BOOL_GATE_OP.path)
}
inline ::std::string* BOOL_GATE_OP::add_path() {
  return path_.Add();
}
inline void BOOL_GATE_OP::add_path(const ::std::string& value) {
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.BOOL_GATE_OP.path)
}
inline void BOOL_GATE_OP::add_path(const char* value) {
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.BOOL_GATE_OP.path)
}
inline void BOOL_GATE_OP::add_path(const char* value, size_t size) {
  path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.BOOL_GATE_OP.path)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BOOL_GATE_OP::path() const {
  // @@protoc_insertion_point(field_list:pb.BOOL_GATE_OP.path)
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BOOL_GATE_OP::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:pb.BOOL_GATE_OP.path)
  return &path_;
}

// required uint32 op = 2;
inline bool BOOL_GATE_OP::has_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BOOL_GATE_OP::set_has_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BOOL_GATE_OP::clear_has_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BOOL_GATE_OP::clear_op() {
  op_ = 0u;
  clear_has_op();
}
inline ::google::protobuf::uint32 BOOL_GATE_OP::op() const {
  // @@protoc_insertion_point(field_get:pb.BOOL_GATE_OP.op)
  return op_;
}
inline void BOOL_GATE_OP::set_op(::google::protobuf::uint32 value) {
  set_has_op();
  op_ = value;
  // @@protoc_insertion_point(field_set:pb.BOOL_GATE_OP.op)
}

// required bool isNot = 3;
inline bool BOOL_GATE_OP::has_isnot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BOOL_GATE_OP::set_has_isnot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BOOL_GATE_OP::clear_has_isnot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BOOL_GATE_OP::clear_isnot() {
  isnot_ = false;
  clear_has_isnot();
}
inline bool BOOL_GATE_OP::isnot() const {
  // @@protoc_insertion_point(field_get:pb.BOOL_GATE_OP.isNot)
  return isnot_;
}
inline void BOOL_GATE_OP::set_isnot(bool value) {
  set_has_isnot();
  isnot_ = value;
  // @@protoc_insertion_point(field_set:pb.BOOL_GATE_OP.isNot)
}

// -------------------------------------------------------------------

// boolGate

// repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
inline int boolGate::boolopspec_size() const {
  return boolopspec_.size();
}
inline void boolGate::clear_boolopspec() {
  boolopspec_.Clear();
}
inline const ::pb::BOOL_GATE_OP& boolGate::boolopspec(int index) const {
  // @@protoc_insertion_point(field_get:pb.boolGate.boolOpSpec)
  return boolopspec_.Get(index);
}
inline ::pb::BOOL_GATE_OP* boolGate::mutable_boolopspec(int index) {
  // @@protoc_insertion_point(field_mutable:pb.boolGate.boolOpSpec)
  return boolopspec_.Mutable(index);
}
inline ::pb::BOOL_GATE_OP* boolGate::add_boolopspec() {
  // @@protoc_insertion_point(field_add:pb.boolGate.boolOpSpec)
  return boolopspec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BOOL_GATE_OP >&
boolGate::boolopspec() const {
  // @@protoc_insertion_point(field_list:pb.boolGate.boolOpSpec)
  return boolopspec_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BOOL_GATE_OP >*
boolGate::mutable_boolopspec() {
  // @@protoc_insertion_point(field_mutable_list:pb.boolGate.boolOpSpec)
  return &boolopspec_;
}

// -------------------------------------------------------------------

// gate

// required bool neg = 1;
inline bool gate::has_neg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gate::set_has_neg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gate::clear_has_neg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gate::clear_neg() {
  neg_ = false;
  clear_has_neg();
}
inline bool gate::neg() const {
  // @@protoc_insertion_point(field_get:pb.gate.neg)
  return neg_;
}
inline void gate::set_neg(bool value) {
  set_has_neg();
  neg_ = value;
  // @@protoc_insertion_point(field_set:pb.gate.neg)
}

// required bool isTransformed = 2;
inline bool gate::has_istransformed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gate::set_has_istransformed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gate::clear_has_istransformed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gate::clear_istransformed() {
  istransformed_ = false;
  clear_has_istransformed();
}
inline bool gate::istransformed() const {
  // @@protoc_insertion_point(field_get:pb.gate.isTransformed)
  return istransformed_;
}
inline void gate::set_istransformed(bool value) {
  set_has_istransformed();
  istransformed_ = value;
  // @@protoc_insertion_point(field_set:pb.gate.isTransformed)
}

// required bool isGained = 3;
inline bool gate::has_isgained() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gate::set_has_isgained() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gate::clear_has_isgained() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gate::clear_isgained() {
  isgained_ = false;
  clear_has_isgained();
}
inline bool gate::isgained() const {
  // @@protoc_insertion_point(field_get:pb.gate.isGained)
  return isgained_;
}
inline void gate::set_isgained(bool value) {
  set_has_isgained();
  isgained_ = value;
  // @@protoc_insertion_point(field_set:pb.gate.isGained)
}

// required .pb.GATE_TYPE type = 4;
inline bool gate::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gate::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gate::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gate::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pb::GATE_TYPE gate::type() const {
  // @@protoc_insertion_point(field_get:pb.gate.type)
  return static_cast< ::pb::GATE_TYPE >(type_);
}
inline void gate::set_type(::pb::GATE_TYPE value) {
  assert(::pb::GATE_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.gate.type)
}

// optional .pb.rangeGate rg = 5;
inline bool gate::has_rg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gate::set_has_rg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gate::clear_has_rg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gate::clear_rg() {
  if (rg_ != NULL) rg_->::pb::rangeGate::Clear();
  clear_has_rg();
}
inline const ::pb::rangeGate& gate::rg() const {
  // @@protoc_insertion_point(field_get:pb.gate.rg)
  return rg_ != NULL ? *rg_ : *default_instance_->rg_;
}
inline ::pb::rangeGate* gate::mutable_rg() {
  set_has_rg();
  if (rg_ == NULL) rg_ = new ::pb::rangeGate;
  // @@protoc_insertion_point(field_mutable:pb.gate.rg)
  return rg_;
}
inline ::pb::rangeGate* gate::release_rg() {
  clear_has_rg();
  ::pb::rangeGate* temp = rg_;
  rg_ = NULL;
  return temp;
}
inline void gate::set_allocated_rg(::pb::rangeGate* rg) {
  delete rg_;
  rg_ = rg;
  if (rg) {
    set_has_rg();
  } else {
    clear_has_rg();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.gate.rg)
}

// optional .pb.polygonGate pg = 6;
inline bool gate::has_pg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gate::set_has_pg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gate::clear_has_pg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gate::clear_pg() {
  if (pg_ != NULL) pg_->::pb::polygonGate::Clear();
  clear_has_pg();
}
inline const ::pb::polygonGate& gate::pg() const {
  // @@protoc_insertion_point(field_get:pb.gate.pg)
  return pg_ != NULL ? *pg_ : *default_instance_->pg_;
}
inline ::pb::polygonGate* gate::mutable_pg() {
  set_has_pg();
  if (pg_ == NULL) pg_ = new ::pb::polygonGate;
  // @@protoc_insertion_point(field_mutable:pb.gate.pg)
  return pg_;
}
inline ::pb::polygonGate* gate::release_pg() {
  clear_has_pg();
  ::pb::polygonGate* temp = pg_;
  pg_ = NULL;
  return temp;
}
inline void gate::set_allocated_pg(::pb::polygonGate* pg) {
  delete pg_;
  pg_ = pg;
  if (pg) {
    set_has_pg();
  } else {
    clear_has_pg();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.gate.pg)
}

// optional .pb.ellipseGate eg = 7;
inline bool gate::has_eg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void gate::set_has_eg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void gate::clear_has_eg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void gate::clear_eg() {
  if (eg_ != NULL) eg_->::pb::ellipseGate::Clear();
  clear_has_eg();
}
inline const ::pb::ellipseGate& gate::eg() const {
  // @@protoc_insertion_point(field_get:pb.gate.eg)
  return eg_ != NULL ? *eg_ : *default_instance_->eg_;
}
inline ::pb::ellipseGate* gate::mutable_eg() {
  set_has_eg();
  if (eg_ == NULL) eg_ = new ::pb::ellipseGate;
  // @@protoc_insertion_point(field_mutable:pb.gate.eg)
  return eg_;
}
inline ::pb::ellipseGate* gate::release_eg() {
  clear_has_eg();
  ::pb::ellipseGate* temp = eg_;
  eg_ = NULL;
  return temp;
}
inline void gate::set_allocated_eg(::pb::ellipseGate* eg) {
  delete eg_;
  eg_ = eg;
  if (eg) {
    set_has_eg();
  } else {
    clear_has_eg();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.gate.eg)
}

// optional .pb.boolGate bg = 8;
inline bool gate::has_bg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void gate::set_has_bg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void gate::clear_has_bg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void gate::clear_bg() {
  if (bg_ != NULL) bg_->::pb::boolGate::Clear();
  clear_has_bg();
}
inline const ::pb::boolGate& gate::bg() const {
  // @@protoc_insertion_point(field_get:pb.gate.bg)
  return bg_ != NULL ? *bg_ : *default_instance_->bg_;
}
inline ::pb::boolGate* gate::mutable_bg() {
  set_has_bg();
  if (bg_ == NULL) bg_ = new ::pb::boolGate;
  // @@protoc_insertion_point(field_mutable:pb.gate.bg)
  return bg_;
}
inline ::pb::boolGate* gate::release_bg() {
  clear_has_bg();
  ::pb::boolGate* temp = bg_;
  bg_ = NULL;
  return temp;
}
inline void gate::set_allocated_bg(::pb::boolGate* bg) {
  delete bg_;
  bg_ = bg;
  if (bg) {
    set_has_bg();
  } else {
    clear_has_bg();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.gate.bg)
}

// -------------------------------------------------------------------

// POPSTATS

// required string statType = 1;
inline bool POPSTATS::has_stattype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void POPSTATS::set_has_stattype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void POPSTATS::clear_has_stattype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void POPSTATS::clear_stattype() {
  if (stattype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_->clear();
  }
  clear_has_stattype();
}
inline const ::std::string& POPSTATS::stattype() const {
  // @@protoc_insertion_point(field_get:pb.POPSTATS.statType)
  return *stattype_;
}
inline void POPSTATS::set_stattype(const ::std::string& value) {
  set_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_ = new ::std::string;
  }
  stattype_->assign(value);
  // @@protoc_insertion_point(field_set:pb.POPSTATS.statType)
}
inline void POPSTATS::set_stattype(const char* value) {
  set_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_ = new ::std::string;
  }
  stattype_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.POPSTATS.statType)
}
inline void POPSTATS::set_stattype(const char* value, size_t size) {
  set_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_ = new ::std::string;
  }
  stattype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.POPSTATS.statType)
}
inline ::std::string* POPSTATS::mutable_stattype() {
  set_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stattype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.POPSTATS.statType)
  return stattype_;
}
inline ::std::string* POPSTATS::release_stattype() {
  clear_has_stattype();
  if (stattype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stattype_;
    stattype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void POPSTATS::set_allocated_stattype(::std::string* stattype) {
  if (stattype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stattype_;
  }
  if (stattype) {
    set_has_stattype();
    stattype_ = stattype;
  } else {
    clear_has_stattype();
    stattype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.POPSTATS.statType)
}

// required float statVal = 2;
inline bool POPSTATS::has_statval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void POPSTATS::set_has_statval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void POPSTATS::clear_has_statval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void POPSTATS::clear_statval() {
  statval_ = 0;
  clear_has_statval();
}
inline float POPSTATS::statval() const {
  // @@protoc_insertion_point(field_get:pb.POPSTATS.statVal)
  return statval_;
}
inline void POPSTATS::set_statval(float value) {
  set_has_statval();
  statval_ = value;
  // @@protoc_insertion_point(field_set:pb.POPSTATS.statVal)
}

// -------------------------------------------------------------------

// calibrationTable

// repeated float x = 1 [packed = true];
inline int calibrationTable::x_size() const {
  return x_.size();
}
inline void calibrationTable::clear_x() {
  x_.Clear();
}
inline float calibrationTable::x(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.x)
  return x_.Get(index);
}
inline void calibrationTable::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.x)
}
inline void calibrationTable::add_x(float value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.x)
}
inline const ::google::protobuf::RepeatedField< float >&
calibrationTable::x() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
calibrationTable::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.x)
  return &x_;
}

// repeated float y = 2 [packed = true];
inline int calibrationTable::y_size() const {
  return y_.size();
}
inline void calibrationTable::clear_y() {
  y_.Clear();
}
inline float calibrationTable::y(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.y)
  return y_.Get(index);
}
inline void calibrationTable::set_y(int index, float value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.y)
}
inline void calibrationTable::add_y(float value) {
  y_.Add(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.y)
}
inline const ::google::protobuf::RepeatedField< float >&
calibrationTable::y() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.y)
  return y_;
}
inline ::google::protobuf::RepeatedField< float >*
calibrationTable::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.y)
  return &y_;
}

// repeated float b = 3 [packed = true];
inline int calibrationTable::b_size() const {
  return b_.size();
}
inline void calibrationTable::clear_b() {
  b_.Clear();
}
inline float calibrationTable::b(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.b)
  return b_.Get(index);
}
inline void calibrationTable::set_b(int index, float value) {
  b_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.b)
}
inline void calibrationTable::add_b(float value) {
  b_.Add(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.b)
}
inline const ::google::protobuf::RepeatedField< float >&
calibrationTable::b() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.b)
  return b_;
}
inline ::google::protobuf::RepeatedField< float >*
calibrationTable::mutable_b() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.b)
  return &b_;
}

// repeated float c = 4 [packed = true];
inline int calibrationTable::c_size() const {
  return c_.size();
}
inline void calibrationTable::clear_c() {
  c_.Clear();
}
inline float calibrationTable::c(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.c)
  return c_.Get(index);
}
inline void calibrationTable::set_c(int index, float value) {
  c_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.c)
}
inline void calibrationTable::add_c(float value) {
  c_.Add(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.c)
}
inline const ::google::protobuf::RepeatedField< float >&
calibrationTable::c() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.c)
  return c_;
}
inline ::google::protobuf::RepeatedField< float >*
calibrationTable::mutable_c() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.c)
  return &c_;
}

// repeated float d = 5 [packed = true];
inline int calibrationTable::d_size() const {
  return d_.size();
}
inline void calibrationTable::clear_d() {
  d_.Clear();
}
inline float calibrationTable::d(int index) const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.d)
  return d_.Get(index);
}
inline void calibrationTable::set_d(int index, float value) {
  d_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.d)
}
inline void calibrationTable::add_d(float value) {
  d_.Add(value);
  // @@protoc_insertion_point(field_add:pb.calibrationTable.d)
}
inline const ::google::protobuf::RepeatedField< float >&
calibrationTable::d() const {
  // @@protoc_insertion_point(field_list:pb.calibrationTable.d)
  return d_;
}
inline ::google::protobuf::RepeatedField< float >*
calibrationTable::mutable_d() {
  // @@protoc_insertion_point(field_mutable_list:pb.calibrationTable.d)
  return &d_;
}

// optional uint32 spline_method = 6;
inline bool calibrationTable::has_spline_method() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void calibrationTable::set_has_spline_method() {
  _has_bits_[0] |= 0x00000020u;
}
inline void calibrationTable::clear_has_spline_method() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void calibrationTable::clear_spline_method() {
  spline_method_ = 0u;
  clear_has_spline_method();
}
inline ::google::protobuf::uint32 calibrationTable::spline_method() const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.spline_method)
  return spline_method_;
}
inline void calibrationTable::set_spline_method(::google::protobuf::uint32 value) {
  set_has_spline_method();
  spline_method_ = value;
  // @@protoc_insertion_point(field_set:pb.calibrationTable.spline_method)
}

// optional string caltype = 7;
inline bool calibrationTable::has_caltype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void calibrationTable::set_has_caltype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void calibrationTable::clear_has_caltype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void calibrationTable::clear_caltype() {
  if (caltype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caltype_->clear();
  }
  clear_has_caltype();
}
inline const ::std::string& calibrationTable::caltype() const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.caltype)
  return *caltype_;
}
inline void calibrationTable::set_caltype(const ::std::string& value) {
  set_has_caltype();
  if (caltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caltype_ = new ::std::string;
  }
  caltype_->assign(value);
  // @@protoc_insertion_point(field_set:pb.calibrationTable.caltype)
}
inline void calibrationTable::set_caltype(const char* value) {
  set_has_caltype();
  if (caltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caltype_ = new ::std::string;
  }
  caltype_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.calibrationTable.caltype)
}
inline void calibrationTable::set_caltype(const char* value, size_t size) {
  set_has_caltype();
  if (caltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caltype_ = new ::std::string;
  }
  caltype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.calibrationTable.caltype)
}
inline ::std::string* calibrationTable::mutable_caltype() {
  set_has_caltype();
  if (caltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    caltype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.calibrationTable.caltype)
  return caltype_;
}
inline ::std::string* calibrationTable::release_caltype() {
  clear_has_caltype();
  if (caltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = caltype_;
    caltype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void calibrationTable::set_allocated_caltype(::std::string* caltype) {
  if (caltype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete caltype_;
  }
  if (caltype) {
    set_has_caltype();
    caltype_ = caltype;
  } else {
    clear_has_caltype();
    caltype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.calibrationTable.caltype)
}

// optional bool flag = 8;
inline bool calibrationTable::has_flag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void calibrationTable::set_has_flag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void calibrationTable::clear_has_flag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void calibrationTable::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool calibrationTable::flag() const {
  // @@protoc_insertion_point(field_get:pb.calibrationTable.flag)
  return flag_;
}
inline void calibrationTable::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:pb.calibrationTable.flag)
}

// -------------------------------------------------------------------

// biexpTrans

// optional uint32 channelRange = 1;
inline bool biexpTrans::has_channelrange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void biexpTrans::set_has_channelrange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void biexpTrans::clear_has_channelrange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void biexpTrans::clear_channelrange() {
  channelrange_ = 0u;
  clear_has_channelrange();
}
inline ::google::protobuf::uint32 biexpTrans::channelrange() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.channelRange)
  return channelrange_;
}
inline void biexpTrans::set_channelrange(::google::protobuf::uint32 value) {
  set_has_channelrange();
  channelrange_ = value;
  // @@protoc_insertion_point(field_set:pb.biexpTrans.channelRange)
}

// optional float pos = 2;
inline bool biexpTrans::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void biexpTrans::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void biexpTrans::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void biexpTrans::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline float biexpTrans::pos() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.pos)
  return pos_;
}
inline void biexpTrans::set_pos(float value) {
  set_has_pos();
  pos_ = value;
  // @@protoc_insertion_point(field_set:pb.biexpTrans.pos)
}

// optional float neg = 3;
inline bool biexpTrans::has_neg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void biexpTrans::set_has_neg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void biexpTrans::clear_has_neg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void biexpTrans::clear_neg() {
  neg_ = 0;
  clear_has_neg();
}
inline float biexpTrans::neg() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.neg)
  return neg_;
}
inline void biexpTrans::set_neg(float value) {
  set_has_neg();
  neg_ = value;
  // @@protoc_insertion_point(field_set:pb.biexpTrans.neg)
}

// optional float widthBasis = 4;
inline bool biexpTrans::has_widthbasis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void biexpTrans::set_has_widthbasis() {
  _has_bits_[0] |= 0x00000008u;
}
inline void biexpTrans::clear_has_widthbasis() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void biexpTrans::clear_widthbasis() {
  widthbasis_ = 0;
  clear_has_widthbasis();
}
inline float biexpTrans::widthbasis() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.widthBasis)
  return widthbasis_;
}
inline void biexpTrans::set_widthbasis(float value) {
  set_has_widthbasis();
  widthbasis_ = value;
  // @@protoc_insertion_point(field_set:pb.biexpTrans.widthBasis)
}

// optional float maxValue = 5;
inline bool biexpTrans::has_maxvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void biexpTrans::set_has_maxvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void biexpTrans::clear_has_maxvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void biexpTrans::clear_maxvalue() {
  maxvalue_ = 0;
  clear_has_maxvalue();
}
inline float biexpTrans::maxvalue() const {
  // @@protoc_insertion_point(field_get:pb.biexpTrans.maxValue)
  return maxvalue_;
}
inline void biexpTrans::set_maxvalue(float value) {
  set_has_maxvalue();
  maxvalue_ = value;
  // @@protoc_insertion_point(field_set:pb.biexpTrans.maxValue)
}

// -------------------------------------------------------------------

// fasinhTrans

// optional float length = 1;
inline bool fasinhTrans::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fasinhTrans::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fasinhTrans::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fasinhTrans::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float fasinhTrans::length() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.length)
  return length_;
}
inline void fasinhTrans::set_length(float value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.length)
}

// optional float maxRange = 2;
inline bool fasinhTrans::has_maxrange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fasinhTrans::set_has_maxrange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fasinhTrans::clear_has_maxrange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fasinhTrans::clear_maxrange() {
  maxrange_ = 0;
  clear_has_maxrange();
}
inline float fasinhTrans::maxrange() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.maxRange)
  return maxrange_;
}
inline void fasinhTrans::set_maxrange(float value) {
  set_has_maxrange();
  maxrange_ = value;
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.maxRange)
}

// optional float T = 3;
inline bool fasinhTrans::has_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fasinhTrans::set_has_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fasinhTrans::clear_has_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fasinhTrans::clear_t() {
  t_ = 0;
  clear_has_t();
}
inline float fasinhTrans::t() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.T)
  return t_;
}
inline void fasinhTrans::set_t(float value) {
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.T)
}

// optional float A = 4;
inline bool fasinhTrans::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fasinhTrans::set_has_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fasinhTrans::clear_has_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fasinhTrans::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline float fasinhTrans::a() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.A)
  return a_;
}
inline void fasinhTrans::set_a(float value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.A)
}

// optional float M = 5;
inline bool fasinhTrans::has_m() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fasinhTrans::set_has_m() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fasinhTrans::clear_has_m() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fasinhTrans::clear_m() {
  m_ = 0;
  clear_has_m();
}
inline float fasinhTrans::m() const {
  // @@protoc_insertion_point(field_get:pb.fasinhTrans.M)
  return m_;
}
inline void fasinhTrans::set_m(float value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:pb.fasinhTrans.M)
}

// -------------------------------------------------------------------

// scaleTrans

// optional float scale_factor = 1;
inline bool scaleTrans::has_scale_factor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scaleTrans::set_has_scale_factor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scaleTrans::clear_has_scale_factor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scaleTrans::clear_scale_factor() {
  scale_factor_ = 0;
  clear_has_scale_factor();
}
inline float scaleTrans::scale_factor() const {
  // @@protoc_insertion_point(field_get:pb.scaleTrans.scale_factor)
  return scale_factor_;
}
inline void scaleTrans::set_scale_factor(float value) {
  set_has_scale_factor();
  scale_factor_ = value;
  // @@protoc_insertion_point(field_set:pb.scaleTrans.scale_factor)
}

// -------------------------------------------------------------------

// flinTrans

// optional float min = 1;
inline bool flinTrans::has_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flinTrans::set_has_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flinTrans::clear_has_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flinTrans::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline float flinTrans::min() const {
  // @@protoc_insertion_point(field_get:pb.flinTrans.min)
  return min_;
}
inline void flinTrans::set_min(float value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:pb.flinTrans.min)
}

// optional float max = 2;
inline bool flinTrans::has_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flinTrans::set_has_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flinTrans::clear_has_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flinTrans::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline float flinTrans::max() const {
  // @@protoc_insertion_point(field_get:pb.flinTrans.max)
  return max_;
}
inline void flinTrans::set_max(float value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:pb.flinTrans.max)
}

// -------------------------------------------------------------------

// logTrans

// optional float offset = 1;
inline bool logTrans::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void logTrans::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void logTrans::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void logTrans::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline float logTrans::offset() const {
  // @@protoc_insertion_point(field_get:pb.logTrans.offset)
  return offset_;
}
inline void logTrans::set_offset(float value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:pb.logTrans.offset)
}

// optional float decade = 2;
inline bool logTrans::has_decade() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void logTrans::set_has_decade() {
  _has_bits_[0] |= 0x00000002u;
}
inline void logTrans::clear_has_decade() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void logTrans::clear_decade() {
  decade_ = 0;
  clear_has_decade();
}
inline float logTrans::decade() const {
  // @@protoc_insertion_point(field_get:pb.logTrans.decade)
  return decade_;
}
inline void logTrans::set_decade(float value) {
  set_has_decade();
  decade_ = value;
  // @@protoc_insertion_point(field_set:pb.logTrans.decade)
}

// optional float T = 3;
inline bool logTrans::has_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void logTrans::set_has_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void logTrans::clear_has_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void logTrans::clear_t() {
  t_ = 0;
  clear_has_t();
}
inline float logTrans::t() const {
  // @@protoc_insertion_point(field_get:pb.logTrans.T)
  return t_;
}
inline void logTrans::set_t(float value) {
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:pb.logTrans.T)
}

// -------------------------------------------------------------------

// transformation

// optional .pb.calibrationTable calTbl = 1;
inline bool transformation::has_caltbl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void transformation::set_has_caltbl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void transformation::clear_has_caltbl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void transformation::clear_caltbl() {
  if (caltbl_ != NULL) caltbl_->::pb::calibrationTable::Clear();
  clear_has_caltbl();
}
inline const ::pb::calibrationTable& transformation::caltbl() const {
  // @@protoc_insertion_point(field_get:pb.transformation.calTbl)
  return caltbl_ != NULL ? *caltbl_ : *default_instance_->caltbl_;
}
inline ::pb::calibrationTable* transformation::mutable_caltbl() {
  set_has_caltbl();
  if (caltbl_ == NULL) caltbl_ = new ::pb::calibrationTable;
  // @@protoc_insertion_point(field_mutable:pb.transformation.calTbl)
  return caltbl_;
}
inline ::pb::calibrationTable* transformation::release_caltbl() {
  clear_has_caltbl();
  ::pb::calibrationTable* temp = caltbl_;
  caltbl_ = NULL;
  return temp;
}
inline void transformation::set_allocated_caltbl(::pb::calibrationTable* caltbl) {
  delete caltbl_;
  caltbl_ = caltbl;
  if (caltbl) {
    set_has_caltbl();
  } else {
    clear_has_caltbl();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.calTbl)
}

// optional bool isGateOnly = 2;
inline bool transformation::has_isgateonly() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void transformation::set_has_isgateonly() {
  _has_bits_[0] |= 0x00000002u;
}
inline void transformation::clear_has_isgateonly() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void transformation::clear_isgateonly() {
  isgateonly_ = false;
  clear_has_isgateonly();
}
inline bool transformation::isgateonly() const {
  // @@protoc_insertion_point(field_get:pb.transformation.isGateOnly)
  return isgateonly_;
}
inline void transformation::set_isgateonly(bool value) {
  set_has_isgateonly();
  isgateonly_ = value;
  // @@protoc_insertion_point(field_set:pb.transformation.isGateOnly)
}

// optional string name = 4;
inline bool transformation::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void transformation::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void transformation::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void transformation::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& transformation::name() const {
  // @@protoc_insertion_point(field_get:pb.transformation.name)
  return *name_;
}
inline void transformation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.transformation.name)
}
inline void transformation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.transformation.name)
}
inline void transformation::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.transformation.name)
}
inline ::std::string* transformation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.transformation.name)
  return name_;
}
inline ::std::string* transformation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void transformation::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.name)
}

// optional string channel = 5;
inline bool transformation::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void transformation::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void transformation::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void transformation::clear_channel() {
  if (channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& transformation::channel() const {
  // @@protoc_insertion_point(field_get:pb.transformation.channel)
  return *channel_;
}
inline void transformation::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
  // @@protoc_insertion_point(field_set:pb.transformation.channel)
}
inline void transformation::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.transformation.channel)
}
inline void transformation::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.transformation.channel)
}
inline ::std::string* transformation::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.transformation.channel)
  return channel_;
}
inline ::std::string* transformation::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void transformation::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.channel)
}

// optional bool isComputed = 6;
inline bool transformation::has_iscomputed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void transformation::set_has_iscomputed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void transformation::clear_has_iscomputed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void transformation::clear_iscomputed() {
  iscomputed_ = false;
  clear_has_iscomputed();
}
inline bool transformation::iscomputed() const {
  // @@protoc_insertion_point(field_get:pb.transformation.isComputed)
  return iscomputed_;
}
inline void transformation::set_iscomputed(bool value) {
  set_has_iscomputed();
  iscomputed_ = value;
  // @@protoc_insertion_point(field_set:pb.transformation.isComputed)
}

// optional uint32 type = 12;
inline bool transformation::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void transformation::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void transformation::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void transformation::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 transformation::type() const {
  // @@protoc_insertion_point(field_get:pb.transformation.type)
  return type_;
}
inline void transformation::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.transformation.type)
}

// optional .pb.TRANS_TYPE trans_type = 3;
inline bool transformation::has_trans_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void transformation::set_has_trans_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void transformation::clear_has_trans_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void transformation::clear_trans_type() {
  trans_type_ = 0;
  clear_has_trans_type();
}
inline ::pb::TRANS_TYPE transformation::trans_type() const {
  // @@protoc_insertion_point(field_get:pb.transformation.trans_type)
  return static_cast< ::pb::TRANS_TYPE >(trans_type_);
}
inline void transformation::set_trans_type(::pb::TRANS_TYPE value) {
  assert(::pb::TRANS_TYPE_IsValid(value));
  set_has_trans_type();
  trans_type_ = value;
  // @@protoc_insertion_point(field_set:pb.transformation.trans_type)
}

// optional .pb.biexpTrans bt = 7;
inline bool transformation::has_bt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void transformation::set_has_bt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void transformation::clear_has_bt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void transformation::clear_bt() {
  if (bt_ != NULL) bt_->::pb::biexpTrans::Clear();
  clear_has_bt();
}
inline const ::pb::biexpTrans& transformation::bt() const {
  // @@protoc_insertion_point(field_get:pb.transformation.bt)
  return bt_ != NULL ? *bt_ : *default_instance_->bt_;
}
inline ::pb::biexpTrans* transformation::mutable_bt() {
  set_has_bt();
  if (bt_ == NULL) bt_ = new ::pb::biexpTrans;
  // @@protoc_insertion_point(field_mutable:pb.transformation.bt)
  return bt_;
}
inline ::pb::biexpTrans* transformation::release_bt() {
  clear_has_bt();
  ::pb::biexpTrans* temp = bt_;
  bt_ = NULL;
  return temp;
}
inline void transformation::set_allocated_bt(::pb::biexpTrans* bt) {
  delete bt_;
  bt_ = bt;
  if (bt) {
    set_has_bt();
  } else {
    clear_has_bt();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.bt)
}

// optional .pb.logTrans lt = 8;
inline bool transformation::has_lt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void transformation::set_has_lt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void transformation::clear_has_lt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void transformation::clear_lt() {
  if (lt_ != NULL) lt_->::pb::logTrans::Clear();
  clear_has_lt();
}
inline const ::pb::logTrans& transformation::lt() const {
  // @@protoc_insertion_point(field_get:pb.transformation.lt)
  return lt_ != NULL ? *lt_ : *default_instance_->lt_;
}
inline ::pb::logTrans* transformation::mutable_lt() {
  set_has_lt();
  if (lt_ == NULL) lt_ = new ::pb::logTrans;
  // @@protoc_insertion_point(field_mutable:pb.transformation.lt)
  return lt_;
}
inline ::pb::logTrans* transformation::release_lt() {
  clear_has_lt();
  ::pb::logTrans* temp = lt_;
  lt_ = NULL;
  return temp;
}
inline void transformation::set_allocated_lt(::pb::logTrans* lt) {
  delete lt_;
  lt_ = lt;
  if (lt) {
    set_has_lt();
  } else {
    clear_has_lt();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.lt)
}

// optional .pb.flinTrans flt = 9;
inline bool transformation::has_flt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void transformation::set_has_flt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void transformation::clear_has_flt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void transformation::clear_flt() {
  if (flt_ != NULL) flt_->::pb::flinTrans::Clear();
  clear_has_flt();
}
inline const ::pb::flinTrans& transformation::flt() const {
  // @@protoc_insertion_point(field_get:pb.transformation.flt)
  return flt_ != NULL ? *flt_ : *default_instance_->flt_;
}
inline ::pb::flinTrans* transformation::mutable_flt() {
  set_has_flt();
  if (flt_ == NULL) flt_ = new ::pb::flinTrans;
  // @@protoc_insertion_point(field_mutable:pb.transformation.flt)
  return flt_;
}
inline ::pb::flinTrans* transformation::release_flt() {
  clear_has_flt();
  ::pb::flinTrans* temp = flt_;
  flt_ = NULL;
  return temp;
}
inline void transformation::set_allocated_flt(::pb::flinTrans* flt) {
  delete flt_;
  flt_ = flt;
  if (flt) {
    set_has_flt();
  } else {
    clear_has_flt();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.flt)
}

// optional .pb.scaleTrans st = 10;
inline bool transformation::has_st() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void transformation::set_has_st() {
  _has_bits_[0] |= 0x00000400u;
}
inline void transformation::clear_has_st() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void transformation::clear_st() {
  if (st_ != NULL) st_->::pb::scaleTrans::Clear();
  clear_has_st();
}
inline const ::pb::scaleTrans& transformation::st() const {
  // @@protoc_insertion_point(field_get:pb.transformation.st)
  return st_ != NULL ? *st_ : *default_instance_->st_;
}
inline ::pb::scaleTrans* transformation::mutable_st() {
  set_has_st();
  if (st_ == NULL) st_ = new ::pb::scaleTrans;
  // @@protoc_insertion_point(field_mutable:pb.transformation.st)
  return st_;
}
inline ::pb::scaleTrans* transformation::release_st() {
  clear_has_st();
  ::pb::scaleTrans* temp = st_;
  st_ = NULL;
  return temp;
}
inline void transformation::set_allocated_st(::pb::scaleTrans* st) {
  delete st_;
  st_ = st;
  if (st) {
    set_has_st();
  } else {
    clear_has_st();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.st)
}

// optional .pb.fasinhTrans ft = 11;
inline bool transformation::has_ft() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void transformation::set_has_ft() {
  _has_bits_[0] |= 0x00000800u;
}
inline void transformation::clear_has_ft() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void transformation::clear_ft() {
  if (ft_ != NULL) ft_->::pb::fasinhTrans::Clear();
  clear_has_ft();
}
inline const ::pb::fasinhTrans& transformation::ft() const {
  // @@protoc_insertion_point(field_get:pb.transformation.ft)
  return ft_ != NULL ? *ft_ : *default_instance_->ft_;
}
inline ::pb::fasinhTrans* transformation::mutable_ft() {
  set_has_ft();
  if (ft_ == NULL) ft_ = new ::pb::fasinhTrans;
  // @@protoc_insertion_point(field_mutable:pb.transformation.ft)
  return ft_;
}
inline ::pb::fasinhTrans* transformation::release_ft() {
  clear_has_ft();
  ::pb::fasinhTrans* temp = ft_;
  ft_ = NULL;
  return temp;
}
inline void transformation::set_allocated_ft(::pb::fasinhTrans* ft) {
  delete ft_;
  ft_ = ft;
  if (ft) {
    set_has_ft();
  } else {
    clear_has_ft();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.transformation.ft)
}

// -------------------------------------------------------------------

// trans_pair

// required string name = 1;
inline bool trans_pair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void trans_pair::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void trans_pair::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void trans_pair::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& trans_pair::name() const {
  // @@protoc_insertion_point(field_get:pb.trans_pair.name)
  return *name_;
}
inline void trans_pair::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.trans_pair.name)
}
inline void trans_pair::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.trans_pair.name)
}
inline void trans_pair::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.trans_pair.name)
}
inline ::std::string* trans_pair::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.trans_pair.name)
  return name_;
}
inline ::std::string* trans_pair::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void trans_pair::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.trans_pair.name)
}

// required uint64 trans_address = 2;
inline bool trans_pair::has_trans_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void trans_pair::set_has_trans_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void trans_pair::clear_has_trans_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void trans_pair::clear_trans_address() {
  trans_address_ = GOOGLE_ULONGLONG(0);
  clear_has_trans_address();
}
inline ::google::protobuf::uint64 trans_pair::trans_address() const {
  // @@protoc_insertion_point(field_get:pb.trans_pair.trans_address)
  return trans_address_;
}
inline void trans_pair::set_trans_address(::google::protobuf::uint64 value) {
  set_has_trans_address();
  trans_address_ = value;
  // @@protoc_insertion_point(field_set:pb.trans_pair.trans_address)
}

// -------------------------------------------------------------------

// trans_local

// repeated .pb.trans_pair tp = 1;
inline int trans_local::tp_size() const {
  return tp_.size();
}
inline void trans_local::clear_tp() {
  tp_.Clear();
}
inline const ::pb::trans_pair& trans_local::tp(int index) const {
  // @@protoc_insertion_point(field_get:pb.trans_local.tp)
  return tp_.Get(index);
}
inline ::pb::trans_pair* trans_local::mutable_tp(int index) {
  // @@protoc_insertion_point(field_mutable:pb.trans_local.tp)
  return tp_.Mutable(index);
}
inline ::pb::trans_pair* trans_local::add_tp() {
  // @@protoc_insertion_point(field_add:pb.trans_local.tp)
  return tp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::trans_pair >&
trans_local::tp() const {
  // @@protoc_insertion_point(field_list:pb.trans_local.tp)
  return tp_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::trans_pair >*
trans_local::mutable_tp() {
  // @@protoc_insertion_point(field_mutable_list:pb.trans_local.tp)
  return &tp_;
}

// optional string groupName = 2;
inline bool trans_local::has_groupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void trans_local::set_has_groupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void trans_local::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void trans_local::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& trans_local::groupname() const {
  // @@protoc_insertion_point(field_get:pb.trans_local.groupName)
  return *groupname_;
}
inline void trans_local::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.trans_local.groupName)
}
inline void trans_local::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.trans_local.groupName)
}
inline void trans_local::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.trans_local.groupName)
}
inline ::std::string* trans_local::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.trans_local.groupName)
  return groupname_;
}
inline ::std::string* trans_local::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void trans_local::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.trans_local.groupName)
}

// repeated uint32 sampleIDs = 3 [packed = true];
inline int trans_local::sampleids_size() const {
  return sampleids_.size();
}
inline void trans_local::clear_sampleids() {
  sampleids_.Clear();
}
inline ::google::protobuf::uint32 trans_local::sampleids(int index) const {
  // @@protoc_insertion_point(field_get:pb.trans_local.sampleIDs)
  return sampleids_.Get(index);
}
inline void trans_local::set_sampleids(int index, ::google::protobuf::uint32 value) {
  sampleids_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.trans_local.sampleIDs)
}
inline void trans_local::add_sampleids(::google::protobuf::uint32 value) {
  sampleids_.Add(value);
  // @@protoc_insertion_point(field_add:pb.trans_local.sampleIDs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
trans_local::sampleids() const {
  // @@protoc_insertion_point(field_list:pb.trans_local.sampleIDs)
  return sampleids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
trans_local::mutable_sampleids() {
  // @@protoc_insertion_point(field_mutable_list:pb.trans_local.sampleIDs)
  return &sampleids_;
}

// -------------------------------------------------------------------

// POPINDICES

// required uint32 nEvents = 1;
inline bool POPINDICES::has_nevents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void POPINDICES::set_has_nevents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void POPINDICES::clear_has_nevents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void POPINDICES::clear_nevents() {
  nevents_ = 0u;
  clear_has_nevents();
}
inline ::google::protobuf::uint32 POPINDICES::nevents() const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.nEvents)
  return nevents_;
}
inline void POPINDICES::set_nevents(::google::protobuf::uint32 value) {
  set_has_nevents();
  nevents_ = value;
  // @@protoc_insertion_point(field_set:pb.POPINDICES.nEvents)
}

// required .pb.ind_type indtype = 2;
inline bool POPINDICES::has_indtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void POPINDICES::set_has_indtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void POPINDICES::clear_has_indtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void POPINDICES::clear_indtype() {
  indtype_ = 0;
  clear_has_indtype();
}
inline ::pb::ind_type POPINDICES::indtype() const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.indtype)
  return static_cast< ::pb::ind_type >(indtype_);
}
inline void POPINDICES::set_indtype(::pb::ind_type value) {
  assert(::pb::ind_type_IsValid(value));
  set_has_indtype();
  indtype_ = value;
  // @@protoc_insertion_point(field_set:pb.POPINDICES.indtype)
}

// repeated uint32 iInd = 3 [packed = true];
inline int POPINDICES::iind_size() const {
  return iind_.size();
}
inline void POPINDICES::clear_iind() {
  iind_.Clear();
}
inline ::google::protobuf::uint32 POPINDICES::iind(int index) const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.iInd)
  return iind_.Get(index);
}
inline void POPINDICES::set_iind(int index, ::google::protobuf::uint32 value) {
  iind_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.POPINDICES.iInd)
}
inline void POPINDICES::add_iind(::google::protobuf::uint32 value) {
  iind_.Add(value);
  // @@protoc_insertion_point(field_add:pb.POPINDICES.iInd)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
POPINDICES::iind() const {
  // @@protoc_insertion_point(field_list:pb.POPINDICES.iInd)
  return iind_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
POPINDICES::mutable_iind() {
  // @@protoc_insertion_point(field_mutable_list:pb.POPINDICES.iInd)
  return &iind_;
}

// optional bytes bInd = 4;
inline bool POPINDICES::has_bind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void POPINDICES::set_has_bind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void POPINDICES::clear_has_bind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void POPINDICES::clear_bind() {
  if (bind_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_->clear();
  }
  clear_has_bind();
}
inline const ::std::string& POPINDICES::bind() const {
  // @@protoc_insertion_point(field_get:pb.POPINDICES.bInd)
  return *bind_;
}
inline void POPINDICES::set_bind(const ::std::string& value) {
  set_has_bind();
  if (bind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_ = new ::std::string;
  }
  bind_->assign(value);
  // @@protoc_insertion_point(field_set:pb.POPINDICES.bInd)
}
inline void POPINDICES::set_bind(const char* value) {
  set_has_bind();
  if (bind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_ = new ::std::string;
  }
  bind_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.POPINDICES.bInd)
}
inline void POPINDICES::set_bind(const void* value, size_t size) {
  set_has_bind();
  if (bind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_ = new ::std::string;
  }
  bind_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.POPINDICES.bInd)
}
inline ::std::string* POPINDICES::mutable_bind() {
  set_has_bind();
  if (bind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.POPINDICES.bInd)
  return bind_;
}
inline ::std::string* POPINDICES::release_bind() {
  clear_has_bind();
  if (bind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bind_;
    bind_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void POPINDICES::set_allocated_bind(::std::string* bind) {
  if (bind_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bind_;
  }
  if (bind) {
    set_has_bind();
    bind_ = bind;
  } else {
    clear_has_bind();
    bind_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.POPINDICES.bInd)
}

// -------------------------------------------------------------------

// nodeProperties

// required string thisName = 1;
inline bool nodeProperties::has_thisname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void nodeProperties::set_has_thisname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void nodeProperties::clear_has_thisname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void nodeProperties::clear_thisname() {
  if (thisname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_->clear();
  }
  clear_has_thisname();
}
inline const ::std::string& nodeProperties::thisname() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.thisName)
  return *thisname_;
}
inline void nodeProperties::set_thisname(const ::std::string& value) {
  set_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_ = new ::std::string;
  }
  thisname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.nodeProperties.thisName)
}
inline void nodeProperties::set_thisname(const char* value) {
  set_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_ = new ::std::string;
  }
  thisname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.nodeProperties.thisName)
}
inline void nodeProperties::set_thisname(const char* value, size_t size) {
  set_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_ = new ::std::string;
  }
  thisname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.nodeProperties.thisName)
}
inline ::std::string* nodeProperties::mutable_thisname() {
  set_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thisname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.thisName)
  return thisname_;
}
inline ::std::string* nodeProperties::release_thisname() {
  clear_has_thisname();
  if (thisname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thisname_;
    thisname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void nodeProperties::set_allocated_thisname(::std::string* thisname) {
  if (thisname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thisname_;
  }
  if (thisname) {
    set_has_thisname();
    thisname_ = thisname;
  } else {
    clear_has_thisname();
    thisname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.thisName)
}

// repeated .pb.POPSTATS fjStats = 2;
inline int nodeProperties::fjstats_size() const {
  return fjstats_.size();
}
inline void nodeProperties::clear_fjstats() {
  fjstats_.Clear();
}
inline const ::pb::POPSTATS& nodeProperties::fjstats(int index) const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.fjStats)
  return fjstats_.Get(index);
}
inline ::pb::POPSTATS* nodeProperties::mutable_fjstats(int index) {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.fjStats)
  return fjstats_.Mutable(index);
}
inline ::pb::POPSTATS* nodeProperties::add_fjstats() {
  // @@protoc_insertion_point(field_add:pb.nodeProperties.fjStats)
  return fjstats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >&
nodeProperties::fjstats() const {
  // @@protoc_insertion_point(field_list:pb.nodeProperties.fjStats)
  return fjstats_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >*
nodeProperties::mutable_fjstats() {
  // @@protoc_insertion_point(field_mutable_list:pb.nodeProperties.fjStats)
  return &fjstats_;
}

// repeated .pb.POPSTATS fcStats = 3;
inline int nodeProperties::fcstats_size() const {
  return fcstats_.size();
}
inline void nodeProperties::clear_fcstats() {
  fcstats_.Clear();
}
inline const ::pb::POPSTATS& nodeProperties::fcstats(int index) const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.fcStats)
  return fcstats_.Get(index);
}
inline ::pb::POPSTATS* nodeProperties::mutable_fcstats(int index) {
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.fcStats)
  return fcstats_.Mutable(index);
}
inline ::pb::POPSTATS* nodeProperties::add_fcstats() {
  // @@protoc_insertion_point(field_add:pb.nodeProperties.fcStats)
  return fcstats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >&
nodeProperties::fcstats() const {
  // @@protoc_insertion_point(field_list:pb.nodeProperties.fcStats)
  return fcstats_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::POPSTATS >*
nodeProperties::mutable_fcstats() {
  // @@protoc_insertion_point(field_mutable_list:pb.nodeProperties.fcStats)
  return &fcstats_;
}

// required bool hidden = 4;
inline bool nodeProperties::has_hidden() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void nodeProperties::set_has_hidden() {
  _has_bits_[0] |= 0x00000008u;
}
inline void nodeProperties::clear_has_hidden() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void nodeProperties::clear_hidden() {
  hidden_ = false;
  clear_has_hidden();
}
inline bool nodeProperties::hidden() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.hidden)
  return hidden_;
}
inline void nodeProperties::set_hidden(bool value) {
  set_has_hidden();
  hidden_ = value;
  // @@protoc_insertion_point(field_set:pb.nodeProperties.hidden)
}

// optional .pb.POPINDICES indices = 5;
inline bool nodeProperties::has_indices() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void nodeProperties::set_has_indices() {
  _has_bits_[0] |= 0x00000010u;
}
inline void nodeProperties::clear_has_indices() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void nodeProperties::clear_indices() {
  if (indices_ != NULL) indices_->::pb::POPINDICES::Clear();
  clear_has_indices();
}
inline const ::pb::POPINDICES& nodeProperties::indices() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.indices)
  return indices_ != NULL ? *indices_ : *default_instance_->indices_;
}
inline ::pb::POPINDICES* nodeProperties::mutable_indices() {
  set_has_indices();
  if (indices_ == NULL) indices_ = new ::pb::POPINDICES;
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.indices)
  return indices_;
}
inline ::pb::POPINDICES* nodeProperties::release_indices() {
  clear_has_indices();
  ::pb::POPINDICES* temp = indices_;
  indices_ = NULL;
  return temp;
}
inline void nodeProperties::set_allocated_indices(::pb::POPINDICES* indices) {
  delete indices_;
  indices_ = indices;
  if (indices) {
    set_has_indices();
  } else {
    clear_has_indices();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.indices)
}

// optional .pb.gate thisGate = 6;
inline bool nodeProperties::has_thisgate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void nodeProperties::set_has_thisgate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void nodeProperties::clear_has_thisgate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void nodeProperties::clear_thisgate() {
  if (thisgate_ != NULL) thisgate_->::pb::gate::Clear();
  clear_has_thisgate();
}
inline const ::pb::gate& nodeProperties::thisgate() const {
  // @@protoc_insertion_point(field_get:pb.nodeProperties.thisGate)
  return thisgate_ != NULL ? *thisgate_ : *default_instance_->thisgate_;
}
inline ::pb::gate* nodeProperties::mutable_thisgate() {
  set_has_thisgate();
  if (thisgate_ == NULL) thisgate_ = new ::pb::gate;
  // @@protoc_insertion_point(field_mutable:pb.nodeProperties.thisGate)
  return thisgate_;
}
inline ::pb::gate* nodeProperties::release_thisgate() {
  clear_has_thisgate();
  ::pb::gate* temp = thisgate_;
  thisgate_ = NULL;
  return temp;
}
inline void nodeProperties::set_allocated_thisgate(::pb::gate* thisgate) {
  delete thisgate_;
  thisgate_ = thisgate;
  if (thisgate) {
    set_has_thisgate();
  } else {
    clear_has_thisgate();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.nodeProperties.thisGate)
}

// -------------------------------------------------------------------

// treeNodes

// required .pb.nodeProperties node = 1;
inline bool treeNodes::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void treeNodes::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void treeNodes::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void treeNodes::clear_node() {
  if (node_ != NULL) node_->::pb::nodeProperties::Clear();
  clear_has_node();
}
inline const ::pb::nodeProperties& treeNodes::node() const {
  // @@protoc_insertion_point(field_get:pb.treeNodes.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::pb::nodeProperties* treeNodes::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::pb::nodeProperties;
  // @@protoc_insertion_point(field_mutable:pb.treeNodes.node)
  return node_;
}
inline ::pb::nodeProperties* treeNodes::release_node() {
  clear_has_node();
  ::pb::nodeProperties* temp = node_;
  node_ = NULL;
  return temp;
}
inline void treeNodes::set_allocated_node(::pb::nodeProperties* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.treeNodes.node)
}

// optional uint32 parent = 2;
inline bool treeNodes::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void treeNodes::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void treeNodes::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void treeNodes::clear_parent() {
  parent_ = 0u;
  clear_has_parent();
}
inline ::google::protobuf::uint32 treeNodes::parent() const {
  // @@protoc_insertion_point(field_get:pb.treeNodes.parent)
  return parent_;
}
inline void treeNodes::set_parent(::google::protobuf::uint32 value) {
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:pb.treeNodes.parent)
}

// -------------------------------------------------------------------

// populationTree

// repeated .pb.treeNodes node = 1;
inline int populationTree::node_size() const {
  return node_.size();
}
inline void populationTree::clear_node() {
  node_.Clear();
}
inline const ::pb::treeNodes& populationTree::node(int index) const {
  // @@protoc_insertion_point(field_get:pb.populationTree.node)
  return node_.Get(index);
}
inline ::pb::treeNodes* populationTree::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:pb.populationTree.node)
  return node_.Mutable(index);
}
inline ::pb::treeNodes* populationTree::add_node() {
  // @@protoc_insertion_point(field_add:pb.populationTree.node)
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::treeNodes >&
populationTree::node() const {
  // @@protoc_insertion_point(field_list:pb.populationTree.node)
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::treeNodes >*
populationTree::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:pb.populationTree.node)
  return &node_;
}

// -------------------------------------------------------------------

// COMP

// optional string cid = 1;
inline bool COMP::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void COMP::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void COMP::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void COMP::clear_cid() {
  if (cid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& COMP::cid() const {
  // @@protoc_insertion_point(field_get:pb.COMP.cid)
  return *cid_;
}
inline void COMP::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
  // @@protoc_insertion_point(field_set:pb.COMP.cid)
}
inline void COMP::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.COMP.cid)
}
inline void COMP::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.cid)
}
inline ::std::string* COMP::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.COMP.cid)
  return cid_;
}
inline ::std::string* COMP::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void COMP::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.cid)
}

// optional string prefix = 2;
inline bool COMP::has_prefix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void COMP::set_has_prefix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void COMP::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void COMP::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& COMP::prefix() const {
  // @@protoc_insertion_point(field_get:pb.COMP.prefix)
  return *prefix_;
}
inline void COMP::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
  // @@protoc_insertion_point(field_set:pb.COMP.prefix)
}
inline void COMP::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.COMP.prefix)
}
inline void COMP::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.prefix)
}
inline ::std::string* COMP::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.COMP.prefix)
  return prefix_;
}
inline ::std::string* COMP::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void COMP::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.prefix)
}

// optional string suffix = 3;
inline bool COMP::has_suffix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void COMP::set_has_suffix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void COMP::clear_has_suffix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void COMP::clear_suffix() {
  if (suffix_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    suffix_->clear();
  }
  clear_has_suffix();
}
inline const ::std::string& COMP::suffix() const {
  // @@protoc_insertion_point(field_get:pb.COMP.suffix)
  return *suffix_;
}
inline void COMP::set_suffix(const ::std::string& value) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(value);
  // @@protoc_insertion_point(field_set:pb.COMP.suffix)
}
inline void COMP::set_suffix(const char* value) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.COMP.suffix)
}
inline void COMP::set_suffix(const char* value, size_t size) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.suffix)
}
inline ::std::string* COMP::mutable_suffix() {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    suffix_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.COMP.suffix)
  return suffix_;
}
inline ::std::string* COMP::release_suffix() {
  clear_has_suffix();
  if (suffix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = suffix_;
    suffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void COMP::set_allocated_suffix(::std::string* suffix) {
  if (suffix_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete suffix_;
  }
  if (suffix) {
    set_has_suffix();
    suffix_ = suffix;
  } else {
    clear_has_suffix();
    suffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.suffix)
}

// optional string name = 4;
inline bool COMP::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void COMP::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void COMP::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void COMP::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& COMP::name() const {
  // @@protoc_insertion_point(field_get:pb.COMP.name)
  return *name_;
}
inline void COMP::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.COMP.name)
}
inline void COMP::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.COMP.name)
}
inline void COMP::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.name)
}
inline ::std::string* COMP::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.COMP.name)
  return name_;
}
inline ::std::string* COMP::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void COMP::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.name)
}

// optional string comment = 5;
inline bool COMP::has_comment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void COMP::set_has_comment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void COMP::clear_has_comment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void COMP::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& COMP::comment() const {
  // @@protoc_insertion_point(field_get:pb.COMP.comment)
  return *comment_;
}
inline void COMP::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:pb.COMP.comment)
}
inline void COMP::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.COMP.comment)
}
inline void COMP::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.comment)
}
inline ::std::string* COMP::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.COMP.comment)
  return comment_;
}
inline ::std::string* COMP::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void COMP::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.COMP.comment)
}

// repeated string marker = 6;
inline int COMP::marker_size() const {
  return marker_.size();
}
inline void COMP::clear_marker() {
  marker_.Clear();
}
inline const ::std::string& COMP::marker(int index) const {
  // @@protoc_insertion_point(field_get:pb.COMP.marker)
  return marker_.Get(index);
}
inline ::std::string* COMP::mutable_marker(int index) {
  // @@protoc_insertion_point(field_mutable:pb.COMP.marker)
  return marker_.Mutable(index);
}
inline void COMP::set_marker(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.COMP.marker)
  marker_.Mutable(index)->assign(value);
}
inline void COMP::set_marker(int index, const char* value) {
  marker_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.COMP.marker)
}
inline void COMP::set_marker(int index, const char* value, size_t size) {
  marker_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.COMP.marker)
}
inline ::std::string* COMP::add_marker() {
  return marker_.Add();
}
inline void COMP::add_marker(const ::std::string& value) {
  marker_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.COMP.marker)
}
inline void COMP::add_marker(const char* value) {
  marker_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.COMP.marker)
}
inline void COMP::add_marker(const char* value, size_t size) {
  marker_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.COMP.marker)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
COMP::marker() const {
  // @@protoc_insertion_point(field_list:pb.COMP.marker)
  return marker_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
COMP::mutable_marker() {
  // @@protoc_insertion_point(field_mutable_list:pb.COMP.marker)
  return &marker_;
}

// repeated float spillOver = 7;
inline int COMP::spillover_size() const {
  return spillover_.size();
}
inline void COMP::clear_spillover() {
  spillover_.Clear();
}
inline float COMP::spillover(int index) const {
  // @@protoc_insertion_point(field_get:pb.COMP.spillOver)
  return spillover_.Get(index);
}
inline void COMP::set_spillover(int index, float value) {
  spillover_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.COMP.spillOver)
}
inline void COMP::add_spillover(float value) {
  spillover_.Add(value);
  // @@protoc_insertion_point(field_add:pb.COMP.spillOver)
}
inline const ::google::protobuf::RepeatedField< float >&
COMP::spillover() const {
  // @@protoc_insertion_point(field_list:pb.COMP.spillOver)
  return spillover_;
}
inline ::google::protobuf::RepeatedField< float >*
COMP::mutable_spillover() {
  // @@protoc_insertion_point(field_mutable_list:pb.COMP.spillOver)
  return &spillover_;
}

// -------------------------------------------------------------------

// PARAM

// optional string param = 1;
inline bool PARAM::has_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PARAM::set_has_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PARAM::clear_has_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PARAM::clear_param() {
  if (param_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    param_->clear();
  }
  clear_has_param();
}
inline const ::std::string& PARAM::param() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.param)
  return *param_;
}
inline void PARAM::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    param_ = new ::std::string;
  }
  param_->assign(value);
  // @@protoc_insertion_point(field_set:pb.PARAM.param)
}
inline void PARAM::set_param(const char* value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    param_ = new ::std::string;
  }
  param_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PARAM.param)
}
inline void PARAM::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PARAM.param)
}
inline ::std::string* PARAM::mutable_param() {
  set_has_param();
  if (param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    param_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.PARAM.param)
  return param_;
}
inline ::std::string* PARAM::release_param() {
  clear_has_param();
  if (param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PARAM::set_allocated_param(::std::string* param) {
  if (param_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.PARAM.param)
}

// optional bool log = 2;
inline bool PARAM::has_log() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PARAM::set_has_log() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PARAM::clear_has_log() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PARAM::clear_log() {
  log_ = false;
  clear_has_log();
}
inline bool PARAM::log() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.log)
  return log_;
}
inline void PARAM::set_log(bool value) {
  set_has_log();
  log_ = value;
  // @@protoc_insertion_point(field_set:pb.PARAM.log)
}

// optional uint32 range = 3;
inline bool PARAM::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PARAM::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PARAM::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PARAM::clear_range() {
  range_ = 0u;
  clear_has_range();
}
inline ::google::protobuf::uint32 PARAM::range() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.range)
  return range_;
}
inline void PARAM::set_range(::google::protobuf::uint32 value) {
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:pb.PARAM.range)
}

// optional uint32 highValue = 4;
inline bool PARAM::has_highvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PARAM::set_has_highvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PARAM::clear_has_highvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PARAM::clear_highvalue() {
  highvalue_ = 0u;
  clear_has_highvalue();
}
inline ::google::protobuf::uint32 PARAM::highvalue() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.highValue)
  return highvalue_;
}
inline void PARAM::set_highvalue(::google::protobuf::uint32 value) {
  set_has_highvalue();
  highvalue_ = value;
  // @@protoc_insertion_point(field_set:pb.PARAM.highValue)
}

// optional uint32 calibrationIndex = 5;
inline bool PARAM::has_calibrationindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PARAM::set_has_calibrationindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PARAM::clear_has_calibrationindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PARAM::clear_calibrationindex() {
  calibrationindex_ = 0u;
  clear_has_calibrationindex();
}
inline ::google::protobuf::uint32 PARAM::calibrationindex() const {
  // @@protoc_insertion_point(field_get:pb.PARAM.calibrationIndex)
  return calibrationindex_;
}
inline void PARAM::set_calibrationindex(::google::protobuf::uint32 value) {
  set_has_calibrationindex();
  calibrationindex_ = value;
  // @@protoc_insertion_point(field_set:pb.PARAM.calibrationIndex)
}

// -------------------------------------------------------------------

// GatingHierarchy

// required .pb.populationTree tree = 2;
inline bool GatingHierarchy::has_tree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GatingHierarchy::set_has_tree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GatingHierarchy::clear_has_tree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GatingHierarchy::clear_tree() {
  if (tree_ != NULL) tree_->::pb::populationTree::Clear();
  clear_has_tree();
}
inline const ::pb::populationTree& GatingHierarchy::tree() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.tree)
  return tree_ != NULL ? *tree_ : *default_instance_->tree_;
}
inline ::pb::populationTree* GatingHierarchy::mutable_tree() {
  set_has_tree();
  if (tree_ == NULL) tree_ = new ::pb::populationTree;
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.tree)
  return tree_;
}
inline ::pb::populationTree* GatingHierarchy::release_tree() {
  clear_has_tree();
  ::pb::populationTree* temp = tree_;
  tree_ = NULL;
  return temp;
}
inline void GatingHierarchy::set_allocated_tree(::pb::populationTree* tree) {
  delete tree_;
  tree_ = tree;
  if (tree) {
    set_has_tree();
  } else {
    clear_has_tree();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GatingHierarchy.tree)
}

// optional .pb.COMP comp = 1;
inline bool GatingHierarchy::has_comp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GatingHierarchy::set_has_comp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GatingHierarchy::clear_has_comp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GatingHierarchy::clear_comp() {
  if (comp_ != NULL) comp_->::pb::COMP::Clear();
  clear_has_comp();
}
inline const ::pb::COMP& GatingHierarchy::comp() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.comp)
  return comp_ != NULL ? *comp_ : *default_instance_->comp_;
}
inline ::pb::COMP* GatingHierarchy::mutable_comp() {
  set_has_comp();
  if (comp_ == NULL) comp_ = new ::pb::COMP;
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.comp)
  return comp_;
}
inline ::pb::COMP* GatingHierarchy::release_comp() {
  clear_has_comp();
  ::pb::COMP* temp = comp_;
  comp_ = NULL;
  return temp;
}
inline void GatingHierarchy::set_allocated_comp(::pb::COMP* comp) {
  delete comp_;
  comp_ = comp;
  if (comp) {
    set_has_comp();
  } else {
    clear_has_comp();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GatingHierarchy.comp)
}

// optional bool isLoaded = 3;
inline bool GatingHierarchy::has_isloaded() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GatingHierarchy::set_has_isloaded() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GatingHierarchy::clear_has_isloaded() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GatingHierarchy::clear_isloaded() {
  isloaded_ = false;
  clear_has_isloaded();
}
inline bool GatingHierarchy::isloaded() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.isLoaded)
  return isloaded_;
}
inline void GatingHierarchy::set_isloaded(bool value) {
  set_has_isloaded();
  isloaded_ = value;
  // @@protoc_insertion_point(field_set:pb.GatingHierarchy.isLoaded)
}

// repeated .pb.PARAM transFlag = 4;
inline int GatingHierarchy::transflag_size() const {
  return transflag_.size();
}
inline void GatingHierarchy::clear_transflag() {
  transflag_.Clear();
}
inline const ::pb::PARAM& GatingHierarchy::transflag(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.transFlag)
  return transflag_.Get(index);
}
inline ::pb::PARAM* GatingHierarchy::mutable_transflag(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.transFlag)
  return transflag_.Mutable(index);
}
inline ::pb::PARAM* GatingHierarchy::add_transflag() {
  // @@protoc_insertion_point(field_add:pb.GatingHierarchy.transFlag)
  return transflag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PARAM >&
GatingHierarchy::transflag() const {
  // @@protoc_insertion_point(field_list:pb.GatingHierarchy.transFlag)
  return transflag_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PARAM >*
GatingHierarchy::mutable_transflag() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingHierarchy.transFlag)
  return &transflag_;
}

// optional .pb.trans_local trans = 5;
inline bool GatingHierarchy::has_trans() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GatingHierarchy::set_has_trans() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GatingHierarchy::clear_has_trans() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GatingHierarchy::clear_trans() {
  if (trans_ != NULL) trans_->::pb::trans_local::Clear();
  clear_has_trans();
}
inline const ::pb::trans_local& GatingHierarchy::trans() const {
  // @@protoc_insertion_point(field_get:pb.GatingHierarchy.trans)
  return trans_ != NULL ? *trans_ : *default_instance_->trans_;
}
inline ::pb::trans_local* GatingHierarchy::mutable_trans() {
  set_has_trans();
  if (trans_ == NULL) trans_ = new ::pb::trans_local;
  // @@protoc_insertion_point(field_mutable:pb.GatingHierarchy.trans)
  return trans_;
}
inline ::pb::trans_local* GatingHierarchy::release_trans() {
  clear_has_trans();
  ::pb::trans_local* temp = trans_;
  trans_ = NULL;
  return temp;
}
inline void GatingHierarchy::set_allocated_trans(::pb::trans_local* trans) {
  delete trans_;
  trans_ = trans;
  if (trans) {
    set_has_trans();
  } else {
    clear_has_trans();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.GatingHierarchy.trans)
}

// -------------------------------------------------------------------

// TRANS_TBL

// required uint64 trans_address = 1;
inline bool TRANS_TBL::has_trans_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRANS_TBL::set_has_trans_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRANS_TBL::clear_has_trans_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRANS_TBL::clear_trans_address() {
  trans_address_ = GOOGLE_ULONGLONG(0);
  clear_has_trans_address();
}
inline ::google::protobuf::uint64 TRANS_TBL::trans_address() const {
  // @@protoc_insertion_point(field_get:pb.TRANS_TBL.trans_address)
  return trans_address_;
}
inline void TRANS_TBL::set_trans_address(::google::protobuf::uint64 value) {
  set_has_trans_address();
  trans_address_ = value;
  // @@protoc_insertion_point(field_set:pb.TRANS_TBL.trans_address)
}

// optional .pb.transformation trans = 2;
inline bool TRANS_TBL::has_trans() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRANS_TBL::set_has_trans() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRANS_TBL::clear_has_trans() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRANS_TBL::clear_trans() {
  if (trans_ != NULL) trans_->::pb::transformation::Clear();
  clear_has_trans();
}
inline const ::pb::transformation& TRANS_TBL::trans() const {
  // @@protoc_insertion_point(field_get:pb.TRANS_TBL.trans)
  return trans_ != NULL ? *trans_ : *default_instance_->trans_;
}
inline ::pb::transformation* TRANS_TBL::mutable_trans() {
  set_has_trans();
  if (trans_ == NULL) trans_ = new ::pb::transformation;
  // @@protoc_insertion_point(field_mutable:pb.TRANS_TBL.trans)
  return trans_;
}
inline ::pb::transformation* TRANS_TBL::release_trans() {
  clear_has_trans();
  ::pb::transformation* temp = trans_;
  trans_ = NULL;
  return temp;
}
inline void TRANS_TBL::set_allocated_trans(::pb::transformation* trans) {
  delete trans_;
  trans_ = trans;
  if (trans) {
    set_has_trans();
  } else {
    clear_has_trans();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.TRANS_TBL.trans)
}

// -------------------------------------------------------------------

// GatingSet

// repeated .pb.TRANS_TBL trans_tbl = 2;
inline int GatingSet::trans_tbl_size() const {
  return trans_tbl_.size();
}
inline void GatingSet::clear_trans_tbl() {
  trans_tbl_.Clear();
}
inline const ::pb::TRANS_TBL& GatingSet::trans_tbl(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.trans_tbl)
  return trans_tbl_.Get(index);
}
inline ::pb::TRANS_TBL* GatingSet::mutable_trans_tbl(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.trans_tbl)
  return trans_tbl_.Mutable(index);
}
inline ::pb::TRANS_TBL* GatingSet::add_trans_tbl() {
  // @@protoc_insertion_point(field_add:pb.GatingSet.trans_tbl)
  return trans_tbl_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TRANS_TBL >&
GatingSet::trans_tbl() const {
  // @@protoc_insertion_point(field_list:pb.GatingSet.trans_tbl)
  return trans_tbl_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TRANS_TBL >*
GatingSet::mutable_trans_tbl() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingSet.trans_tbl)
  return &trans_tbl_;
}

// repeated string sampleName = 1;
inline int GatingSet::samplename_size() const {
  return samplename_.size();
}
inline void GatingSet::clear_samplename() {
  samplename_.Clear();
}
inline const ::std::string& GatingSet::samplename(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.sampleName)
  return samplename_.Get(index);
}
inline ::std::string* GatingSet::mutable_samplename(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.sampleName)
  return samplename_.Mutable(index);
}
inline void GatingSet::set_samplename(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.GatingSet.sampleName)
  samplename_.Mutable(index)->assign(value);
}
inline void GatingSet::set_samplename(int index, const char* value) {
  samplename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GatingSet.sampleName)
}
inline void GatingSet::set_samplename(int index, const char* value, size_t size) {
  samplename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GatingSet.sampleName)
}
inline ::std::string* GatingSet::add_samplename() {
  return samplename_.Add();
}
inline void GatingSet::add_samplename(const ::std::string& value) {
  samplename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.GatingSet.sampleName)
}
inline void GatingSet::add_samplename(const char* value) {
  samplename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.GatingSet.sampleName)
}
inline void GatingSet::add_samplename(const char* value, size_t size) {
  samplename_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.GatingSet.sampleName)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GatingSet::samplename() const {
  // @@protoc_insertion_point(field_list:pb.GatingSet.sampleName)
  return samplename_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GatingSet::mutable_samplename() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingSet.sampleName)
  return &samplename_;
}

// optional uint64 globalBiExpTrans = 3;
inline bool GatingSet::has_globalbiexptrans() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GatingSet::set_has_globalbiexptrans() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GatingSet::clear_has_globalbiexptrans() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GatingSet::clear_globalbiexptrans() {
  globalbiexptrans_ = GOOGLE_ULONGLONG(0);
  clear_has_globalbiexptrans();
}
inline ::google::protobuf::uint64 GatingSet::globalbiexptrans() const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.globalBiExpTrans)
  return globalbiexptrans_;
}
inline void GatingSet::set_globalbiexptrans(::google::protobuf::uint64 value) {
  set_has_globalbiexptrans();
  globalbiexptrans_ = value;
  // @@protoc_insertion_point(field_set:pb.GatingSet.globalBiExpTrans)
}

// optional uint64 globalLinTrans = 4;
inline bool GatingSet::has_globallintrans() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GatingSet::set_has_globallintrans() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GatingSet::clear_has_globallintrans() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GatingSet::clear_globallintrans() {
  globallintrans_ = GOOGLE_ULONGLONG(0);
  clear_has_globallintrans();
}
inline ::google::protobuf::uint64 GatingSet::globallintrans() const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.globalLinTrans)
  return globallintrans_;
}
inline void GatingSet::set_globallintrans(::google::protobuf::uint64 value) {
  set_has_globallintrans();
  globallintrans_ = value;
  // @@protoc_insertion_point(field_set:pb.GatingSet.globalLinTrans)
}

// repeated .pb.trans_local gTrans = 5;
inline int GatingSet::gtrans_size() const {
  return gtrans_.size();
}
inline void GatingSet::clear_gtrans() {
  gtrans_.Clear();
}
inline const ::pb::trans_local& GatingSet::gtrans(int index) const {
  // @@protoc_insertion_point(field_get:pb.GatingSet.gTrans)
  return gtrans_.Get(index);
}
inline ::pb::trans_local* GatingSet::mutable_gtrans(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GatingSet.gTrans)
  return gtrans_.Mutable(index);
}
inline ::pb::trans_local* GatingSet::add_gtrans() {
  // @@protoc_insertion_point(field_add:pb.GatingSet.gTrans)
  return gtrans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::trans_local >&
GatingSet::gtrans() const {
  // @@protoc_insertion_point(field_list:pb.GatingSet.gTrans)
  return gtrans_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::trans_local >*
GatingSet::mutable_gtrans() {
  // @@protoc_insertion_point(field_mutable_list:pb.GatingSet.gTrans)
  return &gtrans_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::GATE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::GATE_TYPE>() {
  return ::pb::GATE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::pb::ind_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ind_type>() {
  return ::pb::ind_type_descriptor();
}
template <> struct is_proto_enum< ::pb::TRANS_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::TRANS_TYPE>() {
  return ::pb::TRANS_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GatingSet_2eproto__INCLUDED
